
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Merchant
 * 
 */
export type Merchant = $Result.DefaultSelection<Prisma.$MerchantPayload>
/**
 * Model POSIntegration
 * 
 */
export type POSIntegration = $Result.DefaultSelection<Prisma.$POSIntegrationPayload>
/**
 * Model Location
 * 
 */
export type Location = $Result.DefaultSelection<Prisma.$LocationPayload>
/**
 * Model Customer
 * 
 */
export type Customer = $Result.DefaultSelection<Prisma.$CustomerPayload>
/**
 * Model LinkedCard
 * 
 */
export type LinkedCard = $Result.DefaultSelection<Prisma.$LinkedCardPayload>
/**
 * Model Transaction
 * 
 */
export type Transaction = $Result.DefaultSelection<Prisma.$TransactionPayload>
/**
 * Model CustomerBalance
 * 
 */
export type CustomerBalance = $Result.DefaultSelection<Prisma.$CustomerBalancePayload>
/**
 * Model Reward
 * 
 */
export type Reward = $Result.DefaultSelection<Prisma.$RewardPayload>
/**
 * Model POSRewardItem
 * 
 */
export type POSRewardItem = $Result.DefaultSelection<Prisma.$POSRewardItemPayload>
/**
 * Model Redemption
 * 
 */
export type Redemption = $Result.DefaultSelection<Prisma.$RedemptionPayload>
/**
 * Model CustomerItemCount
 * 
 */
export type CustomerItemCount = $Result.DefaultSelection<Prisma.$CustomerItemCountPayload>
/**
 * Model LedgerEntry
 * 
 */
export type LedgerEntry = $Result.DefaultSelection<Prisma.$LedgerEntryPayload>
/**
 * Model WebhookLog
 * 
 */
export type WebhookLog = $Result.DefaultSelection<Prisma.$WebhookLogPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const POSProvider: {
  SQUARE: 'SQUARE'
};

export type POSProvider = (typeof POSProvider)[keyof typeof POSProvider]


export const TransactionStatus: {
  PENDING: 'PENDING',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED',
  REFUNDED: 'REFUNDED'
};

export type TransactionStatus = (typeof TransactionStatus)[keyof typeof TransactionStatus]


export const RewardType: {
  POINTS_BASED: 'POINTS_BASED',
  ITEM_BASED: 'ITEM_BASED'
};

export type RewardType = (typeof RewardType)[keyof typeof RewardType]


export const RedemptionStatus: {
  PENDING: 'PENDING',
  REDEEMED: 'REDEEMED',
  CANCELLED: 'CANCELLED',
  EXPIRED: 'EXPIRED'
};

export type RedemptionStatus = (typeof RedemptionStatus)[keyof typeof RedemptionStatus]


export const LedgerEntryType: {
  EARN: 'EARN',
  REDEEM: 'REDEEM',
  REFUND: 'REFUND'
};

export type LedgerEntryType = (typeof LedgerEntryType)[keyof typeof LedgerEntryType]


export const WebhookStatus: {
  PENDING: 'PENDING',
  PROCESSED: 'PROCESSED',
  FAILED: 'FAILED'
};

export type WebhookStatus = (typeof WebhookStatus)[keyof typeof WebhookStatus]

}

export type POSProvider = $Enums.POSProvider

export const POSProvider: typeof $Enums.POSProvider

export type TransactionStatus = $Enums.TransactionStatus

export const TransactionStatus: typeof $Enums.TransactionStatus

export type RewardType = $Enums.RewardType

export const RewardType: typeof $Enums.RewardType

export type RedemptionStatus = $Enums.RedemptionStatus

export const RedemptionStatus: typeof $Enums.RedemptionStatus

export type LedgerEntryType = $Enums.LedgerEntryType

export const LedgerEntryType: typeof $Enums.LedgerEntryType

export type WebhookStatus = $Enums.WebhookStatus

export const WebhookStatus: typeof $Enums.WebhookStatus

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Merchants
 * const merchants = await prisma.merchant.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Merchants
   * const merchants = await prisma.merchant.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.merchant`: Exposes CRUD operations for the **Merchant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Merchants
    * const merchants = await prisma.merchant.findMany()
    * ```
    */
  get merchant(): Prisma.MerchantDelegate<ExtArgs>;

  /**
   * `prisma.pOSIntegration`: Exposes CRUD operations for the **POSIntegration** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more POSIntegrations
    * const pOSIntegrations = await prisma.pOSIntegration.findMany()
    * ```
    */
  get pOSIntegration(): Prisma.POSIntegrationDelegate<ExtArgs>;

  /**
   * `prisma.location`: Exposes CRUD operations for the **Location** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Locations
    * const locations = await prisma.location.findMany()
    * ```
    */
  get location(): Prisma.LocationDelegate<ExtArgs>;

  /**
   * `prisma.customer`: Exposes CRUD operations for the **Customer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Customers
    * const customers = await prisma.customer.findMany()
    * ```
    */
  get customer(): Prisma.CustomerDelegate<ExtArgs>;

  /**
   * `prisma.linkedCard`: Exposes CRUD operations for the **LinkedCard** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LinkedCards
    * const linkedCards = await prisma.linkedCard.findMany()
    * ```
    */
  get linkedCard(): Prisma.LinkedCardDelegate<ExtArgs>;

  /**
   * `prisma.transaction`: Exposes CRUD operations for the **Transaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transactions
    * const transactions = await prisma.transaction.findMany()
    * ```
    */
  get transaction(): Prisma.TransactionDelegate<ExtArgs>;

  /**
   * `prisma.customerBalance`: Exposes CRUD operations for the **CustomerBalance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CustomerBalances
    * const customerBalances = await prisma.customerBalance.findMany()
    * ```
    */
  get customerBalance(): Prisma.CustomerBalanceDelegate<ExtArgs>;

  /**
   * `prisma.reward`: Exposes CRUD operations for the **Reward** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Rewards
    * const rewards = await prisma.reward.findMany()
    * ```
    */
  get reward(): Prisma.RewardDelegate<ExtArgs>;

  /**
   * `prisma.pOSRewardItem`: Exposes CRUD operations for the **POSRewardItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more POSRewardItems
    * const pOSRewardItems = await prisma.pOSRewardItem.findMany()
    * ```
    */
  get pOSRewardItem(): Prisma.POSRewardItemDelegate<ExtArgs>;

  /**
   * `prisma.redemption`: Exposes CRUD operations for the **Redemption** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Redemptions
    * const redemptions = await prisma.redemption.findMany()
    * ```
    */
  get redemption(): Prisma.RedemptionDelegate<ExtArgs>;

  /**
   * `prisma.customerItemCount`: Exposes CRUD operations for the **CustomerItemCount** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CustomerItemCounts
    * const customerItemCounts = await prisma.customerItemCount.findMany()
    * ```
    */
  get customerItemCount(): Prisma.CustomerItemCountDelegate<ExtArgs>;

  /**
   * `prisma.ledgerEntry`: Exposes CRUD operations for the **LedgerEntry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LedgerEntries
    * const ledgerEntries = await prisma.ledgerEntry.findMany()
    * ```
    */
  get ledgerEntry(): Prisma.LedgerEntryDelegate<ExtArgs>;

  /**
   * `prisma.webhookLog`: Exposes CRUD operations for the **WebhookLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WebhookLogs
    * const webhookLogs = await prisma.webhookLog.findMany()
    * ```
    */
  get webhookLog(): Prisma.WebhookLogDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Merchant: 'Merchant',
    POSIntegration: 'POSIntegration',
    Location: 'Location',
    Customer: 'Customer',
    LinkedCard: 'LinkedCard',
    Transaction: 'Transaction',
    CustomerBalance: 'CustomerBalance',
    Reward: 'Reward',
    POSRewardItem: 'POSRewardItem',
    Redemption: 'Redemption',
    CustomerItemCount: 'CustomerItemCount',
    LedgerEntry: 'LedgerEntry',
    WebhookLog: 'WebhookLog'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "merchant" | "pOSIntegration" | "location" | "customer" | "linkedCard" | "transaction" | "customerBalance" | "reward" | "pOSRewardItem" | "redemption" | "customerItemCount" | "ledgerEntry" | "webhookLog"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Merchant: {
        payload: Prisma.$MerchantPayload<ExtArgs>
        fields: Prisma.MerchantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MerchantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MerchantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MerchantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MerchantPayload>
          }
          findFirst: {
            args: Prisma.MerchantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MerchantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MerchantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MerchantPayload>
          }
          findMany: {
            args: Prisma.MerchantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MerchantPayload>[]
          }
          create: {
            args: Prisma.MerchantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MerchantPayload>
          }
          createMany: {
            args: Prisma.MerchantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MerchantCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MerchantPayload>[]
          }
          delete: {
            args: Prisma.MerchantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MerchantPayload>
          }
          update: {
            args: Prisma.MerchantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MerchantPayload>
          }
          deleteMany: {
            args: Prisma.MerchantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MerchantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MerchantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MerchantPayload>
          }
          aggregate: {
            args: Prisma.MerchantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMerchant>
          }
          groupBy: {
            args: Prisma.MerchantGroupByArgs<ExtArgs>
            result: $Utils.Optional<MerchantGroupByOutputType>[]
          }
          count: {
            args: Prisma.MerchantCountArgs<ExtArgs>
            result: $Utils.Optional<MerchantCountAggregateOutputType> | number
          }
        }
      }
      POSIntegration: {
        payload: Prisma.$POSIntegrationPayload<ExtArgs>
        fields: Prisma.POSIntegrationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.POSIntegrationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$POSIntegrationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.POSIntegrationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$POSIntegrationPayload>
          }
          findFirst: {
            args: Prisma.POSIntegrationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$POSIntegrationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.POSIntegrationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$POSIntegrationPayload>
          }
          findMany: {
            args: Prisma.POSIntegrationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$POSIntegrationPayload>[]
          }
          create: {
            args: Prisma.POSIntegrationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$POSIntegrationPayload>
          }
          createMany: {
            args: Prisma.POSIntegrationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.POSIntegrationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$POSIntegrationPayload>[]
          }
          delete: {
            args: Prisma.POSIntegrationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$POSIntegrationPayload>
          }
          update: {
            args: Prisma.POSIntegrationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$POSIntegrationPayload>
          }
          deleteMany: {
            args: Prisma.POSIntegrationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.POSIntegrationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.POSIntegrationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$POSIntegrationPayload>
          }
          aggregate: {
            args: Prisma.POSIntegrationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePOSIntegration>
          }
          groupBy: {
            args: Prisma.POSIntegrationGroupByArgs<ExtArgs>
            result: $Utils.Optional<POSIntegrationGroupByOutputType>[]
          }
          count: {
            args: Prisma.POSIntegrationCountArgs<ExtArgs>
            result: $Utils.Optional<POSIntegrationCountAggregateOutputType> | number
          }
        }
      }
      Location: {
        payload: Prisma.$LocationPayload<ExtArgs>
        fields: Prisma.LocationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LocationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LocationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          findFirst: {
            args: Prisma.LocationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LocationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          findMany: {
            args: Prisma.LocationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>[]
          }
          create: {
            args: Prisma.LocationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          createMany: {
            args: Prisma.LocationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LocationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>[]
          }
          delete: {
            args: Prisma.LocationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          update: {
            args: Prisma.LocationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          deleteMany: {
            args: Prisma.LocationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LocationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LocationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          aggregate: {
            args: Prisma.LocationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLocation>
          }
          groupBy: {
            args: Prisma.LocationGroupByArgs<ExtArgs>
            result: $Utils.Optional<LocationGroupByOutputType>[]
          }
          count: {
            args: Prisma.LocationCountArgs<ExtArgs>
            result: $Utils.Optional<LocationCountAggregateOutputType> | number
          }
        }
      }
      Customer: {
        payload: Prisma.$CustomerPayload<ExtArgs>
        fields: Prisma.CustomerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findFirst: {
            args: Prisma.CustomerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findMany: {
            args: Prisma.CustomerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          create: {
            args: Prisma.CustomerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          createMany: {
            args: Prisma.CustomerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustomerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          delete: {
            args: Prisma.CustomerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          update: {
            args: Prisma.CustomerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          deleteMany: {
            args: Prisma.CustomerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CustomerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          aggregate: {
            args: Prisma.CustomerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomer>
          }
          groupBy: {
            args: Prisma.CustomerGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomerCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerCountAggregateOutputType> | number
          }
        }
      }
      LinkedCard: {
        payload: Prisma.$LinkedCardPayload<ExtArgs>
        fields: Prisma.LinkedCardFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LinkedCardFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LinkedCardPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LinkedCardFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LinkedCardPayload>
          }
          findFirst: {
            args: Prisma.LinkedCardFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LinkedCardPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LinkedCardFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LinkedCardPayload>
          }
          findMany: {
            args: Prisma.LinkedCardFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LinkedCardPayload>[]
          }
          create: {
            args: Prisma.LinkedCardCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LinkedCardPayload>
          }
          createMany: {
            args: Prisma.LinkedCardCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LinkedCardCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LinkedCardPayload>[]
          }
          delete: {
            args: Prisma.LinkedCardDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LinkedCardPayload>
          }
          update: {
            args: Prisma.LinkedCardUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LinkedCardPayload>
          }
          deleteMany: {
            args: Prisma.LinkedCardDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LinkedCardUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LinkedCardUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LinkedCardPayload>
          }
          aggregate: {
            args: Prisma.LinkedCardAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLinkedCard>
          }
          groupBy: {
            args: Prisma.LinkedCardGroupByArgs<ExtArgs>
            result: $Utils.Optional<LinkedCardGroupByOutputType>[]
          }
          count: {
            args: Prisma.LinkedCardCountArgs<ExtArgs>
            result: $Utils.Optional<LinkedCardCountAggregateOutputType> | number
          }
        }
      }
      Transaction: {
        payload: Prisma.$TransactionPayload<ExtArgs>
        fields: Prisma.TransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findFirst: {
            args: Prisma.TransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findMany: {
            args: Prisma.TransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          create: {
            args: Prisma.TransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          createMany: {
            args: Prisma.TransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TransactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          delete: {
            args: Prisma.TransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          update: {
            args: Prisma.TransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          deleteMany: {
            args: Prisma.TransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          aggregate: {
            args: Prisma.TransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransaction>
          }
          groupBy: {
            args: Prisma.TransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.TransactionCountArgs<ExtArgs>
            result: $Utils.Optional<TransactionCountAggregateOutputType> | number
          }
        }
      }
      CustomerBalance: {
        payload: Prisma.$CustomerBalancePayload<ExtArgs>
        fields: Prisma.CustomerBalanceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerBalanceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerBalancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerBalanceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerBalancePayload>
          }
          findFirst: {
            args: Prisma.CustomerBalanceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerBalancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerBalanceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerBalancePayload>
          }
          findMany: {
            args: Prisma.CustomerBalanceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerBalancePayload>[]
          }
          create: {
            args: Prisma.CustomerBalanceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerBalancePayload>
          }
          createMany: {
            args: Prisma.CustomerBalanceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustomerBalanceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerBalancePayload>[]
          }
          delete: {
            args: Prisma.CustomerBalanceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerBalancePayload>
          }
          update: {
            args: Prisma.CustomerBalanceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerBalancePayload>
          }
          deleteMany: {
            args: Prisma.CustomerBalanceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerBalanceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CustomerBalanceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerBalancePayload>
          }
          aggregate: {
            args: Prisma.CustomerBalanceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomerBalance>
          }
          groupBy: {
            args: Prisma.CustomerBalanceGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerBalanceGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomerBalanceCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerBalanceCountAggregateOutputType> | number
          }
        }
      }
      Reward: {
        payload: Prisma.$RewardPayload<ExtArgs>
        fields: Prisma.RewardFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RewardFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RewardFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardPayload>
          }
          findFirst: {
            args: Prisma.RewardFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RewardFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardPayload>
          }
          findMany: {
            args: Prisma.RewardFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardPayload>[]
          }
          create: {
            args: Prisma.RewardCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardPayload>
          }
          createMany: {
            args: Prisma.RewardCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RewardCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardPayload>[]
          }
          delete: {
            args: Prisma.RewardDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardPayload>
          }
          update: {
            args: Prisma.RewardUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardPayload>
          }
          deleteMany: {
            args: Prisma.RewardDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RewardUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RewardUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardPayload>
          }
          aggregate: {
            args: Prisma.RewardAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReward>
          }
          groupBy: {
            args: Prisma.RewardGroupByArgs<ExtArgs>
            result: $Utils.Optional<RewardGroupByOutputType>[]
          }
          count: {
            args: Prisma.RewardCountArgs<ExtArgs>
            result: $Utils.Optional<RewardCountAggregateOutputType> | number
          }
        }
      }
      POSRewardItem: {
        payload: Prisma.$POSRewardItemPayload<ExtArgs>
        fields: Prisma.POSRewardItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.POSRewardItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$POSRewardItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.POSRewardItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$POSRewardItemPayload>
          }
          findFirst: {
            args: Prisma.POSRewardItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$POSRewardItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.POSRewardItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$POSRewardItemPayload>
          }
          findMany: {
            args: Prisma.POSRewardItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$POSRewardItemPayload>[]
          }
          create: {
            args: Prisma.POSRewardItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$POSRewardItemPayload>
          }
          createMany: {
            args: Prisma.POSRewardItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.POSRewardItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$POSRewardItemPayload>[]
          }
          delete: {
            args: Prisma.POSRewardItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$POSRewardItemPayload>
          }
          update: {
            args: Prisma.POSRewardItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$POSRewardItemPayload>
          }
          deleteMany: {
            args: Prisma.POSRewardItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.POSRewardItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.POSRewardItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$POSRewardItemPayload>
          }
          aggregate: {
            args: Prisma.POSRewardItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePOSRewardItem>
          }
          groupBy: {
            args: Prisma.POSRewardItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<POSRewardItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.POSRewardItemCountArgs<ExtArgs>
            result: $Utils.Optional<POSRewardItemCountAggregateOutputType> | number
          }
        }
      }
      Redemption: {
        payload: Prisma.$RedemptionPayload<ExtArgs>
        fields: Prisma.RedemptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RedemptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RedemptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RedemptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RedemptionPayload>
          }
          findFirst: {
            args: Prisma.RedemptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RedemptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RedemptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RedemptionPayload>
          }
          findMany: {
            args: Prisma.RedemptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RedemptionPayload>[]
          }
          create: {
            args: Prisma.RedemptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RedemptionPayload>
          }
          createMany: {
            args: Prisma.RedemptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RedemptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RedemptionPayload>[]
          }
          delete: {
            args: Prisma.RedemptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RedemptionPayload>
          }
          update: {
            args: Prisma.RedemptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RedemptionPayload>
          }
          deleteMany: {
            args: Prisma.RedemptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RedemptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RedemptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RedemptionPayload>
          }
          aggregate: {
            args: Prisma.RedemptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRedemption>
          }
          groupBy: {
            args: Prisma.RedemptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<RedemptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.RedemptionCountArgs<ExtArgs>
            result: $Utils.Optional<RedemptionCountAggregateOutputType> | number
          }
        }
      }
      CustomerItemCount: {
        payload: Prisma.$CustomerItemCountPayload<ExtArgs>
        fields: Prisma.CustomerItemCountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerItemCountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerItemCountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerItemCountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerItemCountPayload>
          }
          findFirst: {
            args: Prisma.CustomerItemCountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerItemCountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerItemCountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerItemCountPayload>
          }
          findMany: {
            args: Prisma.CustomerItemCountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerItemCountPayload>[]
          }
          create: {
            args: Prisma.CustomerItemCountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerItemCountPayload>
          }
          createMany: {
            args: Prisma.CustomerItemCountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustomerItemCountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerItemCountPayload>[]
          }
          delete: {
            args: Prisma.CustomerItemCountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerItemCountPayload>
          }
          update: {
            args: Prisma.CustomerItemCountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerItemCountPayload>
          }
          deleteMany: {
            args: Prisma.CustomerItemCountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerItemCountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CustomerItemCountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerItemCountPayload>
          }
          aggregate: {
            args: Prisma.CustomerItemCountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomerItemCount>
          }
          groupBy: {
            args: Prisma.CustomerItemCountGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerItemCountGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomerItemCountCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerItemCountCountAggregateOutputType> | number
          }
        }
      }
      LedgerEntry: {
        payload: Prisma.$LedgerEntryPayload<ExtArgs>
        fields: Prisma.LedgerEntryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LedgerEntryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LedgerEntryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LedgerEntryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LedgerEntryPayload>
          }
          findFirst: {
            args: Prisma.LedgerEntryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LedgerEntryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LedgerEntryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LedgerEntryPayload>
          }
          findMany: {
            args: Prisma.LedgerEntryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LedgerEntryPayload>[]
          }
          create: {
            args: Prisma.LedgerEntryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LedgerEntryPayload>
          }
          createMany: {
            args: Prisma.LedgerEntryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LedgerEntryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LedgerEntryPayload>[]
          }
          delete: {
            args: Prisma.LedgerEntryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LedgerEntryPayload>
          }
          update: {
            args: Prisma.LedgerEntryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LedgerEntryPayload>
          }
          deleteMany: {
            args: Prisma.LedgerEntryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LedgerEntryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LedgerEntryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LedgerEntryPayload>
          }
          aggregate: {
            args: Prisma.LedgerEntryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLedgerEntry>
          }
          groupBy: {
            args: Prisma.LedgerEntryGroupByArgs<ExtArgs>
            result: $Utils.Optional<LedgerEntryGroupByOutputType>[]
          }
          count: {
            args: Prisma.LedgerEntryCountArgs<ExtArgs>
            result: $Utils.Optional<LedgerEntryCountAggregateOutputType> | number
          }
        }
      }
      WebhookLog: {
        payload: Prisma.$WebhookLogPayload<ExtArgs>
        fields: Prisma.WebhookLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WebhookLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WebhookLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookLogPayload>
          }
          findFirst: {
            args: Prisma.WebhookLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WebhookLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookLogPayload>
          }
          findMany: {
            args: Prisma.WebhookLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookLogPayload>[]
          }
          create: {
            args: Prisma.WebhookLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookLogPayload>
          }
          createMany: {
            args: Prisma.WebhookLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WebhookLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookLogPayload>[]
          }
          delete: {
            args: Prisma.WebhookLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookLogPayload>
          }
          update: {
            args: Prisma.WebhookLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookLogPayload>
          }
          deleteMany: {
            args: Prisma.WebhookLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WebhookLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WebhookLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookLogPayload>
          }
          aggregate: {
            args: Prisma.WebhookLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWebhookLog>
          }
          groupBy: {
            args: Prisma.WebhookLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<WebhookLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.WebhookLogCountArgs<ExtArgs>
            result: $Utils.Optional<WebhookLogCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type MerchantCountOutputType
   */

  export type MerchantCountOutputType = {
    posIntegrations: number
    locations: number
    rewards: number
    transactions: number
    redemptions: number
    customerBalances: number
    itemCounts: number
    ledgerEntries: number
  }

  export type MerchantCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    posIntegrations?: boolean | MerchantCountOutputTypeCountPosIntegrationsArgs
    locations?: boolean | MerchantCountOutputTypeCountLocationsArgs
    rewards?: boolean | MerchantCountOutputTypeCountRewardsArgs
    transactions?: boolean | MerchantCountOutputTypeCountTransactionsArgs
    redemptions?: boolean | MerchantCountOutputTypeCountRedemptionsArgs
    customerBalances?: boolean | MerchantCountOutputTypeCountCustomerBalancesArgs
    itemCounts?: boolean | MerchantCountOutputTypeCountItemCountsArgs
    ledgerEntries?: boolean | MerchantCountOutputTypeCountLedgerEntriesArgs
  }

  // Custom InputTypes
  /**
   * MerchantCountOutputType without action
   */
  export type MerchantCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MerchantCountOutputType
     */
    select?: MerchantCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MerchantCountOutputType without action
   */
  export type MerchantCountOutputTypeCountPosIntegrationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: POSIntegrationWhereInput
  }

  /**
   * MerchantCountOutputType without action
   */
  export type MerchantCountOutputTypeCountLocationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LocationWhereInput
  }

  /**
   * MerchantCountOutputType without action
   */
  export type MerchantCountOutputTypeCountRewardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RewardWhereInput
  }

  /**
   * MerchantCountOutputType without action
   */
  export type MerchantCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }

  /**
   * MerchantCountOutputType without action
   */
  export type MerchantCountOutputTypeCountRedemptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RedemptionWhereInput
  }

  /**
   * MerchantCountOutputType without action
   */
  export type MerchantCountOutputTypeCountCustomerBalancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerBalanceWhereInput
  }

  /**
   * MerchantCountOutputType without action
   */
  export type MerchantCountOutputTypeCountItemCountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerItemCountWhereInput
  }

  /**
   * MerchantCountOutputType without action
   */
  export type MerchantCountOutputTypeCountLedgerEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LedgerEntryWhereInput
  }


  /**
   * Count Type POSIntegrationCountOutputType
   */

  export type POSIntegrationCountOutputType = {
    locations: number
  }

  export type POSIntegrationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    locations?: boolean | POSIntegrationCountOutputTypeCountLocationsArgs
  }

  // Custom InputTypes
  /**
   * POSIntegrationCountOutputType without action
   */
  export type POSIntegrationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POSIntegrationCountOutputType
     */
    select?: POSIntegrationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * POSIntegrationCountOutputType without action
   */
  export type POSIntegrationCountOutputTypeCountLocationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LocationWhereInput
  }


  /**
   * Count Type LocationCountOutputType
   */

  export type LocationCountOutputType = {
    transactions: number
  }

  export type LocationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactions?: boolean | LocationCountOutputTypeCountTransactionsArgs
  }

  // Custom InputTypes
  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationCountOutputType
     */
    select?: LocationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }


  /**
   * Count Type CustomerCountOutputType
   */

  export type CustomerCountOutputType = {
    linkedCards: number
    transactions: number
    customerBalances: number
    redemptions: number
    ledgerEntries: number
    itemCounts: number
  }

  export type CustomerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    linkedCards?: boolean | CustomerCountOutputTypeCountLinkedCardsArgs
    transactions?: boolean | CustomerCountOutputTypeCountTransactionsArgs
    customerBalances?: boolean | CustomerCountOutputTypeCountCustomerBalancesArgs
    redemptions?: boolean | CustomerCountOutputTypeCountRedemptionsArgs
    ledgerEntries?: boolean | CustomerCountOutputTypeCountLedgerEntriesArgs
    itemCounts?: boolean | CustomerCountOutputTypeCountItemCountsArgs
  }

  // Custom InputTypes
  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerCountOutputType
     */
    select?: CustomerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountLinkedCardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LinkedCardWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountCustomerBalancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerBalanceWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountRedemptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RedemptionWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountLedgerEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LedgerEntryWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountItemCountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerItemCountWhereInput
  }


  /**
   * Count Type TransactionCountOutputType
   */

  export type TransactionCountOutputType = {
    ledgerEntries: number
  }

  export type TransactionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ledgerEntries?: boolean | TransactionCountOutputTypeCountLedgerEntriesArgs
  }

  // Custom InputTypes
  /**
   * TransactionCountOutputType without action
   */
  export type TransactionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionCountOutputType
     */
    select?: TransactionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TransactionCountOutputType without action
   */
  export type TransactionCountOutputTypeCountLedgerEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LedgerEntryWhereInput
  }


  /**
   * Count Type RewardCountOutputType
   */

  export type RewardCountOutputType = {
    posRewardItems: number
    redemptions: number
    itemCounts: number
  }

  export type RewardCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    posRewardItems?: boolean | RewardCountOutputTypeCountPosRewardItemsArgs
    redemptions?: boolean | RewardCountOutputTypeCountRedemptionsArgs
    itemCounts?: boolean | RewardCountOutputTypeCountItemCountsArgs
  }

  // Custom InputTypes
  /**
   * RewardCountOutputType without action
   */
  export type RewardCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardCountOutputType
     */
    select?: RewardCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RewardCountOutputType without action
   */
  export type RewardCountOutputTypeCountPosRewardItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: POSRewardItemWhereInput
  }

  /**
   * RewardCountOutputType without action
   */
  export type RewardCountOutputTypeCountRedemptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RedemptionWhereInput
  }

  /**
   * RewardCountOutputType without action
   */
  export type RewardCountOutputTypeCountItemCountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerItemCountWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Merchant
   */

  export type AggregateMerchant = {
    _count: MerchantCountAggregateOutputType | null
    _min: MerchantMinAggregateOutputType | null
    _max: MerchantMaxAggregateOutputType | null
  }

  export type MerchantMinAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MerchantMaxAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MerchantCountAggregateOutputType = {
    id: number
    email: number
    password: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MerchantMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MerchantMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MerchantCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MerchantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Merchant to aggregate.
     */
    where?: MerchantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Merchants to fetch.
     */
    orderBy?: MerchantOrderByWithRelationInput | MerchantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MerchantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Merchants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Merchants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Merchants
    **/
    _count?: true | MerchantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MerchantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MerchantMaxAggregateInputType
  }

  export type GetMerchantAggregateType<T extends MerchantAggregateArgs> = {
        [P in keyof T & keyof AggregateMerchant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMerchant[P]>
      : GetScalarType<T[P], AggregateMerchant[P]>
  }




  export type MerchantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MerchantWhereInput
    orderBy?: MerchantOrderByWithAggregationInput | MerchantOrderByWithAggregationInput[]
    by: MerchantScalarFieldEnum[] | MerchantScalarFieldEnum
    having?: MerchantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MerchantCountAggregateInputType | true
    _min?: MerchantMinAggregateInputType
    _max?: MerchantMaxAggregateInputType
  }

  export type MerchantGroupByOutputType = {
    id: string
    email: string
    password: string
    name: string
    createdAt: Date
    updatedAt: Date
    _count: MerchantCountAggregateOutputType | null
    _min: MerchantMinAggregateOutputType | null
    _max: MerchantMaxAggregateOutputType | null
  }

  type GetMerchantGroupByPayload<T extends MerchantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MerchantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MerchantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MerchantGroupByOutputType[P]>
            : GetScalarType<T[P], MerchantGroupByOutputType[P]>
        }
      >
    >


  export type MerchantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    posIntegrations?: boolean | Merchant$posIntegrationsArgs<ExtArgs>
    locations?: boolean | Merchant$locationsArgs<ExtArgs>
    rewards?: boolean | Merchant$rewardsArgs<ExtArgs>
    transactions?: boolean | Merchant$transactionsArgs<ExtArgs>
    redemptions?: boolean | Merchant$redemptionsArgs<ExtArgs>
    customerBalances?: boolean | Merchant$customerBalancesArgs<ExtArgs>
    itemCounts?: boolean | Merchant$itemCountsArgs<ExtArgs>
    ledgerEntries?: boolean | Merchant$ledgerEntriesArgs<ExtArgs>
    _count?: boolean | MerchantCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["merchant"]>

  export type MerchantSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["merchant"]>

  export type MerchantSelectScalar = {
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MerchantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    posIntegrations?: boolean | Merchant$posIntegrationsArgs<ExtArgs>
    locations?: boolean | Merchant$locationsArgs<ExtArgs>
    rewards?: boolean | Merchant$rewardsArgs<ExtArgs>
    transactions?: boolean | Merchant$transactionsArgs<ExtArgs>
    redemptions?: boolean | Merchant$redemptionsArgs<ExtArgs>
    customerBalances?: boolean | Merchant$customerBalancesArgs<ExtArgs>
    itemCounts?: boolean | Merchant$itemCountsArgs<ExtArgs>
    ledgerEntries?: boolean | Merchant$ledgerEntriesArgs<ExtArgs>
    _count?: boolean | MerchantCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MerchantIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $MerchantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Merchant"
    objects: {
      posIntegrations: Prisma.$POSIntegrationPayload<ExtArgs>[]
      locations: Prisma.$LocationPayload<ExtArgs>[]
      rewards: Prisma.$RewardPayload<ExtArgs>[]
      transactions: Prisma.$TransactionPayload<ExtArgs>[]
      redemptions: Prisma.$RedemptionPayload<ExtArgs>[]
      customerBalances: Prisma.$CustomerBalancePayload<ExtArgs>[]
      itemCounts: Prisma.$CustomerItemCountPayload<ExtArgs>[]
      ledgerEntries: Prisma.$LedgerEntryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      password: string
      name: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["merchant"]>
    composites: {}
  }

  type MerchantGetPayload<S extends boolean | null | undefined | MerchantDefaultArgs> = $Result.GetResult<Prisma.$MerchantPayload, S>

  type MerchantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MerchantFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MerchantCountAggregateInputType | true
    }

  export interface MerchantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Merchant'], meta: { name: 'Merchant' } }
    /**
     * Find zero or one Merchant that matches the filter.
     * @param {MerchantFindUniqueArgs} args - Arguments to find a Merchant
     * @example
     * // Get one Merchant
     * const merchant = await prisma.merchant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MerchantFindUniqueArgs>(args: SelectSubset<T, MerchantFindUniqueArgs<ExtArgs>>): Prisma__MerchantClient<$Result.GetResult<Prisma.$MerchantPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Merchant that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MerchantFindUniqueOrThrowArgs} args - Arguments to find a Merchant
     * @example
     * // Get one Merchant
     * const merchant = await prisma.merchant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MerchantFindUniqueOrThrowArgs>(args: SelectSubset<T, MerchantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MerchantClient<$Result.GetResult<Prisma.$MerchantPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Merchant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MerchantFindFirstArgs} args - Arguments to find a Merchant
     * @example
     * // Get one Merchant
     * const merchant = await prisma.merchant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MerchantFindFirstArgs>(args?: SelectSubset<T, MerchantFindFirstArgs<ExtArgs>>): Prisma__MerchantClient<$Result.GetResult<Prisma.$MerchantPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Merchant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MerchantFindFirstOrThrowArgs} args - Arguments to find a Merchant
     * @example
     * // Get one Merchant
     * const merchant = await prisma.merchant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MerchantFindFirstOrThrowArgs>(args?: SelectSubset<T, MerchantFindFirstOrThrowArgs<ExtArgs>>): Prisma__MerchantClient<$Result.GetResult<Prisma.$MerchantPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Merchants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MerchantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Merchants
     * const merchants = await prisma.merchant.findMany()
     * 
     * // Get first 10 Merchants
     * const merchants = await prisma.merchant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const merchantWithIdOnly = await prisma.merchant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MerchantFindManyArgs>(args?: SelectSubset<T, MerchantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MerchantPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Merchant.
     * @param {MerchantCreateArgs} args - Arguments to create a Merchant.
     * @example
     * // Create one Merchant
     * const Merchant = await prisma.merchant.create({
     *   data: {
     *     // ... data to create a Merchant
     *   }
     * })
     * 
     */
    create<T extends MerchantCreateArgs>(args: SelectSubset<T, MerchantCreateArgs<ExtArgs>>): Prisma__MerchantClient<$Result.GetResult<Prisma.$MerchantPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Merchants.
     * @param {MerchantCreateManyArgs} args - Arguments to create many Merchants.
     * @example
     * // Create many Merchants
     * const merchant = await prisma.merchant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MerchantCreateManyArgs>(args?: SelectSubset<T, MerchantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Merchants and returns the data saved in the database.
     * @param {MerchantCreateManyAndReturnArgs} args - Arguments to create many Merchants.
     * @example
     * // Create many Merchants
     * const merchant = await prisma.merchant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Merchants and only return the `id`
     * const merchantWithIdOnly = await prisma.merchant.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MerchantCreateManyAndReturnArgs>(args?: SelectSubset<T, MerchantCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MerchantPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Merchant.
     * @param {MerchantDeleteArgs} args - Arguments to delete one Merchant.
     * @example
     * // Delete one Merchant
     * const Merchant = await prisma.merchant.delete({
     *   where: {
     *     // ... filter to delete one Merchant
     *   }
     * })
     * 
     */
    delete<T extends MerchantDeleteArgs>(args: SelectSubset<T, MerchantDeleteArgs<ExtArgs>>): Prisma__MerchantClient<$Result.GetResult<Prisma.$MerchantPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Merchant.
     * @param {MerchantUpdateArgs} args - Arguments to update one Merchant.
     * @example
     * // Update one Merchant
     * const merchant = await prisma.merchant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MerchantUpdateArgs>(args: SelectSubset<T, MerchantUpdateArgs<ExtArgs>>): Prisma__MerchantClient<$Result.GetResult<Prisma.$MerchantPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Merchants.
     * @param {MerchantDeleteManyArgs} args - Arguments to filter Merchants to delete.
     * @example
     * // Delete a few Merchants
     * const { count } = await prisma.merchant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MerchantDeleteManyArgs>(args?: SelectSubset<T, MerchantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Merchants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MerchantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Merchants
     * const merchant = await prisma.merchant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MerchantUpdateManyArgs>(args: SelectSubset<T, MerchantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Merchant.
     * @param {MerchantUpsertArgs} args - Arguments to update or create a Merchant.
     * @example
     * // Update or create a Merchant
     * const merchant = await prisma.merchant.upsert({
     *   create: {
     *     // ... data to create a Merchant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Merchant we want to update
     *   }
     * })
     */
    upsert<T extends MerchantUpsertArgs>(args: SelectSubset<T, MerchantUpsertArgs<ExtArgs>>): Prisma__MerchantClient<$Result.GetResult<Prisma.$MerchantPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Merchants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MerchantCountArgs} args - Arguments to filter Merchants to count.
     * @example
     * // Count the number of Merchants
     * const count = await prisma.merchant.count({
     *   where: {
     *     // ... the filter for the Merchants we want to count
     *   }
     * })
    **/
    count<T extends MerchantCountArgs>(
      args?: Subset<T, MerchantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MerchantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Merchant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MerchantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MerchantAggregateArgs>(args: Subset<T, MerchantAggregateArgs>): Prisma.PrismaPromise<GetMerchantAggregateType<T>>

    /**
     * Group by Merchant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MerchantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MerchantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MerchantGroupByArgs['orderBy'] }
        : { orderBy?: MerchantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MerchantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMerchantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Merchant model
   */
  readonly fields: MerchantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Merchant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MerchantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    posIntegrations<T extends Merchant$posIntegrationsArgs<ExtArgs> = {}>(args?: Subset<T, Merchant$posIntegrationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$POSIntegrationPayload<ExtArgs>, T, "findMany"> | Null>
    locations<T extends Merchant$locationsArgs<ExtArgs> = {}>(args?: Subset<T, Merchant$locationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findMany"> | Null>
    rewards<T extends Merchant$rewardsArgs<ExtArgs> = {}>(args?: Subset<T, Merchant$rewardsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RewardPayload<ExtArgs>, T, "findMany"> | Null>
    transactions<T extends Merchant$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, Merchant$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany"> | Null>
    redemptions<T extends Merchant$redemptionsArgs<ExtArgs> = {}>(args?: Subset<T, Merchant$redemptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RedemptionPayload<ExtArgs>, T, "findMany"> | Null>
    customerBalances<T extends Merchant$customerBalancesArgs<ExtArgs> = {}>(args?: Subset<T, Merchant$customerBalancesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerBalancePayload<ExtArgs>, T, "findMany"> | Null>
    itemCounts<T extends Merchant$itemCountsArgs<ExtArgs> = {}>(args?: Subset<T, Merchant$itemCountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerItemCountPayload<ExtArgs>, T, "findMany"> | Null>
    ledgerEntries<T extends Merchant$ledgerEntriesArgs<ExtArgs> = {}>(args?: Subset<T, Merchant$ledgerEntriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LedgerEntryPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Merchant model
   */ 
  interface MerchantFieldRefs {
    readonly id: FieldRef<"Merchant", 'String'>
    readonly email: FieldRef<"Merchant", 'String'>
    readonly password: FieldRef<"Merchant", 'String'>
    readonly name: FieldRef<"Merchant", 'String'>
    readonly createdAt: FieldRef<"Merchant", 'DateTime'>
    readonly updatedAt: FieldRef<"Merchant", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Merchant findUnique
   */
  export type MerchantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Merchant
     */
    select?: MerchantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerchantInclude<ExtArgs> | null
    /**
     * Filter, which Merchant to fetch.
     */
    where: MerchantWhereUniqueInput
  }

  /**
   * Merchant findUniqueOrThrow
   */
  export type MerchantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Merchant
     */
    select?: MerchantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerchantInclude<ExtArgs> | null
    /**
     * Filter, which Merchant to fetch.
     */
    where: MerchantWhereUniqueInput
  }

  /**
   * Merchant findFirst
   */
  export type MerchantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Merchant
     */
    select?: MerchantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerchantInclude<ExtArgs> | null
    /**
     * Filter, which Merchant to fetch.
     */
    where?: MerchantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Merchants to fetch.
     */
    orderBy?: MerchantOrderByWithRelationInput | MerchantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Merchants.
     */
    cursor?: MerchantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Merchants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Merchants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Merchants.
     */
    distinct?: MerchantScalarFieldEnum | MerchantScalarFieldEnum[]
  }

  /**
   * Merchant findFirstOrThrow
   */
  export type MerchantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Merchant
     */
    select?: MerchantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerchantInclude<ExtArgs> | null
    /**
     * Filter, which Merchant to fetch.
     */
    where?: MerchantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Merchants to fetch.
     */
    orderBy?: MerchantOrderByWithRelationInput | MerchantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Merchants.
     */
    cursor?: MerchantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Merchants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Merchants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Merchants.
     */
    distinct?: MerchantScalarFieldEnum | MerchantScalarFieldEnum[]
  }

  /**
   * Merchant findMany
   */
  export type MerchantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Merchant
     */
    select?: MerchantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerchantInclude<ExtArgs> | null
    /**
     * Filter, which Merchants to fetch.
     */
    where?: MerchantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Merchants to fetch.
     */
    orderBy?: MerchantOrderByWithRelationInput | MerchantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Merchants.
     */
    cursor?: MerchantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Merchants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Merchants.
     */
    skip?: number
    distinct?: MerchantScalarFieldEnum | MerchantScalarFieldEnum[]
  }

  /**
   * Merchant create
   */
  export type MerchantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Merchant
     */
    select?: MerchantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerchantInclude<ExtArgs> | null
    /**
     * The data needed to create a Merchant.
     */
    data: XOR<MerchantCreateInput, MerchantUncheckedCreateInput>
  }

  /**
   * Merchant createMany
   */
  export type MerchantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Merchants.
     */
    data: MerchantCreateManyInput | MerchantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Merchant createManyAndReturn
   */
  export type MerchantCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Merchant
     */
    select?: MerchantSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Merchants.
     */
    data: MerchantCreateManyInput | MerchantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Merchant update
   */
  export type MerchantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Merchant
     */
    select?: MerchantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerchantInclude<ExtArgs> | null
    /**
     * The data needed to update a Merchant.
     */
    data: XOR<MerchantUpdateInput, MerchantUncheckedUpdateInput>
    /**
     * Choose, which Merchant to update.
     */
    where: MerchantWhereUniqueInput
  }

  /**
   * Merchant updateMany
   */
  export type MerchantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Merchants.
     */
    data: XOR<MerchantUpdateManyMutationInput, MerchantUncheckedUpdateManyInput>
    /**
     * Filter which Merchants to update
     */
    where?: MerchantWhereInput
  }

  /**
   * Merchant upsert
   */
  export type MerchantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Merchant
     */
    select?: MerchantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerchantInclude<ExtArgs> | null
    /**
     * The filter to search for the Merchant to update in case it exists.
     */
    where: MerchantWhereUniqueInput
    /**
     * In case the Merchant found by the `where` argument doesn't exist, create a new Merchant with this data.
     */
    create: XOR<MerchantCreateInput, MerchantUncheckedCreateInput>
    /**
     * In case the Merchant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MerchantUpdateInput, MerchantUncheckedUpdateInput>
  }

  /**
   * Merchant delete
   */
  export type MerchantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Merchant
     */
    select?: MerchantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerchantInclude<ExtArgs> | null
    /**
     * Filter which Merchant to delete.
     */
    where: MerchantWhereUniqueInput
  }

  /**
   * Merchant deleteMany
   */
  export type MerchantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Merchants to delete
     */
    where?: MerchantWhereInput
  }

  /**
   * Merchant.posIntegrations
   */
  export type Merchant$posIntegrationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POSIntegration
     */
    select?: POSIntegrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSIntegrationInclude<ExtArgs> | null
    where?: POSIntegrationWhereInput
    orderBy?: POSIntegrationOrderByWithRelationInput | POSIntegrationOrderByWithRelationInput[]
    cursor?: POSIntegrationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: POSIntegrationScalarFieldEnum | POSIntegrationScalarFieldEnum[]
  }

  /**
   * Merchant.locations
   */
  export type Merchant$locationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    where?: LocationWhereInput
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    cursor?: LocationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * Merchant.rewards
   */
  export type Merchant$rewardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reward
     */
    select?: RewardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardInclude<ExtArgs> | null
    where?: RewardWhereInput
    orderBy?: RewardOrderByWithRelationInput | RewardOrderByWithRelationInput[]
    cursor?: RewardWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RewardScalarFieldEnum | RewardScalarFieldEnum[]
  }

  /**
   * Merchant.transactions
   */
  export type Merchant$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Merchant.redemptions
   */
  export type Merchant$redemptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redemption
     */
    select?: RedemptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RedemptionInclude<ExtArgs> | null
    where?: RedemptionWhereInput
    orderBy?: RedemptionOrderByWithRelationInput | RedemptionOrderByWithRelationInput[]
    cursor?: RedemptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RedemptionScalarFieldEnum | RedemptionScalarFieldEnum[]
  }

  /**
   * Merchant.customerBalances
   */
  export type Merchant$customerBalancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerBalance
     */
    select?: CustomerBalanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerBalanceInclude<ExtArgs> | null
    where?: CustomerBalanceWhereInput
    orderBy?: CustomerBalanceOrderByWithRelationInput | CustomerBalanceOrderByWithRelationInput[]
    cursor?: CustomerBalanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerBalanceScalarFieldEnum | CustomerBalanceScalarFieldEnum[]
  }

  /**
   * Merchant.itemCounts
   */
  export type Merchant$itemCountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerItemCount
     */
    select?: CustomerItemCountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerItemCountInclude<ExtArgs> | null
    where?: CustomerItemCountWhereInput
    orderBy?: CustomerItemCountOrderByWithRelationInput | CustomerItemCountOrderByWithRelationInput[]
    cursor?: CustomerItemCountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerItemCountScalarFieldEnum | CustomerItemCountScalarFieldEnum[]
  }

  /**
   * Merchant.ledgerEntries
   */
  export type Merchant$ledgerEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerEntry
     */
    select?: LedgerEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerEntryInclude<ExtArgs> | null
    where?: LedgerEntryWhereInput
    orderBy?: LedgerEntryOrderByWithRelationInput | LedgerEntryOrderByWithRelationInput[]
    cursor?: LedgerEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LedgerEntryScalarFieldEnum | LedgerEntryScalarFieldEnum[]
  }

  /**
   * Merchant without action
   */
  export type MerchantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Merchant
     */
    select?: MerchantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerchantInclude<ExtArgs> | null
  }


  /**
   * Model POSIntegration
   */

  export type AggregatePOSIntegration = {
    _count: POSIntegrationCountAggregateOutputType | null
    _min: POSIntegrationMinAggregateOutputType | null
    _max: POSIntegrationMaxAggregateOutputType | null
  }

  export type POSIntegrationMinAggregateOutputType = {
    id: string | null
    merchantId: string | null
    provider: $Enums.POSProvider | null
    accessToken: string | null
    refreshToken: string | null
    providerMerchantId: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type POSIntegrationMaxAggregateOutputType = {
    id: string | null
    merchantId: string | null
    provider: $Enums.POSProvider | null
    accessToken: string | null
    refreshToken: string | null
    providerMerchantId: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type POSIntegrationCountAggregateOutputType = {
    id: number
    merchantId: number
    provider: number
    accessToken: number
    refreshToken: number
    providerMerchantId: number
    expiresAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type POSIntegrationMinAggregateInputType = {
    id?: true
    merchantId?: true
    provider?: true
    accessToken?: true
    refreshToken?: true
    providerMerchantId?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type POSIntegrationMaxAggregateInputType = {
    id?: true
    merchantId?: true
    provider?: true
    accessToken?: true
    refreshToken?: true
    providerMerchantId?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type POSIntegrationCountAggregateInputType = {
    id?: true
    merchantId?: true
    provider?: true
    accessToken?: true
    refreshToken?: true
    providerMerchantId?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type POSIntegrationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which POSIntegration to aggregate.
     */
    where?: POSIntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of POSIntegrations to fetch.
     */
    orderBy?: POSIntegrationOrderByWithRelationInput | POSIntegrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: POSIntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` POSIntegrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` POSIntegrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned POSIntegrations
    **/
    _count?: true | POSIntegrationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: POSIntegrationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: POSIntegrationMaxAggregateInputType
  }

  export type GetPOSIntegrationAggregateType<T extends POSIntegrationAggregateArgs> = {
        [P in keyof T & keyof AggregatePOSIntegration]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePOSIntegration[P]>
      : GetScalarType<T[P], AggregatePOSIntegration[P]>
  }




  export type POSIntegrationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: POSIntegrationWhereInput
    orderBy?: POSIntegrationOrderByWithAggregationInput | POSIntegrationOrderByWithAggregationInput[]
    by: POSIntegrationScalarFieldEnum[] | POSIntegrationScalarFieldEnum
    having?: POSIntegrationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: POSIntegrationCountAggregateInputType | true
    _min?: POSIntegrationMinAggregateInputType
    _max?: POSIntegrationMaxAggregateInputType
  }

  export type POSIntegrationGroupByOutputType = {
    id: string
    merchantId: string
    provider: $Enums.POSProvider
    accessToken: string
    refreshToken: string | null
    providerMerchantId: string
    expiresAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: POSIntegrationCountAggregateOutputType | null
    _min: POSIntegrationMinAggregateOutputType | null
    _max: POSIntegrationMaxAggregateOutputType | null
  }

  type GetPOSIntegrationGroupByPayload<T extends POSIntegrationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<POSIntegrationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof POSIntegrationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], POSIntegrationGroupByOutputType[P]>
            : GetScalarType<T[P], POSIntegrationGroupByOutputType[P]>
        }
      >
    >


  export type POSIntegrationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    merchantId?: boolean
    provider?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    providerMerchantId?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    merchant?: boolean | MerchantDefaultArgs<ExtArgs>
    locations?: boolean | POSIntegration$locationsArgs<ExtArgs>
    _count?: boolean | POSIntegrationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pOSIntegration"]>

  export type POSIntegrationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    merchantId?: boolean
    provider?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    providerMerchantId?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    merchant?: boolean | MerchantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pOSIntegration"]>

  export type POSIntegrationSelectScalar = {
    id?: boolean
    merchantId?: boolean
    provider?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    providerMerchantId?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type POSIntegrationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    merchant?: boolean | MerchantDefaultArgs<ExtArgs>
    locations?: boolean | POSIntegration$locationsArgs<ExtArgs>
    _count?: boolean | POSIntegrationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type POSIntegrationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    merchant?: boolean | MerchantDefaultArgs<ExtArgs>
  }

  export type $POSIntegrationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "POSIntegration"
    objects: {
      merchant: Prisma.$MerchantPayload<ExtArgs>
      locations: Prisma.$LocationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      merchantId: string
      provider: $Enums.POSProvider
      accessToken: string
      refreshToken: string | null
      providerMerchantId: string
      expiresAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["pOSIntegration"]>
    composites: {}
  }

  type POSIntegrationGetPayload<S extends boolean | null | undefined | POSIntegrationDefaultArgs> = $Result.GetResult<Prisma.$POSIntegrationPayload, S>

  type POSIntegrationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<POSIntegrationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: POSIntegrationCountAggregateInputType | true
    }

  export interface POSIntegrationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['POSIntegration'], meta: { name: 'POSIntegration' } }
    /**
     * Find zero or one POSIntegration that matches the filter.
     * @param {POSIntegrationFindUniqueArgs} args - Arguments to find a POSIntegration
     * @example
     * // Get one POSIntegration
     * const pOSIntegration = await prisma.pOSIntegration.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends POSIntegrationFindUniqueArgs>(args: SelectSubset<T, POSIntegrationFindUniqueArgs<ExtArgs>>): Prisma__POSIntegrationClient<$Result.GetResult<Prisma.$POSIntegrationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one POSIntegration that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {POSIntegrationFindUniqueOrThrowArgs} args - Arguments to find a POSIntegration
     * @example
     * // Get one POSIntegration
     * const pOSIntegration = await prisma.pOSIntegration.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends POSIntegrationFindUniqueOrThrowArgs>(args: SelectSubset<T, POSIntegrationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__POSIntegrationClient<$Result.GetResult<Prisma.$POSIntegrationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first POSIntegration that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {POSIntegrationFindFirstArgs} args - Arguments to find a POSIntegration
     * @example
     * // Get one POSIntegration
     * const pOSIntegration = await prisma.pOSIntegration.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends POSIntegrationFindFirstArgs>(args?: SelectSubset<T, POSIntegrationFindFirstArgs<ExtArgs>>): Prisma__POSIntegrationClient<$Result.GetResult<Prisma.$POSIntegrationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first POSIntegration that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {POSIntegrationFindFirstOrThrowArgs} args - Arguments to find a POSIntegration
     * @example
     * // Get one POSIntegration
     * const pOSIntegration = await prisma.pOSIntegration.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends POSIntegrationFindFirstOrThrowArgs>(args?: SelectSubset<T, POSIntegrationFindFirstOrThrowArgs<ExtArgs>>): Prisma__POSIntegrationClient<$Result.GetResult<Prisma.$POSIntegrationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more POSIntegrations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {POSIntegrationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all POSIntegrations
     * const pOSIntegrations = await prisma.pOSIntegration.findMany()
     * 
     * // Get first 10 POSIntegrations
     * const pOSIntegrations = await prisma.pOSIntegration.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pOSIntegrationWithIdOnly = await prisma.pOSIntegration.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends POSIntegrationFindManyArgs>(args?: SelectSubset<T, POSIntegrationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$POSIntegrationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a POSIntegration.
     * @param {POSIntegrationCreateArgs} args - Arguments to create a POSIntegration.
     * @example
     * // Create one POSIntegration
     * const POSIntegration = await prisma.pOSIntegration.create({
     *   data: {
     *     // ... data to create a POSIntegration
     *   }
     * })
     * 
     */
    create<T extends POSIntegrationCreateArgs>(args: SelectSubset<T, POSIntegrationCreateArgs<ExtArgs>>): Prisma__POSIntegrationClient<$Result.GetResult<Prisma.$POSIntegrationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many POSIntegrations.
     * @param {POSIntegrationCreateManyArgs} args - Arguments to create many POSIntegrations.
     * @example
     * // Create many POSIntegrations
     * const pOSIntegration = await prisma.pOSIntegration.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends POSIntegrationCreateManyArgs>(args?: SelectSubset<T, POSIntegrationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many POSIntegrations and returns the data saved in the database.
     * @param {POSIntegrationCreateManyAndReturnArgs} args - Arguments to create many POSIntegrations.
     * @example
     * // Create many POSIntegrations
     * const pOSIntegration = await prisma.pOSIntegration.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many POSIntegrations and only return the `id`
     * const pOSIntegrationWithIdOnly = await prisma.pOSIntegration.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends POSIntegrationCreateManyAndReturnArgs>(args?: SelectSubset<T, POSIntegrationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$POSIntegrationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a POSIntegration.
     * @param {POSIntegrationDeleteArgs} args - Arguments to delete one POSIntegration.
     * @example
     * // Delete one POSIntegration
     * const POSIntegration = await prisma.pOSIntegration.delete({
     *   where: {
     *     // ... filter to delete one POSIntegration
     *   }
     * })
     * 
     */
    delete<T extends POSIntegrationDeleteArgs>(args: SelectSubset<T, POSIntegrationDeleteArgs<ExtArgs>>): Prisma__POSIntegrationClient<$Result.GetResult<Prisma.$POSIntegrationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one POSIntegration.
     * @param {POSIntegrationUpdateArgs} args - Arguments to update one POSIntegration.
     * @example
     * // Update one POSIntegration
     * const pOSIntegration = await prisma.pOSIntegration.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends POSIntegrationUpdateArgs>(args: SelectSubset<T, POSIntegrationUpdateArgs<ExtArgs>>): Prisma__POSIntegrationClient<$Result.GetResult<Prisma.$POSIntegrationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more POSIntegrations.
     * @param {POSIntegrationDeleteManyArgs} args - Arguments to filter POSIntegrations to delete.
     * @example
     * // Delete a few POSIntegrations
     * const { count } = await prisma.pOSIntegration.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends POSIntegrationDeleteManyArgs>(args?: SelectSubset<T, POSIntegrationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more POSIntegrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {POSIntegrationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many POSIntegrations
     * const pOSIntegration = await prisma.pOSIntegration.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends POSIntegrationUpdateManyArgs>(args: SelectSubset<T, POSIntegrationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one POSIntegration.
     * @param {POSIntegrationUpsertArgs} args - Arguments to update or create a POSIntegration.
     * @example
     * // Update or create a POSIntegration
     * const pOSIntegration = await prisma.pOSIntegration.upsert({
     *   create: {
     *     // ... data to create a POSIntegration
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the POSIntegration we want to update
     *   }
     * })
     */
    upsert<T extends POSIntegrationUpsertArgs>(args: SelectSubset<T, POSIntegrationUpsertArgs<ExtArgs>>): Prisma__POSIntegrationClient<$Result.GetResult<Prisma.$POSIntegrationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of POSIntegrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {POSIntegrationCountArgs} args - Arguments to filter POSIntegrations to count.
     * @example
     * // Count the number of POSIntegrations
     * const count = await prisma.pOSIntegration.count({
     *   where: {
     *     // ... the filter for the POSIntegrations we want to count
     *   }
     * })
    **/
    count<T extends POSIntegrationCountArgs>(
      args?: Subset<T, POSIntegrationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], POSIntegrationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a POSIntegration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {POSIntegrationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends POSIntegrationAggregateArgs>(args: Subset<T, POSIntegrationAggregateArgs>): Prisma.PrismaPromise<GetPOSIntegrationAggregateType<T>>

    /**
     * Group by POSIntegration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {POSIntegrationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends POSIntegrationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: POSIntegrationGroupByArgs['orderBy'] }
        : { orderBy?: POSIntegrationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, POSIntegrationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPOSIntegrationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the POSIntegration model
   */
  readonly fields: POSIntegrationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for POSIntegration.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__POSIntegrationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    merchant<T extends MerchantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MerchantDefaultArgs<ExtArgs>>): Prisma__MerchantClient<$Result.GetResult<Prisma.$MerchantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    locations<T extends POSIntegration$locationsArgs<ExtArgs> = {}>(args?: Subset<T, POSIntegration$locationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the POSIntegration model
   */ 
  interface POSIntegrationFieldRefs {
    readonly id: FieldRef<"POSIntegration", 'String'>
    readonly merchantId: FieldRef<"POSIntegration", 'String'>
    readonly provider: FieldRef<"POSIntegration", 'POSProvider'>
    readonly accessToken: FieldRef<"POSIntegration", 'String'>
    readonly refreshToken: FieldRef<"POSIntegration", 'String'>
    readonly providerMerchantId: FieldRef<"POSIntegration", 'String'>
    readonly expiresAt: FieldRef<"POSIntegration", 'DateTime'>
    readonly createdAt: FieldRef<"POSIntegration", 'DateTime'>
    readonly updatedAt: FieldRef<"POSIntegration", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * POSIntegration findUnique
   */
  export type POSIntegrationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POSIntegration
     */
    select?: POSIntegrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSIntegrationInclude<ExtArgs> | null
    /**
     * Filter, which POSIntegration to fetch.
     */
    where: POSIntegrationWhereUniqueInput
  }

  /**
   * POSIntegration findUniqueOrThrow
   */
  export type POSIntegrationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POSIntegration
     */
    select?: POSIntegrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSIntegrationInclude<ExtArgs> | null
    /**
     * Filter, which POSIntegration to fetch.
     */
    where: POSIntegrationWhereUniqueInput
  }

  /**
   * POSIntegration findFirst
   */
  export type POSIntegrationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POSIntegration
     */
    select?: POSIntegrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSIntegrationInclude<ExtArgs> | null
    /**
     * Filter, which POSIntegration to fetch.
     */
    where?: POSIntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of POSIntegrations to fetch.
     */
    orderBy?: POSIntegrationOrderByWithRelationInput | POSIntegrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for POSIntegrations.
     */
    cursor?: POSIntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` POSIntegrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` POSIntegrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of POSIntegrations.
     */
    distinct?: POSIntegrationScalarFieldEnum | POSIntegrationScalarFieldEnum[]
  }

  /**
   * POSIntegration findFirstOrThrow
   */
  export type POSIntegrationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POSIntegration
     */
    select?: POSIntegrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSIntegrationInclude<ExtArgs> | null
    /**
     * Filter, which POSIntegration to fetch.
     */
    where?: POSIntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of POSIntegrations to fetch.
     */
    orderBy?: POSIntegrationOrderByWithRelationInput | POSIntegrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for POSIntegrations.
     */
    cursor?: POSIntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` POSIntegrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` POSIntegrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of POSIntegrations.
     */
    distinct?: POSIntegrationScalarFieldEnum | POSIntegrationScalarFieldEnum[]
  }

  /**
   * POSIntegration findMany
   */
  export type POSIntegrationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POSIntegration
     */
    select?: POSIntegrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSIntegrationInclude<ExtArgs> | null
    /**
     * Filter, which POSIntegrations to fetch.
     */
    where?: POSIntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of POSIntegrations to fetch.
     */
    orderBy?: POSIntegrationOrderByWithRelationInput | POSIntegrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing POSIntegrations.
     */
    cursor?: POSIntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` POSIntegrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` POSIntegrations.
     */
    skip?: number
    distinct?: POSIntegrationScalarFieldEnum | POSIntegrationScalarFieldEnum[]
  }

  /**
   * POSIntegration create
   */
  export type POSIntegrationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POSIntegration
     */
    select?: POSIntegrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSIntegrationInclude<ExtArgs> | null
    /**
     * The data needed to create a POSIntegration.
     */
    data: XOR<POSIntegrationCreateInput, POSIntegrationUncheckedCreateInput>
  }

  /**
   * POSIntegration createMany
   */
  export type POSIntegrationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many POSIntegrations.
     */
    data: POSIntegrationCreateManyInput | POSIntegrationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * POSIntegration createManyAndReturn
   */
  export type POSIntegrationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POSIntegration
     */
    select?: POSIntegrationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many POSIntegrations.
     */
    data: POSIntegrationCreateManyInput | POSIntegrationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSIntegrationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * POSIntegration update
   */
  export type POSIntegrationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POSIntegration
     */
    select?: POSIntegrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSIntegrationInclude<ExtArgs> | null
    /**
     * The data needed to update a POSIntegration.
     */
    data: XOR<POSIntegrationUpdateInput, POSIntegrationUncheckedUpdateInput>
    /**
     * Choose, which POSIntegration to update.
     */
    where: POSIntegrationWhereUniqueInput
  }

  /**
   * POSIntegration updateMany
   */
  export type POSIntegrationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update POSIntegrations.
     */
    data: XOR<POSIntegrationUpdateManyMutationInput, POSIntegrationUncheckedUpdateManyInput>
    /**
     * Filter which POSIntegrations to update
     */
    where?: POSIntegrationWhereInput
  }

  /**
   * POSIntegration upsert
   */
  export type POSIntegrationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POSIntegration
     */
    select?: POSIntegrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSIntegrationInclude<ExtArgs> | null
    /**
     * The filter to search for the POSIntegration to update in case it exists.
     */
    where: POSIntegrationWhereUniqueInput
    /**
     * In case the POSIntegration found by the `where` argument doesn't exist, create a new POSIntegration with this data.
     */
    create: XOR<POSIntegrationCreateInput, POSIntegrationUncheckedCreateInput>
    /**
     * In case the POSIntegration was found with the provided `where` argument, update it with this data.
     */
    update: XOR<POSIntegrationUpdateInput, POSIntegrationUncheckedUpdateInput>
  }

  /**
   * POSIntegration delete
   */
  export type POSIntegrationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POSIntegration
     */
    select?: POSIntegrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSIntegrationInclude<ExtArgs> | null
    /**
     * Filter which POSIntegration to delete.
     */
    where: POSIntegrationWhereUniqueInput
  }

  /**
   * POSIntegration deleteMany
   */
  export type POSIntegrationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which POSIntegrations to delete
     */
    where?: POSIntegrationWhereInput
  }

  /**
   * POSIntegration.locations
   */
  export type POSIntegration$locationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    where?: LocationWhereInput
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    cursor?: LocationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * POSIntegration without action
   */
  export type POSIntegrationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POSIntegration
     */
    select?: POSIntegrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSIntegrationInclude<ExtArgs> | null
  }


  /**
   * Model Location
   */

  export type AggregateLocation = {
    _count: LocationCountAggregateOutputType | null
    _min: LocationMinAggregateOutputType | null
    _max: LocationMaxAggregateOutputType | null
  }

  export type LocationMinAggregateOutputType = {
    id: string | null
    merchantId: string | null
    posIntegrationId: string | null
    posLocationId: string | null
    name: string | null
    address: string | null
    city: string | null
    state: string | null
    zipCode: string | null
    country: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LocationMaxAggregateOutputType = {
    id: string | null
    merchantId: string | null
    posIntegrationId: string | null
    posLocationId: string | null
    name: string | null
    address: string | null
    city: string | null
    state: string | null
    zipCode: string | null
    country: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LocationCountAggregateOutputType = {
    id: number
    merchantId: number
    posIntegrationId: number
    posLocationId: number
    name: number
    address: number
    city: number
    state: number
    zipCode: number
    country: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LocationMinAggregateInputType = {
    id?: true
    merchantId?: true
    posIntegrationId?: true
    posLocationId?: true
    name?: true
    address?: true
    city?: true
    state?: true
    zipCode?: true
    country?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LocationMaxAggregateInputType = {
    id?: true
    merchantId?: true
    posIntegrationId?: true
    posLocationId?: true
    name?: true
    address?: true
    city?: true
    state?: true
    zipCode?: true
    country?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LocationCountAggregateInputType = {
    id?: true
    merchantId?: true
    posIntegrationId?: true
    posLocationId?: true
    name?: true
    address?: true
    city?: true
    state?: true
    zipCode?: true
    country?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LocationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Location to aggregate.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Locations
    **/
    _count?: true | LocationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LocationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LocationMaxAggregateInputType
  }

  export type GetLocationAggregateType<T extends LocationAggregateArgs> = {
        [P in keyof T & keyof AggregateLocation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLocation[P]>
      : GetScalarType<T[P], AggregateLocation[P]>
  }




  export type LocationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LocationWhereInput
    orderBy?: LocationOrderByWithAggregationInput | LocationOrderByWithAggregationInput[]
    by: LocationScalarFieldEnum[] | LocationScalarFieldEnum
    having?: LocationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LocationCountAggregateInputType | true
    _min?: LocationMinAggregateInputType
    _max?: LocationMaxAggregateInputType
  }

  export type LocationGroupByOutputType = {
    id: string
    merchantId: string
    posIntegrationId: string
    posLocationId: string
    name: string
    address: string | null
    city: string | null
    state: string | null
    zipCode: string | null
    country: string | null
    createdAt: Date
    updatedAt: Date
    _count: LocationCountAggregateOutputType | null
    _min: LocationMinAggregateOutputType | null
    _max: LocationMaxAggregateOutputType | null
  }

  type GetLocationGroupByPayload<T extends LocationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LocationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LocationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LocationGroupByOutputType[P]>
            : GetScalarType<T[P], LocationGroupByOutputType[P]>
        }
      >
    >


  export type LocationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    merchantId?: boolean
    posIntegrationId?: boolean
    posLocationId?: boolean
    name?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    zipCode?: boolean
    country?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    merchant?: boolean | MerchantDefaultArgs<ExtArgs>
    posIntegration?: boolean | POSIntegrationDefaultArgs<ExtArgs>
    transactions?: boolean | Location$transactionsArgs<ExtArgs>
    _count?: boolean | LocationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["location"]>

  export type LocationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    merchantId?: boolean
    posIntegrationId?: boolean
    posLocationId?: boolean
    name?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    zipCode?: boolean
    country?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    merchant?: boolean | MerchantDefaultArgs<ExtArgs>
    posIntegration?: boolean | POSIntegrationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["location"]>

  export type LocationSelectScalar = {
    id?: boolean
    merchantId?: boolean
    posIntegrationId?: boolean
    posLocationId?: boolean
    name?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    zipCode?: boolean
    country?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LocationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    merchant?: boolean | MerchantDefaultArgs<ExtArgs>
    posIntegration?: boolean | POSIntegrationDefaultArgs<ExtArgs>
    transactions?: boolean | Location$transactionsArgs<ExtArgs>
    _count?: boolean | LocationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LocationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    merchant?: boolean | MerchantDefaultArgs<ExtArgs>
    posIntegration?: boolean | POSIntegrationDefaultArgs<ExtArgs>
  }

  export type $LocationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Location"
    objects: {
      merchant: Prisma.$MerchantPayload<ExtArgs>
      posIntegration: Prisma.$POSIntegrationPayload<ExtArgs>
      transactions: Prisma.$TransactionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      merchantId: string
      posIntegrationId: string
      posLocationId: string
      name: string
      address: string | null
      city: string | null
      state: string | null
      zipCode: string | null
      country: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["location"]>
    composites: {}
  }

  type LocationGetPayload<S extends boolean | null | undefined | LocationDefaultArgs> = $Result.GetResult<Prisma.$LocationPayload, S>

  type LocationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LocationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LocationCountAggregateInputType | true
    }

  export interface LocationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Location'], meta: { name: 'Location' } }
    /**
     * Find zero or one Location that matches the filter.
     * @param {LocationFindUniqueArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LocationFindUniqueArgs>(args: SelectSubset<T, LocationFindUniqueArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Location that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LocationFindUniqueOrThrowArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LocationFindUniqueOrThrowArgs>(args: SelectSubset<T, LocationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Location that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationFindFirstArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LocationFindFirstArgs>(args?: SelectSubset<T, LocationFindFirstArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Location that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationFindFirstOrThrowArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LocationFindFirstOrThrowArgs>(args?: SelectSubset<T, LocationFindFirstOrThrowArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Locations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Locations
     * const locations = await prisma.location.findMany()
     * 
     * // Get first 10 Locations
     * const locations = await prisma.location.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const locationWithIdOnly = await prisma.location.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LocationFindManyArgs>(args?: SelectSubset<T, LocationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Location.
     * @param {LocationCreateArgs} args - Arguments to create a Location.
     * @example
     * // Create one Location
     * const Location = await prisma.location.create({
     *   data: {
     *     // ... data to create a Location
     *   }
     * })
     * 
     */
    create<T extends LocationCreateArgs>(args: SelectSubset<T, LocationCreateArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Locations.
     * @param {LocationCreateManyArgs} args - Arguments to create many Locations.
     * @example
     * // Create many Locations
     * const location = await prisma.location.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LocationCreateManyArgs>(args?: SelectSubset<T, LocationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Locations and returns the data saved in the database.
     * @param {LocationCreateManyAndReturnArgs} args - Arguments to create many Locations.
     * @example
     * // Create many Locations
     * const location = await prisma.location.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Locations and only return the `id`
     * const locationWithIdOnly = await prisma.location.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LocationCreateManyAndReturnArgs>(args?: SelectSubset<T, LocationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Location.
     * @param {LocationDeleteArgs} args - Arguments to delete one Location.
     * @example
     * // Delete one Location
     * const Location = await prisma.location.delete({
     *   where: {
     *     // ... filter to delete one Location
     *   }
     * })
     * 
     */
    delete<T extends LocationDeleteArgs>(args: SelectSubset<T, LocationDeleteArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Location.
     * @param {LocationUpdateArgs} args - Arguments to update one Location.
     * @example
     * // Update one Location
     * const location = await prisma.location.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LocationUpdateArgs>(args: SelectSubset<T, LocationUpdateArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Locations.
     * @param {LocationDeleteManyArgs} args - Arguments to filter Locations to delete.
     * @example
     * // Delete a few Locations
     * const { count } = await prisma.location.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LocationDeleteManyArgs>(args?: SelectSubset<T, LocationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Locations
     * const location = await prisma.location.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LocationUpdateManyArgs>(args: SelectSubset<T, LocationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Location.
     * @param {LocationUpsertArgs} args - Arguments to update or create a Location.
     * @example
     * // Update or create a Location
     * const location = await prisma.location.upsert({
     *   create: {
     *     // ... data to create a Location
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Location we want to update
     *   }
     * })
     */
    upsert<T extends LocationUpsertArgs>(args: SelectSubset<T, LocationUpsertArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationCountArgs} args - Arguments to filter Locations to count.
     * @example
     * // Count the number of Locations
     * const count = await prisma.location.count({
     *   where: {
     *     // ... the filter for the Locations we want to count
     *   }
     * })
    **/
    count<T extends LocationCountArgs>(
      args?: Subset<T, LocationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LocationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Location.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LocationAggregateArgs>(args: Subset<T, LocationAggregateArgs>): Prisma.PrismaPromise<GetLocationAggregateType<T>>

    /**
     * Group by Location.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LocationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LocationGroupByArgs['orderBy'] }
        : { orderBy?: LocationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LocationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLocationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Location model
   */
  readonly fields: LocationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Location.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LocationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    merchant<T extends MerchantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MerchantDefaultArgs<ExtArgs>>): Prisma__MerchantClient<$Result.GetResult<Prisma.$MerchantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    posIntegration<T extends POSIntegrationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, POSIntegrationDefaultArgs<ExtArgs>>): Prisma__POSIntegrationClient<$Result.GetResult<Prisma.$POSIntegrationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    transactions<T extends Location$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, Location$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Location model
   */ 
  interface LocationFieldRefs {
    readonly id: FieldRef<"Location", 'String'>
    readonly merchantId: FieldRef<"Location", 'String'>
    readonly posIntegrationId: FieldRef<"Location", 'String'>
    readonly posLocationId: FieldRef<"Location", 'String'>
    readonly name: FieldRef<"Location", 'String'>
    readonly address: FieldRef<"Location", 'String'>
    readonly city: FieldRef<"Location", 'String'>
    readonly state: FieldRef<"Location", 'String'>
    readonly zipCode: FieldRef<"Location", 'String'>
    readonly country: FieldRef<"Location", 'String'>
    readonly createdAt: FieldRef<"Location", 'DateTime'>
    readonly updatedAt: FieldRef<"Location", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Location findUnique
   */
  export type LocationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location findUniqueOrThrow
   */
  export type LocationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location findFirst
   */
  export type LocationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Locations.
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Locations.
     */
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * Location findFirstOrThrow
   */
  export type LocationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Locations.
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Locations.
     */
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * Location findMany
   */
  export type LocationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Locations to fetch.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Locations.
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * Location create
   */
  export type LocationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * The data needed to create a Location.
     */
    data: XOR<LocationCreateInput, LocationUncheckedCreateInput>
  }

  /**
   * Location createMany
   */
  export type LocationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Locations.
     */
    data: LocationCreateManyInput | LocationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Location createManyAndReturn
   */
  export type LocationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Locations.
     */
    data: LocationCreateManyInput | LocationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Location update
   */
  export type LocationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * The data needed to update a Location.
     */
    data: XOR<LocationUpdateInput, LocationUncheckedUpdateInput>
    /**
     * Choose, which Location to update.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location updateMany
   */
  export type LocationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Locations.
     */
    data: XOR<LocationUpdateManyMutationInput, LocationUncheckedUpdateManyInput>
    /**
     * Filter which Locations to update
     */
    where?: LocationWhereInput
  }

  /**
   * Location upsert
   */
  export type LocationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * The filter to search for the Location to update in case it exists.
     */
    where: LocationWhereUniqueInput
    /**
     * In case the Location found by the `where` argument doesn't exist, create a new Location with this data.
     */
    create: XOR<LocationCreateInput, LocationUncheckedCreateInput>
    /**
     * In case the Location was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LocationUpdateInput, LocationUncheckedUpdateInput>
  }

  /**
   * Location delete
   */
  export type LocationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter which Location to delete.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location deleteMany
   */
  export type LocationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Locations to delete
     */
    where?: LocationWhereInput
  }

  /**
   * Location.transactions
   */
  export type Location$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Location without action
   */
  export type LocationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
  }


  /**
   * Model Customer
   */

  export type AggregateCustomer = {
    _count: CustomerCountAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  export type CustomerMinAggregateOutputType = {
    id: string | null
    phoneNumber: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerMaxAggregateOutputType = {
    id: string | null
    phoneNumber: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerCountAggregateOutputType = {
    id: number
    phoneNumber: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CustomerMinAggregateInputType = {
    id?: true
    phoneNumber?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerMaxAggregateInputType = {
    id?: true
    phoneNumber?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerCountAggregateInputType = {
    id?: true
    phoneNumber?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CustomerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customer to aggregate.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Customers
    **/
    _count?: true | CustomerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerMaxAggregateInputType
  }

  export type GetCustomerAggregateType<T extends CustomerAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomer[P]>
      : GetScalarType<T[P], AggregateCustomer[P]>
  }




  export type CustomerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerWhereInput
    orderBy?: CustomerOrderByWithAggregationInput | CustomerOrderByWithAggregationInput[]
    by: CustomerScalarFieldEnum[] | CustomerScalarFieldEnum
    having?: CustomerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerCountAggregateInputType | true
    _min?: CustomerMinAggregateInputType
    _max?: CustomerMaxAggregateInputType
  }

  export type CustomerGroupByOutputType = {
    id: string
    phoneNumber: string | null
    createdAt: Date
    updatedAt: Date
    _count: CustomerCountAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  type GetCustomerGroupByPayload<T extends CustomerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerGroupByOutputType[P]>
        }
      >
    >


  export type CustomerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    phoneNumber?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    linkedCards?: boolean | Customer$linkedCardsArgs<ExtArgs>
    transactions?: boolean | Customer$transactionsArgs<ExtArgs>
    customerBalances?: boolean | Customer$customerBalancesArgs<ExtArgs>
    redemptions?: boolean | Customer$redemptionsArgs<ExtArgs>
    ledgerEntries?: boolean | Customer$ledgerEntriesArgs<ExtArgs>
    itemCounts?: boolean | Customer$itemCountsArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    phoneNumber?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectScalar = {
    id?: boolean
    phoneNumber?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CustomerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    linkedCards?: boolean | Customer$linkedCardsArgs<ExtArgs>
    transactions?: boolean | Customer$transactionsArgs<ExtArgs>
    customerBalances?: boolean | Customer$customerBalancesArgs<ExtArgs>
    redemptions?: boolean | Customer$redemptionsArgs<ExtArgs>
    ledgerEntries?: boolean | Customer$ledgerEntriesArgs<ExtArgs>
    itemCounts?: boolean | Customer$itemCountsArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CustomerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CustomerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Customer"
    objects: {
      linkedCards: Prisma.$LinkedCardPayload<ExtArgs>[]
      transactions: Prisma.$TransactionPayload<ExtArgs>[]
      customerBalances: Prisma.$CustomerBalancePayload<ExtArgs>[]
      redemptions: Prisma.$RedemptionPayload<ExtArgs>[]
      ledgerEntries: Prisma.$LedgerEntryPayload<ExtArgs>[]
      itemCounts: Prisma.$CustomerItemCountPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      phoneNumber: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["customer"]>
    composites: {}
  }

  type CustomerGetPayload<S extends boolean | null | undefined | CustomerDefaultArgs> = $Result.GetResult<Prisma.$CustomerPayload, S>

  type CustomerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CustomerFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CustomerCountAggregateInputType | true
    }

  export interface CustomerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Customer'], meta: { name: 'Customer' } }
    /**
     * Find zero or one Customer that matches the filter.
     * @param {CustomerFindUniqueArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomerFindUniqueArgs>(args: SelectSubset<T, CustomerFindUniqueArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Customer that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CustomerFindUniqueOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomerFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Customer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomerFindFirstArgs>(args?: SelectSubset<T, CustomerFindFirstArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Customer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomerFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomerFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Customers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Customers
     * const customers = await prisma.customer.findMany()
     * 
     * // Get first 10 Customers
     * const customers = await prisma.customer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerWithIdOnly = await prisma.customer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomerFindManyArgs>(args?: SelectSubset<T, CustomerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Customer.
     * @param {CustomerCreateArgs} args - Arguments to create a Customer.
     * @example
     * // Create one Customer
     * const Customer = await prisma.customer.create({
     *   data: {
     *     // ... data to create a Customer
     *   }
     * })
     * 
     */
    create<T extends CustomerCreateArgs>(args: SelectSubset<T, CustomerCreateArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Customers.
     * @param {CustomerCreateManyArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomerCreateManyArgs>(args?: SelectSubset<T, CustomerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Customers and returns the data saved in the database.
     * @param {CustomerCreateManyAndReturnArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Customers and only return the `id`
     * const customerWithIdOnly = await prisma.customer.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustomerCreateManyAndReturnArgs>(args?: SelectSubset<T, CustomerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Customer.
     * @param {CustomerDeleteArgs} args - Arguments to delete one Customer.
     * @example
     * // Delete one Customer
     * const Customer = await prisma.customer.delete({
     *   where: {
     *     // ... filter to delete one Customer
     *   }
     * })
     * 
     */
    delete<T extends CustomerDeleteArgs>(args: SelectSubset<T, CustomerDeleteArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Customer.
     * @param {CustomerUpdateArgs} args - Arguments to update one Customer.
     * @example
     * // Update one Customer
     * const customer = await prisma.customer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomerUpdateArgs>(args: SelectSubset<T, CustomerUpdateArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Customers.
     * @param {CustomerDeleteManyArgs} args - Arguments to filter Customers to delete.
     * @example
     * // Delete a few Customers
     * const { count } = await prisma.customer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomerDeleteManyArgs>(args?: SelectSubset<T, CustomerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomerUpdateManyArgs>(args: SelectSubset<T, CustomerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Customer.
     * @param {CustomerUpsertArgs} args - Arguments to update or create a Customer.
     * @example
     * // Update or create a Customer
     * const customer = await prisma.customer.upsert({
     *   create: {
     *     // ... data to create a Customer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Customer we want to update
     *   }
     * })
     */
    upsert<T extends CustomerUpsertArgs>(args: SelectSubset<T, CustomerUpsertArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerCountArgs} args - Arguments to filter Customers to count.
     * @example
     * // Count the number of Customers
     * const count = await prisma.customer.count({
     *   where: {
     *     // ... the filter for the Customers we want to count
     *   }
     * })
    **/
    count<T extends CustomerCountArgs>(
      args?: Subset<T, CustomerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerAggregateArgs>(args: Subset<T, CustomerAggregateArgs>): Prisma.PrismaPromise<GetCustomerAggregateType<T>>

    /**
     * Group by Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerGroupByArgs['orderBy'] }
        : { orderBy?: CustomerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Customer model
   */
  readonly fields: CustomerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Customer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    linkedCards<T extends Customer$linkedCardsArgs<ExtArgs> = {}>(args?: Subset<T, Customer$linkedCardsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LinkedCardPayload<ExtArgs>, T, "findMany"> | Null>
    transactions<T extends Customer$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, Customer$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany"> | Null>
    customerBalances<T extends Customer$customerBalancesArgs<ExtArgs> = {}>(args?: Subset<T, Customer$customerBalancesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerBalancePayload<ExtArgs>, T, "findMany"> | Null>
    redemptions<T extends Customer$redemptionsArgs<ExtArgs> = {}>(args?: Subset<T, Customer$redemptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RedemptionPayload<ExtArgs>, T, "findMany"> | Null>
    ledgerEntries<T extends Customer$ledgerEntriesArgs<ExtArgs> = {}>(args?: Subset<T, Customer$ledgerEntriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LedgerEntryPayload<ExtArgs>, T, "findMany"> | Null>
    itemCounts<T extends Customer$itemCountsArgs<ExtArgs> = {}>(args?: Subset<T, Customer$itemCountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerItemCountPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Customer model
   */ 
  interface CustomerFieldRefs {
    readonly id: FieldRef<"Customer", 'String'>
    readonly phoneNumber: FieldRef<"Customer", 'String'>
    readonly createdAt: FieldRef<"Customer", 'DateTime'>
    readonly updatedAt: FieldRef<"Customer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Customer findUnique
   */
  export type CustomerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findUniqueOrThrow
   */
  export type CustomerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findFirst
   */
  export type CustomerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer findFirstOrThrow
   */
  export type CustomerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer findMany
   */
  export type CustomerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customers to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer create
   */
  export type CustomerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to create a Customer.
     */
    data: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
  }

  /**
   * Customer createMany
   */
  export type CustomerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Customers.
     */
    data: CustomerCreateManyInput | CustomerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Customer createManyAndReturn
   */
  export type CustomerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Customers.
     */
    data: CustomerCreateManyInput | CustomerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Customer update
   */
  export type CustomerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to update a Customer.
     */
    data: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
    /**
     * Choose, which Customer to update.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer updateMany
   */
  export type CustomerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Customers.
     */
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyInput>
    /**
     * Filter which Customers to update
     */
    where?: CustomerWhereInput
  }

  /**
   * Customer upsert
   */
  export type CustomerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The filter to search for the Customer to update in case it exists.
     */
    where: CustomerWhereUniqueInput
    /**
     * In case the Customer found by the `where` argument doesn't exist, create a new Customer with this data.
     */
    create: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
    /**
     * In case the Customer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
  }

  /**
   * Customer delete
   */
  export type CustomerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter which Customer to delete.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer deleteMany
   */
  export type CustomerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customers to delete
     */
    where?: CustomerWhereInput
  }

  /**
   * Customer.linkedCards
   */
  export type Customer$linkedCardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinkedCard
     */
    select?: LinkedCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkedCardInclude<ExtArgs> | null
    where?: LinkedCardWhereInput
    orderBy?: LinkedCardOrderByWithRelationInput | LinkedCardOrderByWithRelationInput[]
    cursor?: LinkedCardWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LinkedCardScalarFieldEnum | LinkedCardScalarFieldEnum[]
  }

  /**
   * Customer.transactions
   */
  export type Customer$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Customer.customerBalances
   */
  export type Customer$customerBalancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerBalance
     */
    select?: CustomerBalanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerBalanceInclude<ExtArgs> | null
    where?: CustomerBalanceWhereInput
    orderBy?: CustomerBalanceOrderByWithRelationInput | CustomerBalanceOrderByWithRelationInput[]
    cursor?: CustomerBalanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerBalanceScalarFieldEnum | CustomerBalanceScalarFieldEnum[]
  }

  /**
   * Customer.redemptions
   */
  export type Customer$redemptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redemption
     */
    select?: RedemptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RedemptionInclude<ExtArgs> | null
    where?: RedemptionWhereInput
    orderBy?: RedemptionOrderByWithRelationInput | RedemptionOrderByWithRelationInput[]
    cursor?: RedemptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RedemptionScalarFieldEnum | RedemptionScalarFieldEnum[]
  }

  /**
   * Customer.ledgerEntries
   */
  export type Customer$ledgerEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerEntry
     */
    select?: LedgerEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerEntryInclude<ExtArgs> | null
    where?: LedgerEntryWhereInput
    orderBy?: LedgerEntryOrderByWithRelationInput | LedgerEntryOrderByWithRelationInput[]
    cursor?: LedgerEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LedgerEntryScalarFieldEnum | LedgerEntryScalarFieldEnum[]
  }

  /**
   * Customer.itemCounts
   */
  export type Customer$itemCountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerItemCount
     */
    select?: CustomerItemCountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerItemCountInclude<ExtArgs> | null
    where?: CustomerItemCountWhereInput
    orderBy?: CustomerItemCountOrderByWithRelationInput | CustomerItemCountOrderByWithRelationInput[]
    cursor?: CustomerItemCountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerItemCountScalarFieldEnum | CustomerItemCountScalarFieldEnum[]
  }

  /**
   * Customer without action
   */
  export type CustomerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
  }


  /**
   * Model LinkedCard
   */

  export type AggregateLinkedCard = {
    _count: LinkedCardCountAggregateOutputType | null
    _min: LinkedCardMinAggregateOutputType | null
    _max: LinkedCardMaxAggregateOutputType | null
  }

  export type LinkedCardMinAggregateOutputType = {
    id: string | null
    customerId: string | null
    cardFingerprint: string | null
    last4: string | null
    brand: string | null
    zipCode: string | null
    posProvider: $Enums.POSProvider | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LinkedCardMaxAggregateOutputType = {
    id: string | null
    customerId: string | null
    cardFingerprint: string | null
    last4: string | null
    brand: string | null
    zipCode: string | null
    posProvider: $Enums.POSProvider | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LinkedCardCountAggregateOutputType = {
    id: number
    customerId: number
    cardFingerprint: number
    last4: number
    brand: number
    zipCode: number
    posProvider: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LinkedCardMinAggregateInputType = {
    id?: true
    customerId?: true
    cardFingerprint?: true
    last4?: true
    brand?: true
    zipCode?: true
    posProvider?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LinkedCardMaxAggregateInputType = {
    id?: true
    customerId?: true
    cardFingerprint?: true
    last4?: true
    brand?: true
    zipCode?: true
    posProvider?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LinkedCardCountAggregateInputType = {
    id?: true
    customerId?: true
    cardFingerprint?: true
    last4?: true
    brand?: true
    zipCode?: true
    posProvider?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LinkedCardAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LinkedCard to aggregate.
     */
    where?: LinkedCardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LinkedCards to fetch.
     */
    orderBy?: LinkedCardOrderByWithRelationInput | LinkedCardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LinkedCardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LinkedCards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LinkedCards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LinkedCards
    **/
    _count?: true | LinkedCardCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LinkedCardMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LinkedCardMaxAggregateInputType
  }

  export type GetLinkedCardAggregateType<T extends LinkedCardAggregateArgs> = {
        [P in keyof T & keyof AggregateLinkedCard]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLinkedCard[P]>
      : GetScalarType<T[P], AggregateLinkedCard[P]>
  }




  export type LinkedCardGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LinkedCardWhereInput
    orderBy?: LinkedCardOrderByWithAggregationInput | LinkedCardOrderByWithAggregationInput[]
    by: LinkedCardScalarFieldEnum[] | LinkedCardScalarFieldEnum
    having?: LinkedCardScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LinkedCardCountAggregateInputType | true
    _min?: LinkedCardMinAggregateInputType
    _max?: LinkedCardMaxAggregateInputType
  }

  export type LinkedCardGroupByOutputType = {
    id: string
    customerId: string
    cardFingerprint: string
    last4: string
    brand: string | null
    zipCode: string | null
    posProvider: $Enums.POSProvider
    createdAt: Date
    updatedAt: Date
    _count: LinkedCardCountAggregateOutputType | null
    _min: LinkedCardMinAggregateOutputType | null
    _max: LinkedCardMaxAggregateOutputType | null
  }

  type GetLinkedCardGroupByPayload<T extends LinkedCardGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LinkedCardGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LinkedCardGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LinkedCardGroupByOutputType[P]>
            : GetScalarType<T[P], LinkedCardGroupByOutputType[P]>
        }
      >
    >


  export type LinkedCardSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    cardFingerprint?: boolean
    last4?: boolean
    brand?: boolean
    zipCode?: boolean
    posProvider?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["linkedCard"]>

  export type LinkedCardSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    cardFingerprint?: boolean
    last4?: boolean
    brand?: boolean
    zipCode?: boolean
    posProvider?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["linkedCard"]>

  export type LinkedCardSelectScalar = {
    id?: boolean
    customerId?: boolean
    cardFingerprint?: boolean
    last4?: boolean
    brand?: boolean
    zipCode?: boolean
    posProvider?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LinkedCardInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }
  export type LinkedCardIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }

  export type $LinkedCardPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LinkedCard"
    objects: {
      customer: Prisma.$CustomerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      customerId: string
      cardFingerprint: string
      last4: string
      brand: string | null
      zipCode: string | null
      posProvider: $Enums.POSProvider
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["linkedCard"]>
    composites: {}
  }

  type LinkedCardGetPayload<S extends boolean | null | undefined | LinkedCardDefaultArgs> = $Result.GetResult<Prisma.$LinkedCardPayload, S>

  type LinkedCardCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LinkedCardFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LinkedCardCountAggregateInputType | true
    }

  export interface LinkedCardDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LinkedCard'], meta: { name: 'LinkedCard' } }
    /**
     * Find zero or one LinkedCard that matches the filter.
     * @param {LinkedCardFindUniqueArgs} args - Arguments to find a LinkedCard
     * @example
     * // Get one LinkedCard
     * const linkedCard = await prisma.linkedCard.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LinkedCardFindUniqueArgs>(args: SelectSubset<T, LinkedCardFindUniqueArgs<ExtArgs>>): Prisma__LinkedCardClient<$Result.GetResult<Prisma.$LinkedCardPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one LinkedCard that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LinkedCardFindUniqueOrThrowArgs} args - Arguments to find a LinkedCard
     * @example
     * // Get one LinkedCard
     * const linkedCard = await prisma.linkedCard.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LinkedCardFindUniqueOrThrowArgs>(args: SelectSubset<T, LinkedCardFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LinkedCardClient<$Result.GetResult<Prisma.$LinkedCardPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first LinkedCard that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LinkedCardFindFirstArgs} args - Arguments to find a LinkedCard
     * @example
     * // Get one LinkedCard
     * const linkedCard = await prisma.linkedCard.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LinkedCardFindFirstArgs>(args?: SelectSubset<T, LinkedCardFindFirstArgs<ExtArgs>>): Prisma__LinkedCardClient<$Result.GetResult<Prisma.$LinkedCardPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first LinkedCard that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LinkedCardFindFirstOrThrowArgs} args - Arguments to find a LinkedCard
     * @example
     * // Get one LinkedCard
     * const linkedCard = await prisma.linkedCard.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LinkedCardFindFirstOrThrowArgs>(args?: SelectSubset<T, LinkedCardFindFirstOrThrowArgs<ExtArgs>>): Prisma__LinkedCardClient<$Result.GetResult<Prisma.$LinkedCardPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more LinkedCards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LinkedCardFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LinkedCards
     * const linkedCards = await prisma.linkedCard.findMany()
     * 
     * // Get first 10 LinkedCards
     * const linkedCards = await prisma.linkedCard.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const linkedCardWithIdOnly = await prisma.linkedCard.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LinkedCardFindManyArgs>(args?: SelectSubset<T, LinkedCardFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LinkedCardPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a LinkedCard.
     * @param {LinkedCardCreateArgs} args - Arguments to create a LinkedCard.
     * @example
     * // Create one LinkedCard
     * const LinkedCard = await prisma.linkedCard.create({
     *   data: {
     *     // ... data to create a LinkedCard
     *   }
     * })
     * 
     */
    create<T extends LinkedCardCreateArgs>(args: SelectSubset<T, LinkedCardCreateArgs<ExtArgs>>): Prisma__LinkedCardClient<$Result.GetResult<Prisma.$LinkedCardPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many LinkedCards.
     * @param {LinkedCardCreateManyArgs} args - Arguments to create many LinkedCards.
     * @example
     * // Create many LinkedCards
     * const linkedCard = await prisma.linkedCard.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LinkedCardCreateManyArgs>(args?: SelectSubset<T, LinkedCardCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LinkedCards and returns the data saved in the database.
     * @param {LinkedCardCreateManyAndReturnArgs} args - Arguments to create many LinkedCards.
     * @example
     * // Create many LinkedCards
     * const linkedCard = await prisma.linkedCard.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LinkedCards and only return the `id`
     * const linkedCardWithIdOnly = await prisma.linkedCard.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LinkedCardCreateManyAndReturnArgs>(args?: SelectSubset<T, LinkedCardCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LinkedCardPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a LinkedCard.
     * @param {LinkedCardDeleteArgs} args - Arguments to delete one LinkedCard.
     * @example
     * // Delete one LinkedCard
     * const LinkedCard = await prisma.linkedCard.delete({
     *   where: {
     *     // ... filter to delete one LinkedCard
     *   }
     * })
     * 
     */
    delete<T extends LinkedCardDeleteArgs>(args: SelectSubset<T, LinkedCardDeleteArgs<ExtArgs>>): Prisma__LinkedCardClient<$Result.GetResult<Prisma.$LinkedCardPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one LinkedCard.
     * @param {LinkedCardUpdateArgs} args - Arguments to update one LinkedCard.
     * @example
     * // Update one LinkedCard
     * const linkedCard = await prisma.linkedCard.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LinkedCardUpdateArgs>(args: SelectSubset<T, LinkedCardUpdateArgs<ExtArgs>>): Prisma__LinkedCardClient<$Result.GetResult<Prisma.$LinkedCardPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more LinkedCards.
     * @param {LinkedCardDeleteManyArgs} args - Arguments to filter LinkedCards to delete.
     * @example
     * // Delete a few LinkedCards
     * const { count } = await prisma.linkedCard.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LinkedCardDeleteManyArgs>(args?: SelectSubset<T, LinkedCardDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LinkedCards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LinkedCardUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LinkedCards
     * const linkedCard = await prisma.linkedCard.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LinkedCardUpdateManyArgs>(args: SelectSubset<T, LinkedCardUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LinkedCard.
     * @param {LinkedCardUpsertArgs} args - Arguments to update or create a LinkedCard.
     * @example
     * // Update or create a LinkedCard
     * const linkedCard = await prisma.linkedCard.upsert({
     *   create: {
     *     // ... data to create a LinkedCard
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LinkedCard we want to update
     *   }
     * })
     */
    upsert<T extends LinkedCardUpsertArgs>(args: SelectSubset<T, LinkedCardUpsertArgs<ExtArgs>>): Prisma__LinkedCardClient<$Result.GetResult<Prisma.$LinkedCardPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of LinkedCards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LinkedCardCountArgs} args - Arguments to filter LinkedCards to count.
     * @example
     * // Count the number of LinkedCards
     * const count = await prisma.linkedCard.count({
     *   where: {
     *     // ... the filter for the LinkedCards we want to count
     *   }
     * })
    **/
    count<T extends LinkedCardCountArgs>(
      args?: Subset<T, LinkedCardCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LinkedCardCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LinkedCard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LinkedCardAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LinkedCardAggregateArgs>(args: Subset<T, LinkedCardAggregateArgs>): Prisma.PrismaPromise<GetLinkedCardAggregateType<T>>

    /**
     * Group by LinkedCard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LinkedCardGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LinkedCardGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LinkedCardGroupByArgs['orderBy'] }
        : { orderBy?: LinkedCardGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LinkedCardGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLinkedCardGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LinkedCard model
   */
  readonly fields: LinkedCardFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LinkedCard.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LinkedCardClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LinkedCard model
   */ 
  interface LinkedCardFieldRefs {
    readonly id: FieldRef<"LinkedCard", 'String'>
    readonly customerId: FieldRef<"LinkedCard", 'String'>
    readonly cardFingerprint: FieldRef<"LinkedCard", 'String'>
    readonly last4: FieldRef<"LinkedCard", 'String'>
    readonly brand: FieldRef<"LinkedCard", 'String'>
    readonly zipCode: FieldRef<"LinkedCard", 'String'>
    readonly posProvider: FieldRef<"LinkedCard", 'POSProvider'>
    readonly createdAt: FieldRef<"LinkedCard", 'DateTime'>
    readonly updatedAt: FieldRef<"LinkedCard", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LinkedCard findUnique
   */
  export type LinkedCardFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinkedCard
     */
    select?: LinkedCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkedCardInclude<ExtArgs> | null
    /**
     * Filter, which LinkedCard to fetch.
     */
    where: LinkedCardWhereUniqueInput
  }

  /**
   * LinkedCard findUniqueOrThrow
   */
  export type LinkedCardFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinkedCard
     */
    select?: LinkedCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkedCardInclude<ExtArgs> | null
    /**
     * Filter, which LinkedCard to fetch.
     */
    where: LinkedCardWhereUniqueInput
  }

  /**
   * LinkedCard findFirst
   */
  export type LinkedCardFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinkedCard
     */
    select?: LinkedCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkedCardInclude<ExtArgs> | null
    /**
     * Filter, which LinkedCard to fetch.
     */
    where?: LinkedCardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LinkedCards to fetch.
     */
    orderBy?: LinkedCardOrderByWithRelationInput | LinkedCardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LinkedCards.
     */
    cursor?: LinkedCardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LinkedCards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LinkedCards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LinkedCards.
     */
    distinct?: LinkedCardScalarFieldEnum | LinkedCardScalarFieldEnum[]
  }

  /**
   * LinkedCard findFirstOrThrow
   */
  export type LinkedCardFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinkedCard
     */
    select?: LinkedCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkedCardInclude<ExtArgs> | null
    /**
     * Filter, which LinkedCard to fetch.
     */
    where?: LinkedCardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LinkedCards to fetch.
     */
    orderBy?: LinkedCardOrderByWithRelationInput | LinkedCardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LinkedCards.
     */
    cursor?: LinkedCardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LinkedCards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LinkedCards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LinkedCards.
     */
    distinct?: LinkedCardScalarFieldEnum | LinkedCardScalarFieldEnum[]
  }

  /**
   * LinkedCard findMany
   */
  export type LinkedCardFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinkedCard
     */
    select?: LinkedCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkedCardInclude<ExtArgs> | null
    /**
     * Filter, which LinkedCards to fetch.
     */
    where?: LinkedCardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LinkedCards to fetch.
     */
    orderBy?: LinkedCardOrderByWithRelationInput | LinkedCardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LinkedCards.
     */
    cursor?: LinkedCardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LinkedCards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LinkedCards.
     */
    skip?: number
    distinct?: LinkedCardScalarFieldEnum | LinkedCardScalarFieldEnum[]
  }

  /**
   * LinkedCard create
   */
  export type LinkedCardCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinkedCard
     */
    select?: LinkedCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkedCardInclude<ExtArgs> | null
    /**
     * The data needed to create a LinkedCard.
     */
    data: XOR<LinkedCardCreateInput, LinkedCardUncheckedCreateInput>
  }

  /**
   * LinkedCard createMany
   */
  export type LinkedCardCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LinkedCards.
     */
    data: LinkedCardCreateManyInput | LinkedCardCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LinkedCard createManyAndReturn
   */
  export type LinkedCardCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinkedCard
     */
    select?: LinkedCardSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many LinkedCards.
     */
    data: LinkedCardCreateManyInput | LinkedCardCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkedCardIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LinkedCard update
   */
  export type LinkedCardUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinkedCard
     */
    select?: LinkedCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkedCardInclude<ExtArgs> | null
    /**
     * The data needed to update a LinkedCard.
     */
    data: XOR<LinkedCardUpdateInput, LinkedCardUncheckedUpdateInput>
    /**
     * Choose, which LinkedCard to update.
     */
    where: LinkedCardWhereUniqueInput
  }

  /**
   * LinkedCard updateMany
   */
  export type LinkedCardUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LinkedCards.
     */
    data: XOR<LinkedCardUpdateManyMutationInput, LinkedCardUncheckedUpdateManyInput>
    /**
     * Filter which LinkedCards to update
     */
    where?: LinkedCardWhereInput
  }

  /**
   * LinkedCard upsert
   */
  export type LinkedCardUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinkedCard
     */
    select?: LinkedCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkedCardInclude<ExtArgs> | null
    /**
     * The filter to search for the LinkedCard to update in case it exists.
     */
    where: LinkedCardWhereUniqueInput
    /**
     * In case the LinkedCard found by the `where` argument doesn't exist, create a new LinkedCard with this data.
     */
    create: XOR<LinkedCardCreateInput, LinkedCardUncheckedCreateInput>
    /**
     * In case the LinkedCard was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LinkedCardUpdateInput, LinkedCardUncheckedUpdateInput>
  }

  /**
   * LinkedCard delete
   */
  export type LinkedCardDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinkedCard
     */
    select?: LinkedCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkedCardInclude<ExtArgs> | null
    /**
     * Filter which LinkedCard to delete.
     */
    where: LinkedCardWhereUniqueInput
  }

  /**
   * LinkedCard deleteMany
   */
  export type LinkedCardDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LinkedCards to delete
     */
    where?: LinkedCardWhereInput
  }

  /**
   * LinkedCard without action
   */
  export type LinkedCardDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinkedCard
     */
    select?: LinkedCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkedCardInclude<ExtArgs> | null
  }


  /**
   * Model Transaction
   */

  export type AggregateTransaction = {
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  export type TransactionAvgAggregateOutputType = {
    amount: Decimal | null
    pointsEarned: number | null
  }

  export type TransactionSumAggregateOutputType = {
    amount: Decimal | null
    pointsEarned: number | null
  }

  export type TransactionMinAggregateOutputType = {
    id: string | null
    merchantId: string | null
    customerId: string | null
    locationId: string | null
    posProvider: $Enums.POSProvider | null
    posTransactionId: string | null
    posLocationId: string | null
    amount: Decimal | null
    pointsEarned: number | null
    status: $Enums.TransactionStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransactionMaxAggregateOutputType = {
    id: string | null
    merchantId: string | null
    customerId: string | null
    locationId: string | null
    posProvider: $Enums.POSProvider | null
    posTransactionId: string | null
    posLocationId: string | null
    amount: Decimal | null
    pointsEarned: number | null
    status: $Enums.TransactionStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransactionCountAggregateOutputType = {
    id: number
    merchantId: number
    customerId: number
    locationId: number
    posProvider: number
    posTransactionId: number
    posLocationId: number
    amount: number
    pointsEarned: number
    status: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TransactionAvgAggregateInputType = {
    amount?: true
    pointsEarned?: true
  }

  export type TransactionSumAggregateInputType = {
    amount?: true
    pointsEarned?: true
  }

  export type TransactionMinAggregateInputType = {
    id?: true
    merchantId?: true
    customerId?: true
    locationId?: true
    posProvider?: true
    posTransactionId?: true
    posLocationId?: true
    amount?: true
    pointsEarned?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransactionMaxAggregateInputType = {
    id?: true
    merchantId?: true
    customerId?: true
    locationId?: true
    posProvider?: true
    posTransactionId?: true
    posLocationId?: true
    amount?: true
    pointsEarned?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransactionCountAggregateInputType = {
    id?: true
    merchantId?: true
    customerId?: true
    locationId?: true
    posProvider?: true
    posTransactionId?: true
    posLocationId?: true
    amount?: true
    pointsEarned?: true
    status?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transaction to aggregate.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Transactions
    **/
    _count?: true | TransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransactionMaxAggregateInputType
  }

  export type GetTransactionAggregateType<T extends TransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransaction[P]>
      : GetScalarType<T[P], AggregateTransaction[P]>
  }




  export type TransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithAggregationInput | TransactionOrderByWithAggregationInput[]
    by: TransactionScalarFieldEnum[] | TransactionScalarFieldEnum
    having?: TransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransactionCountAggregateInputType | true
    _avg?: TransactionAvgAggregateInputType
    _sum?: TransactionSumAggregateInputType
    _min?: TransactionMinAggregateInputType
    _max?: TransactionMaxAggregateInputType
  }

  export type TransactionGroupByOutputType = {
    id: string
    merchantId: string
    customerId: string | null
    locationId: string | null
    posProvider: $Enums.POSProvider
    posTransactionId: string
    posLocationId: string | null
    amount: Decimal
    pointsEarned: number
    status: $Enums.TransactionStatus
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  type GetTransactionGroupByPayload<T extends TransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransactionGroupByOutputType[P]>
            : GetScalarType<T[P], TransactionGroupByOutputType[P]>
        }
      >
    >


  export type TransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    merchantId?: boolean
    customerId?: boolean
    locationId?: boolean
    posProvider?: boolean
    posTransactionId?: boolean
    posLocationId?: boolean
    amount?: boolean
    pointsEarned?: boolean
    status?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    merchant?: boolean | MerchantDefaultArgs<ExtArgs>
    customer?: boolean | Transaction$customerArgs<ExtArgs>
    location?: boolean | Transaction$locationArgs<ExtArgs>
    ledgerEntries?: boolean | Transaction$ledgerEntriesArgs<ExtArgs>
    _count?: boolean | TransactionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    merchantId?: boolean
    customerId?: boolean
    locationId?: boolean
    posProvider?: boolean
    posTransactionId?: boolean
    posLocationId?: boolean
    amount?: boolean
    pointsEarned?: boolean
    status?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    merchant?: boolean | MerchantDefaultArgs<ExtArgs>
    customer?: boolean | Transaction$customerArgs<ExtArgs>
    location?: boolean | Transaction$locationArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectScalar = {
    id?: boolean
    merchantId?: boolean
    customerId?: boolean
    locationId?: boolean
    posProvider?: boolean
    posTransactionId?: boolean
    posLocationId?: boolean
    amount?: boolean
    pointsEarned?: boolean
    status?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    merchant?: boolean | MerchantDefaultArgs<ExtArgs>
    customer?: boolean | Transaction$customerArgs<ExtArgs>
    location?: boolean | Transaction$locationArgs<ExtArgs>
    ledgerEntries?: boolean | Transaction$ledgerEntriesArgs<ExtArgs>
    _count?: boolean | TransactionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TransactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    merchant?: boolean | MerchantDefaultArgs<ExtArgs>
    customer?: boolean | Transaction$customerArgs<ExtArgs>
    location?: boolean | Transaction$locationArgs<ExtArgs>
  }

  export type $TransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Transaction"
    objects: {
      merchant: Prisma.$MerchantPayload<ExtArgs>
      customer: Prisma.$CustomerPayload<ExtArgs> | null
      location: Prisma.$LocationPayload<ExtArgs> | null
      ledgerEntries: Prisma.$LedgerEntryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      merchantId: string
      customerId: string | null
      locationId: string | null
      posProvider: $Enums.POSProvider
      posTransactionId: string
      posLocationId: string | null
      amount: Prisma.Decimal
      pointsEarned: number
      status: $Enums.TransactionStatus
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["transaction"]>
    composites: {}
  }

  type TransactionGetPayload<S extends boolean | null | undefined | TransactionDefaultArgs> = $Result.GetResult<Prisma.$TransactionPayload, S>

  type TransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TransactionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TransactionCountAggregateInputType | true
    }

  export interface TransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Transaction'], meta: { name: 'Transaction' } }
    /**
     * Find zero or one Transaction that matches the filter.
     * @param {TransactionFindUniqueArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TransactionFindUniqueArgs>(args: SelectSubset<T, TransactionFindUniqueArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Transaction that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TransactionFindUniqueOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, TransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Transaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TransactionFindFirstArgs>(args?: SelectSubset<T, TransactionFindFirstArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Transaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, TransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transactions
     * const transactions = await prisma.transaction.findMany()
     * 
     * // Get first 10 Transactions
     * const transactions = await prisma.transaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transactionWithIdOnly = await prisma.transaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TransactionFindManyArgs>(args?: SelectSubset<T, TransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Transaction.
     * @param {TransactionCreateArgs} args - Arguments to create a Transaction.
     * @example
     * // Create one Transaction
     * const Transaction = await prisma.transaction.create({
     *   data: {
     *     // ... data to create a Transaction
     *   }
     * })
     * 
     */
    create<T extends TransactionCreateArgs>(args: SelectSubset<T, TransactionCreateArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Transactions.
     * @param {TransactionCreateManyArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transaction = await prisma.transaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TransactionCreateManyArgs>(args?: SelectSubset<T, TransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Transactions and returns the data saved in the database.
     * @param {TransactionCreateManyAndReturnArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transaction = await prisma.transaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Transactions and only return the `id`
     * const transactionWithIdOnly = await prisma.transaction.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TransactionCreateManyAndReturnArgs>(args?: SelectSubset<T, TransactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Transaction.
     * @param {TransactionDeleteArgs} args - Arguments to delete one Transaction.
     * @example
     * // Delete one Transaction
     * const Transaction = await prisma.transaction.delete({
     *   where: {
     *     // ... filter to delete one Transaction
     *   }
     * })
     * 
     */
    delete<T extends TransactionDeleteArgs>(args: SelectSubset<T, TransactionDeleteArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Transaction.
     * @param {TransactionUpdateArgs} args - Arguments to update one Transaction.
     * @example
     * // Update one Transaction
     * const transaction = await prisma.transaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TransactionUpdateArgs>(args: SelectSubset<T, TransactionUpdateArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Transactions.
     * @param {TransactionDeleteManyArgs} args - Arguments to filter Transactions to delete.
     * @example
     * // Delete a few Transactions
     * const { count } = await prisma.transaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TransactionDeleteManyArgs>(args?: SelectSubset<T, TransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transactions
     * const transaction = await prisma.transaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TransactionUpdateManyArgs>(args: SelectSubset<T, TransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Transaction.
     * @param {TransactionUpsertArgs} args - Arguments to update or create a Transaction.
     * @example
     * // Update or create a Transaction
     * const transaction = await prisma.transaction.upsert({
     *   create: {
     *     // ... data to create a Transaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transaction we want to update
     *   }
     * })
     */
    upsert<T extends TransactionUpsertArgs>(args: SelectSubset<T, TransactionUpsertArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionCountArgs} args - Arguments to filter Transactions to count.
     * @example
     * // Count the number of Transactions
     * const count = await prisma.transaction.count({
     *   where: {
     *     // ... the filter for the Transactions we want to count
     *   }
     * })
    **/
    count<T extends TransactionCountArgs>(
      args?: Subset<T, TransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransactionAggregateArgs>(args: Subset<T, TransactionAggregateArgs>): Prisma.PrismaPromise<GetTransactionAggregateType<T>>

    /**
     * Group by Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransactionGroupByArgs['orderBy'] }
        : { orderBy?: TransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Transaction model
   */
  readonly fields: TransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Transaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    merchant<T extends MerchantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MerchantDefaultArgs<ExtArgs>>): Prisma__MerchantClient<$Result.GetResult<Prisma.$MerchantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    customer<T extends Transaction$customerArgs<ExtArgs> = {}>(args?: Subset<T, Transaction$customerArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    location<T extends Transaction$locationArgs<ExtArgs> = {}>(args?: Subset<T, Transaction$locationArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    ledgerEntries<T extends Transaction$ledgerEntriesArgs<ExtArgs> = {}>(args?: Subset<T, Transaction$ledgerEntriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LedgerEntryPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Transaction model
   */ 
  interface TransactionFieldRefs {
    readonly id: FieldRef<"Transaction", 'String'>
    readonly merchantId: FieldRef<"Transaction", 'String'>
    readonly customerId: FieldRef<"Transaction", 'String'>
    readonly locationId: FieldRef<"Transaction", 'String'>
    readonly posProvider: FieldRef<"Transaction", 'POSProvider'>
    readonly posTransactionId: FieldRef<"Transaction", 'String'>
    readonly posLocationId: FieldRef<"Transaction", 'String'>
    readonly amount: FieldRef<"Transaction", 'Decimal'>
    readonly pointsEarned: FieldRef<"Transaction", 'Int'>
    readonly status: FieldRef<"Transaction", 'TransactionStatus'>
    readonly metadata: FieldRef<"Transaction", 'Json'>
    readonly createdAt: FieldRef<"Transaction", 'DateTime'>
    readonly updatedAt: FieldRef<"Transaction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Transaction findUnique
   */
  export type TransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction findUniqueOrThrow
   */
  export type TransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction findFirst
   */
  export type TransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction findFirstOrThrow
   */
  export type TransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction findMany
   */
  export type TransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transactions to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction create
   */
  export type TransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a Transaction.
     */
    data: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
  }

  /**
   * Transaction createMany
   */
  export type TransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Transactions.
     */
    data: TransactionCreateManyInput | TransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Transaction createManyAndReturn
   */
  export type TransactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Transactions.
     */
    data: TransactionCreateManyInput | TransactionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Transaction update
   */
  export type TransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a Transaction.
     */
    data: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
    /**
     * Choose, which Transaction to update.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction updateMany
   */
  export type TransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Transactions.
     */
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyInput>
    /**
     * Filter which Transactions to update
     */
    where?: TransactionWhereInput
  }

  /**
   * Transaction upsert
   */
  export type TransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the Transaction to update in case it exists.
     */
    where: TransactionWhereUniqueInput
    /**
     * In case the Transaction found by the `where` argument doesn't exist, create a new Transaction with this data.
     */
    create: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
    /**
     * In case the Transaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
  }

  /**
   * Transaction delete
   */
  export type TransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter which Transaction to delete.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction deleteMany
   */
  export type TransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transactions to delete
     */
    where?: TransactionWhereInput
  }

  /**
   * Transaction.customer
   */
  export type Transaction$customerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    where?: CustomerWhereInput
  }

  /**
   * Transaction.location
   */
  export type Transaction$locationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    where?: LocationWhereInput
  }

  /**
   * Transaction.ledgerEntries
   */
  export type Transaction$ledgerEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerEntry
     */
    select?: LedgerEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerEntryInclude<ExtArgs> | null
    where?: LedgerEntryWhereInput
    orderBy?: LedgerEntryOrderByWithRelationInput | LedgerEntryOrderByWithRelationInput[]
    cursor?: LedgerEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LedgerEntryScalarFieldEnum | LedgerEntryScalarFieldEnum[]
  }

  /**
   * Transaction without action
   */
  export type TransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
  }


  /**
   * Model CustomerBalance
   */

  export type AggregateCustomerBalance = {
    _count: CustomerBalanceCountAggregateOutputType | null
    _avg: CustomerBalanceAvgAggregateOutputType | null
    _sum: CustomerBalanceSumAggregateOutputType | null
    _min: CustomerBalanceMinAggregateOutputType | null
    _max: CustomerBalanceMaxAggregateOutputType | null
  }

  export type CustomerBalanceAvgAggregateOutputType = {
    points: number | null
  }

  export type CustomerBalanceSumAggregateOutputType = {
    points: number | null
  }

  export type CustomerBalanceMinAggregateOutputType = {
    id: string | null
    customerId: string | null
    merchantId: string | null
    points: number | null
    updatedAt: Date | null
  }

  export type CustomerBalanceMaxAggregateOutputType = {
    id: string | null
    customerId: string | null
    merchantId: string | null
    points: number | null
    updatedAt: Date | null
  }

  export type CustomerBalanceCountAggregateOutputType = {
    id: number
    customerId: number
    merchantId: number
    points: number
    updatedAt: number
    _all: number
  }


  export type CustomerBalanceAvgAggregateInputType = {
    points?: true
  }

  export type CustomerBalanceSumAggregateInputType = {
    points?: true
  }

  export type CustomerBalanceMinAggregateInputType = {
    id?: true
    customerId?: true
    merchantId?: true
    points?: true
    updatedAt?: true
  }

  export type CustomerBalanceMaxAggregateInputType = {
    id?: true
    customerId?: true
    merchantId?: true
    points?: true
    updatedAt?: true
  }

  export type CustomerBalanceCountAggregateInputType = {
    id?: true
    customerId?: true
    merchantId?: true
    points?: true
    updatedAt?: true
    _all?: true
  }

  export type CustomerBalanceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomerBalance to aggregate.
     */
    where?: CustomerBalanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerBalances to fetch.
     */
    orderBy?: CustomerBalanceOrderByWithRelationInput | CustomerBalanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerBalanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerBalances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerBalances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CustomerBalances
    **/
    _count?: true | CustomerBalanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomerBalanceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomerBalanceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerBalanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerBalanceMaxAggregateInputType
  }

  export type GetCustomerBalanceAggregateType<T extends CustomerBalanceAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomerBalance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomerBalance[P]>
      : GetScalarType<T[P], AggregateCustomerBalance[P]>
  }




  export type CustomerBalanceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerBalanceWhereInput
    orderBy?: CustomerBalanceOrderByWithAggregationInput | CustomerBalanceOrderByWithAggregationInput[]
    by: CustomerBalanceScalarFieldEnum[] | CustomerBalanceScalarFieldEnum
    having?: CustomerBalanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerBalanceCountAggregateInputType | true
    _avg?: CustomerBalanceAvgAggregateInputType
    _sum?: CustomerBalanceSumAggregateInputType
    _min?: CustomerBalanceMinAggregateInputType
    _max?: CustomerBalanceMaxAggregateInputType
  }

  export type CustomerBalanceGroupByOutputType = {
    id: string
    customerId: string
    merchantId: string
    points: number
    updatedAt: Date
    _count: CustomerBalanceCountAggregateOutputType | null
    _avg: CustomerBalanceAvgAggregateOutputType | null
    _sum: CustomerBalanceSumAggregateOutputType | null
    _min: CustomerBalanceMinAggregateOutputType | null
    _max: CustomerBalanceMaxAggregateOutputType | null
  }

  type GetCustomerBalanceGroupByPayload<T extends CustomerBalanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerBalanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerBalanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerBalanceGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerBalanceGroupByOutputType[P]>
        }
      >
    >


  export type CustomerBalanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    merchantId?: boolean
    points?: boolean
    updatedAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    merchant?: boolean | MerchantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerBalance"]>

  export type CustomerBalanceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    merchantId?: boolean
    points?: boolean
    updatedAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    merchant?: boolean | MerchantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerBalance"]>

  export type CustomerBalanceSelectScalar = {
    id?: boolean
    customerId?: boolean
    merchantId?: boolean
    points?: boolean
    updatedAt?: boolean
  }

  export type CustomerBalanceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    merchant?: boolean | MerchantDefaultArgs<ExtArgs>
  }
  export type CustomerBalanceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    merchant?: boolean | MerchantDefaultArgs<ExtArgs>
  }

  export type $CustomerBalancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CustomerBalance"
    objects: {
      customer: Prisma.$CustomerPayload<ExtArgs>
      merchant: Prisma.$MerchantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      customerId: string
      merchantId: string
      points: number
      updatedAt: Date
    }, ExtArgs["result"]["customerBalance"]>
    composites: {}
  }

  type CustomerBalanceGetPayload<S extends boolean | null | undefined | CustomerBalanceDefaultArgs> = $Result.GetResult<Prisma.$CustomerBalancePayload, S>

  type CustomerBalanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CustomerBalanceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CustomerBalanceCountAggregateInputType | true
    }

  export interface CustomerBalanceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CustomerBalance'], meta: { name: 'CustomerBalance' } }
    /**
     * Find zero or one CustomerBalance that matches the filter.
     * @param {CustomerBalanceFindUniqueArgs} args - Arguments to find a CustomerBalance
     * @example
     * // Get one CustomerBalance
     * const customerBalance = await prisma.customerBalance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomerBalanceFindUniqueArgs>(args: SelectSubset<T, CustomerBalanceFindUniqueArgs<ExtArgs>>): Prisma__CustomerBalanceClient<$Result.GetResult<Prisma.$CustomerBalancePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CustomerBalance that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CustomerBalanceFindUniqueOrThrowArgs} args - Arguments to find a CustomerBalance
     * @example
     * // Get one CustomerBalance
     * const customerBalance = await prisma.customerBalance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomerBalanceFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomerBalanceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomerBalanceClient<$Result.GetResult<Prisma.$CustomerBalancePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CustomerBalance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerBalanceFindFirstArgs} args - Arguments to find a CustomerBalance
     * @example
     * // Get one CustomerBalance
     * const customerBalance = await prisma.customerBalance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomerBalanceFindFirstArgs>(args?: SelectSubset<T, CustomerBalanceFindFirstArgs<ExtArgs>>): Prisma__CustomerBalanceClient<$Result.GetResult<Prisma.$CustomerBalancePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CustomerBalance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerBalanceFindFirstOrThrowArgs} args - Arguments to find a CustomerBalance
     * @example
     * // Get one CustomerBalance
     * const customerBalance = await prisma.customerBalance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomerBalanceFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomerBalanceFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomerBalanceClient<$Result.GetResult<Prisma.$CustomerBalancePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CustomerBalances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerBalanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CustomerBalances
     * const customerBalances = await prisma.customerBalance.findMany()
     * 
     * // Get first 10 CustomerBalances
     * const customerBalances = await prisma.customerBalance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerBalanceWithIdOnly = await prisma.customerBalance.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomerBalanceFindManyArgs>(args?: SelectSubset<T, CustomerBalanceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerBalancePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CustomerBalance.
     * @param {CustomerBalanceCreateArgs} args - Arguments to create a CustomerBalance.
     * @example
     * // Create one CustomerBalance
     * const CustomerBalance = await prisma.customerBalance.create({
     *   data: {
     *     // ... data to create a CustomerBalance
     *   }
     * })
     * 
     */
    create<T extends CustomerBalanceCreateArgs>(args: SelectSubset<T, CustomerBalanceCreateArgs<ExtArgs>>): Prisma__CustomerBalanceClient<$Result.GetResult<Prisma.$CustomerBalancePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CustomerBalances.
     * @param {CustomerBalanceCreateManyArgs} args - Arguments to create many CustomerBalances.
     * @example
     * // Create many CustomerBalances
     * const customerBalance = await prisma.customerBalance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomerBalanceCreateManyArgs>(args?: SelectSubset<T, CustomerBalanceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CustomerBalances and returns the data saved in the database.
     * @param {CustomerBalanceCreateManyAndReturnArgs} args - Arguments to create many CustomerBalances.
     * @example
     * // Create many CustomerBalances
     * const customerBalance = await prisma.customerBalance.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CustomerBalances and only return the `id`
     * const customerBalanceWithIdOnly = await prisma.customerBalance.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustomerBalanceCreateManyAndReturnArgs>(args?: SelectSubset<T, CustomerBalanceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerBalancePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CustomerBalance.
     * @param {CustomerBalanceDeleteArgs} args - Arguments to delete one CustomerBalance.
     * @example
     * // Delete one CustomerBalance
     * const CustomerBalance = await prisma.customerBalance.delete({
     *   where: {
     *     // ... filter to delete one CustomerBalance
     *   }
     * })
     * 
     */
    delete<T extends CustomerBalanceDeleteArgs>(args: SelectSubset<T, CustomerBalanceDeleteArgs<ExtArgs>>): Prisma__CustomerBalanceClient<$Result.GetResult<Prisma.$CustomerBalancePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CustomerBalance.
     * @param {CustomerBalanceUpdateArgs} args - Arguments to update one CustomerBalance.
     * @example
     * // Update one CustomerBalance
     * const customerBalance = await prisma.customerBalance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomerBalanceUpdateArgs>(args: SelectSubset<T, CustomerBalanceUpdateArgs<ExtArgs>>): Prisma__CustomerBalanceClient<$Result.GetResult<Prisma.$CustomerBalancePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CustomerBalances.
     * @param {CustomerBalanceDeleteManyArgs} args - Arguments to filter CustomerBalances to delete.
     * @example
     * // Delete a few CustomerBalances
     * const { count } = await prisma.customerBalance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomerBalanceDeleteManyArgs>(args?: SelectSubset<T, CustomerBalanceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomerBalances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerBalanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CustomerBalances
     * const customerBalance = await prisma.customerBalance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomerBalanceUpdateManyArgs>(args: SelectSubset<T, CustomerBalanceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CustomerBalance.
     * @param {CustomerBalanceUpsertArgs} args - Arguments to update or create a CustomerBalance.
     * @example
     * // Update or create a CustomerBalance
     * const customerBalance = await prisma.customerBalance.upsert({
     *   create: {
     *     // ... data to create a CustomerBalance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CustomerBalance we want to update
     *   }
     * })
     */
    upsert<T extends CustomerBalanceUpsertArgs>(args: SelectSubset<T, CustomerBalanceUpsertArgs<ExtArgs>>): Prisma__CustomerBalanceClient<$Result.GetResult<Prisma.$CustomerBalancePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CustomerBalances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerBalanceCountArgs} args - Arguments to filter CustomerBalances to count.
     * @example
     * // Count the number of CustomerBalances
     * const count = await prisma.customerBalance.count({
     *   where: {
     *     // ... the filter for the CustomerBalances we want to count
     *   }
     * })
    **/
    count<T extends CustomerBalanceCountArgs>(
      args?: Subset<T, CustomerBalanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerBalanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CustomerBalance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerBalanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerBalanceAggregateArgs>(args: Subset<T, CustomerBalanceAggregateArgs>): Prisma.PrismaPromise<GetCustomerBalanceAggregateType<T>>

    /**
     * Group by CustomerBalance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerBalanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerBalanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerBalanceGroupByArgs['orderBy'] }
        : { orderBy?: CustomerBalanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerBalanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerBalanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CustomerBalance model
   */
  readonly fields: CustomerBalanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CustomerBalance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerBalanceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    merchant<T extends MerchantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MerchantDefaultArgs<ExtArgs>>): Prisma__MerchantClient<$Result.GetResult<Prisma.$MerchantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CustomerBalance model
   */ 
  interface CustomerBalanceFieldRefs {
    readonly id: FieldRef<"CustomerBalance", 'String'>
    readonly customerId: FieldRef<"CustomerBalance", 'String'>
    readonly merchantId: FieldRef<"CustomerBalance", 'String'>
    readonly points: FieldRef<"CustomerBalance", 'Int'>
    readonly updatedAt: FieldRef<"CustomerBalance", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CustomerBalance findUnique
   */
  export type CustomerBalanceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerBalance
     */
    select?: CustomerBalanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerBalanceInclude<ExtArgs> | null
    /**
     * Filter, which CustomerBalance to fetch.
     */
    where: CustomerBalanceWhereUniqueInput
  }

  /**
   * CustomerBalance findUniqueOrThrow
   */
  export type CustomerBalanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerBalance
     */
    select?: CustomerBalanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerBalanceInclude<ExtArgs> | null
    /**
     * Filter, which CustomerBalance to fetch.
     */
    where: CustomerBalanceWhereUniqueInput
  }

  /**
   * CustomerBalance findFirst
   */
  export type CustomerBalanceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerBalance
     */
    select?: CustomerBalanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerBalanceInclude<ExtArgs> | null
    /**
     * Filter, which CustomerBalance to fetch.
     */
    where?: CustomerBalanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerBalances to fetch.
     */
    orderBy?: CustomerBalanceOrderByWithRelationInput | CustomerBalanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerBalances.
     */
    cursor?: CustomerBalanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerBalances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerBalances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerBalances.
     */
    distinct?: CustomerBalanceScalarFieldEnum | CustomerBalanceScalarFieldEnum[]
  }

  /**
   * CustomerBalance findFirstOrThrow
   */
  export type CustomerBalanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerBalance
     */
    select?: CustomerBalanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerBalanceInclude<ExtArgs> | null
    /**
     * Filter, which CustomerBalance to fetch.
     */
    where?: CustomerBalanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerBalances to fetch.
     */
    orderBy?: CustomerBalanceOrderByWithRelationInput | CustomerBalanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerBalances.
     */
    cursor?: CustomerBalanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerBalances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerBalances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerBalances.
     */
    distinct?: CustomerBalanceScalarFieldEnum | CustomerBalanceScalarFieldEnum[]
  }

  /**
   * CustomerBalance findMany
   */
  export type CustomerBalanceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerBalance
     */
    select?: CustomerBalanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerBalanceInclude<ExtArgs> | null
    /**
     * Filter, which CustomerBalances to fetch.
     */
    where?: CustomerBalanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerBalances to fetch.
     */
    orderBy?: CustomerBalanceOrderByWithRelationInput | CustomerBalanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CustomerBalances.
     */
    cursor?: CustomerBalanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerBalances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerBalances.
     */
    skip?: number
    distinct?: CustomerBalanceScalarFieldEnum | CustomerBalanceScalarFieldEnum[]
  }

  /**
   * CustomerBalance create
   */
  export type CustomerBalanceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerBalance
     */
    select?: CustomerBalanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerBalanceInclude<ExtArgs> | null
    /**
     * The data needed to create a CustomerBalance.
     */
    data: XOR<CustomerBalanceCreateInput, CustomerBalanceUncheckedCreateInput>
  }

  /**
   * CustomerBalance createMany
   */
  export type CustomerBalanceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CustomerBalances.
     */
    data: CustomerBalanceCreateManyInput | CustomerBalanceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CustomerBalance createManyAndReturn
   */
  export type CustomerBalanceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerBalance
     */
    select?: CustomerBalanceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CustomerBalances.
     */
    data: CustomerBalanceCreateManyInput | CustomerBalanceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerBalanceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CustomerBalance update
   */
  export type CustomerBalanceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerBalance
     */
    select?: CustomerBalanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerBalanceInclude<ExtArgs> | null
    /**
     * The data needed to update a CustomerBalance.
     */
    data: XOR<CustomerBalanceUpdateInput, CustomerBalanceUncheckedUpdateInput>
    /**
     * Choose, which CustomerBalance to update.
     */
    where: CustomerBalanceWhereUniqueInput
  }

  /**
   * CustomerBalance updateMany
   */
  export type CustomerBalanceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CustomerBalances.
     */
    data: XOR<CustomerBalanceUpdateManyMutationInput, CustomerBalanceUncheckedUpdateManyInput>
    /**
     * Filter which CustomerBalances to update
     */
    where?: CustomerBalanceWhereInput
  }

  /**
   * CustomerBalance upsert
   */
  export type CustomerBalanceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerBalance
     */
    select?: CustomerBalanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerBalanceInclude<ExtArgs> | null
    /**
     * The filter to search for the CustomerBalance to update in case it exists.
     */
    where: CustomerBalanceWhereUniqueInput
    /**
     * In case the CustomerBalance found by the `where` argument doesn't exist, create a new CustomerBalance with this data.
     */
    create: XOR<CustomerBalanceCreateInput, CustomerBalanceUncheckedCreateInput>
    /**
     * In case the CustomerBalance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerBalanceUpdateInput, CustomerBalanceUncheckedUpdateInput>
  }

  /**
   * CustomerBalance delete
   */
  export type CustomerBalanceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerBalance
     */
    select?: CustomerBalanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerBalanceInclude<ExtArgs> | null
    /**
     * Filter which CustomerBalance to delete.
     */
    where: CustomerBalanceWhereUniqueInput
  }

  /**
   * CustomerBalance deleteMany
   */
  export type CustomerBalanceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomerBalances to delete
     */
    where?: CustomerBalanceWhereInput
  }

  /**
   * CustomerBalance without action
   */
  export type CustomerBalanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerBalance
     */
    select?: CustomerBalanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerBalanceInclude<ExtArgs> | null
  }


  /**
   * Model Reward
   */

  export type AggregateReward = {
    _count: RewardCountAggregateOutputType | null
    _avg: RewardAvgAggregateOutputType | null
    _sum: RewardSumAggregateOutputType | null
    _min: RewardMinAggregateOutputType | null
    _max: RewardMaxAggregateOutputType | null
  }

  export type RewardAvgAggregateOutputType = {
    pointsCost: number | null
    itemCount: number | null
  }

  export type RewardSumAggregateOutputType = {
    pointsCost: number | null
    itemCount: number | null
  }

  export type RewardMinAggregateOutputType = {
    id: string | null
    merchantId: string | null
    name: string | null
    description: string | null
    type: $Enums.RewardType | null
    pointsCost: number | null
    itemName: string | null
    itemCount: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RewardMaxAggregateOutputType = {
    id: string | null
    merchantId: string | null
    name: string | null
    description: string | null
    type: $Enums.RewardType | null
    pointsCost: number | null
    itemName: string | null
    itemCount: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RewardCountAggregateOutputType = {
    id: number
    merchantId: number
    name: number
    description: number
    type: number
    pointsCost: number
    itemName: number
    itemCount: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RewardAvgAggregateInputType = {
    pointsCost?: true
    itemCount?: true
  }

  export type RewardSumAggregateInputType = {
    pointsCost?: true
    itemCount?: true
  }

  export type RewardMinAggregateInputType = {
    id?: true
    merchantId?: true
    name?: true
    description?: true
    type?: true
    pointsCost?: true
    itemName?: true
    itemCount?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RewardMaxAggregateInputType = {
    id?: true
    merchantId?: true
    name?: true
    description?: true
    type?: true
    pointsCost?: true
    itemName?: true
    itemCount?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RewardCountAggregateInputType = {
    id?: true
    merchantId?: true
    name?: true
    description?: true
    type?: true
    pointsCost?: true
    itemName?: true
    itemCount?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RewardAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reward to aggregate.
     */
    where?: RewardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rewards to fetch.
     */
    orderBy?: RewardOrderByWithRelationInput | RewardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RewardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rewards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rewards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Rewards
    **/
    _count?: true | RewardCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RewardAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RewardSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RewardMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RewardMaxAggregateInputType
  }

  export type GetRewardAggregateType<T extends RewardAggregateArgs> = {
        [P in keyof T & keyof AggregateReward]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReward[P]>
      : GetScalarType<T[P], AggregateReward[P]>
  }




  export type RewardGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RewardWhereInput
    orderBy?: RewardOrderByWithAggregationInput | RewardOrderByWithAggregationInput[]
    by: RewardScalarFieldEnum[] | RewardScalarFieldEnum
    having?: RewardScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RewardCountAggregateInputType | true
    _avg?: RewardAvgAggregateInputType
    _sum?: RewardSumAggregateInputType
    _min?: RewardMinAggregateInputType
    _max?: RewardMaxAggregateInputType
  }

  export type RewardGroupByOutputType = {
    id: string
    merchantId: string
    name: string
    description: string | null
    type: $Enums.RewardType
    pointsCost: number | null
    itemName: string | null
    itemCount: number | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: RewardCountAggregateOutputType | null
    _avg: RewardAvgAggregateOutputType | null
    _sum: RewardSumAggregateOutputType | null
    _min: RewardMinAggregateOutputType | null
    _max: RewardMaxAggregateOutputType | null
  }

  type GetRewardGroupByPayload<T extends RewardGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RewardGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RewardGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RewardGroupByOutputType[P]>
            : GetScalarType<T[P], RewardGroupByOutputType[P]>
        }
      >
    >


  export type RewardSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    merchantId?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    pointsCost?: boolean
    itemName?: boolean
    itemCount?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    merchant?: boolean | MerchantDefaultArgs<ExtArgs>
    posRewardItems?: boolean | Reward$posRewardItemsArgs<ExtArgs>
    redemptions?: boolean | Reward$redemptionsArgs<ExtArgs>
    itemCounts?: boolean | Reward$itemCountsArgs<ExtArgs>
    _count?: boolean | RewardCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reward"]>

  export type RewardSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    merchantId?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    pointsCost?: boolean
    itemName?: boolean
    itemCount?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    merchant?: boolean | MerchantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reward"]>

  export type RewardSelectScalar = {
    id?: boolean
    merchantId?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    pointsCost?: boolean
    itemName?: boolean
    itemCount?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RewardInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    merchant?: boolean | MerchantDefaultArgs<ExtArgs>
    posRewardItems?: boolean | Reward$posRewardItemsArgs<ExtArgs>
    redemptions?: boolean | Reward$redemptionsArgs<ExtArgs>
    itemCounts?: boolean | Reward$itemCountsArgs<ExtArgs>
    _count?: boolean | RewardCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RewardIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    merchant?: boolean | MerchantDefaultArgs<ExtArgs>
  }

  export type $RewardPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Reward"
    objects: {
      merchant: Prisma.$MerchantPayload<ExtArgs>
      posRewardItems: Prisma.$POSRewardItemPayload<ExtArgs>[]
      redemptions: Prisma.$RedemptionPayload<ExtArgs>[]
      itemCounts: Prisma.$CustomerItemCountPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      merchantId: string
      name: string
      description: string | null
      type: $Enums.RewardType
      pointsCost: number | null
      itemName: string | null
      itemCount: number | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["reward"]>
    composites: {}
  }

  type RewardGetPayload<S extends boolean | null | undefined | RewardDefaultArgs> = $Result.GetResult<Prisma.$RewardPayload, S>

  type RewardCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RewardFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RewardCountAggregateInputType | true
    }

  export interface RewardDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Reward'], meta: { name: 'Reward' } }
    /**
     * Find zero or one Reward that matches the filter.
     * @param {RewardFindUniqueArgs} args - Arguments to find a Reward
     * @example
     * // Get one Reward
     * const reward = await prisma.reward.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RewardFindUniqueArgs>(args: SelectSubset<T, RewardFindUniqueArgs<ExtArgs>>): Prisma__RewardClient<$Result.GetResult<Prisma.$RewardPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Reward that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RewardFindUniqueOrThrowArgs} args - Arguments to find a Reward
     * @example
     * // Get one Reward
     * const reward = await prisma.reward.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RewardFindUniqueOrThrowArgs>(args: SelectSubset<T, RewardFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RewardClient<$Result.GetResult<Prisma.$RewardPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Reward that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardFindFirstArgs} args - Arguments to find a Reward
     * @example
     * // Get one Reward
     * const reward = await prisma.reward.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RewardFindFirstArgs>(args?: SelectSubset<T, RewardFindFirstArgs<ExtArgs>>): Prisma__RewardClient<$Result.GetResult<Prisma.$RewardPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Reward that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardFindFirstOrThrowArgs} args - Arguments to find a Reward
     * @example
     * // Get one Reward
     * const reward = await prisma.reward.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RewardFindFirstOrThrowArgs>(args?: SelectSubset<T, RewardFindFirstOrThrowArgs<ExtArgs>>): Prisma__RewardClient<$Result.GetResult<Prisma.$RewardPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Rewards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Rewards
     * const rewards = await prisma.reward.findMany()
     * 
     * // Get first 10 Rewards
     * const rewards = await prisma.reward.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rewardWithIdOnly = await prisma.reward.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RewardFindManyArgs>(args?: SelectSubset<T, RewardFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RewardPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Reward.
     * @param {RewardCreateArgs} args - Arguments to create a Reward.
     * @example
     * // Create one Reward
     * const Reward = await prisma.reward.create({
     *   data: {
     *     // ... data to create a Reward
     *   }
     * })
     * 
     */
    create<T extends RewardCreateArgs>(args: SelectSubset<T, RewardCreateArgs<ExtArgs>>): Prisma__RewardClient<$Result.GetResult<Prisma.$RewardPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Rewards.
     * @param {RewardCreateManyArgs} args - Arguments to create many Rewards.
     * @example
     * // Create many Rewards
     * const reward = await prisma.reward.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RewardCreateManyArgs>(args?: SelectSubset<T, RewardCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Rewards and returns the data saved in the database.
     * @param {RewardCreateManyAndReturnArgs} args - Arguments to create many Rewards.
     * @example
     * // Create many Rewards
     * const reward = await prisma.reward.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Rewards and only return the `id`
     * const rewardWithIdOnly = await prisma.reward.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RewardCreateManyAndReturnArgs>(args?: SelectSubset<T, RewardCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RewardPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Reward.
     * @param {RewardDeleteArgs} args - Arguments to delete one Reward.
     * @example
     * // Delete one Reward
     * const Reward = await prisma.reward.delete({
     *   where: {
     *     // ... filter to delete one Reward
     *   }
     * })
     * 
     */
    delete<T extends RewardDeleteArgs>(args: SelectSubset<T, RewardDeleteArgs<ExtArgs>>): Prisma__RewardClient<$Result.GetResult<Prisma.$RewardPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Reward.
     * @param {RewardUpdateArgs} args - Arguments to update one Reward.
     * @example
     * // Update one Reward
     * const reward = await prisma.reward.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RewardUpdateArgs>(args: SelectSubset<T, RewardUpdateArgs<ExtArgs>>): Prisma__RewardClient<$Result.GetResult<Prisma.$RewardPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Rewards.
     * @param {RewardDeleteManyArgs} args - Arguments to filter Rewards to delete.
     * @example
     * // Delete a few Rewards
     * const { count } = await prisma.reward.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RewardDeleteManyArgs>(args?: SelectSubset<T, RewardDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rewards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Rewards
     * const reward = await prisma.reward.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RewardUpdateManyArgs>(args: SelectSubset<T, RewardUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Reward.
     * @param {RewardUpsertArgs} args - Arguments to update or create a Reward.
     * @example
     * // Update or create a Reward
     * const reward = await prisma.reward.upsert({
     *   create: {
     *     // ... data to create a Reward
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Reward we want to update
     *   }
     * })
     */
    upsert<T extends RewardUpsertArgs>(args: SelectSubset<T, RewardUpsertArgs<ExtArgs>>): Prisma__RewardClient<$Result.GetResult<Prisma.$RewardPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Rewards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardCountArgs} args - Arguments to filter Rewards to count.
     * @example
     * // Count the number of Rewards
     * const count = await prisma.reward.count({
     *   where: {
     *     // ... the filter for the Rewards we want to count
     *   }
     * })
    **/
    count<T extends RewardCountArgs>(
      args?: Subset<T, RewardCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RewardCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Reward.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RewardAggregateArgs>(args: Subset<T, RewardAggregateArgs>): Prisma.PrismaPromise<GetRewardAggregateType<T>>

    /**
     * Group by Reward.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RewardGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RewardGroupByArgs['orderBy'] }
        : { orderBy?: RewardGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RewardGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRewardGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Reward model
   */
  readonly fields: RewardFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Reward.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RewardClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    merchant<T extends MerchantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MerchantDefaultArgs<ExtArgs>>): Prisma__MerchantClient<$Result.GetResult<Prisma.$MerchantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    posRewardItems<T extends Reward$posRewardItemsArgs<ExtArgs> = {}>(args?: Subset<T, Reward$posRewardItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$POSRewardItemPayload<ExtArgs>, T, "findMany"> | Null>
    redemptions<T extends Reward$redemptionsArgs<ExtArgs> = {}>(args?: Subset<T, Reward$redemptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RedemptionPayload<ExtArgs>, T, "findMany"> | Null>
    itemCounts<T extends Reward$itemCountsArgs<ExtArgs> = {}>(args?: Subset<T, Reward$itemCountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerItemCountPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Reward model
   */ 
  interface RewardFieldRefs {
    readonly id: FieldRef<"Reward", 'String'>
    readonly merchantId: FieldRef<"Reward", 'String'>
    readonly name: FieldRef<"Reward", 'String'>
    readonly description: FieldRef<"Reward", 'String'>
    readonly type: FieldRef<"Reward", 'RewardType'>
    readonly pointsCost: FieldRef<"Reward", 'Int'>
    readonly itemName: FieldRef<"Reward", 'String'>
    readonly itemCount: FieldRef<"Reward", 'Int'>
    readonly isActive: FieldRef<"Reward", 'Boolean'>
    readonly createdAt: FieldRef<"Reward", 'DateTime'>
    readonly updatedAt: FieldRef<"Reward", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Reward findUnique
   */
  export type RewardFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reward
     */
    select?: RewardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardInclude<ExtArgs> | null
    /**
     * Filter, which Reward to fetch.
     */
    where: RewardWhereUniqueInput
  }

  /**
   * Reward findUniqueOrThrow
   */
  export type RewardFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reward
     */
    select?: RewardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardInclude<ExtArgs> | null
    /**
     * Filter, which Reward to fetch.
     */
    where: RewardWhereUniqueInput
  }

  /**
   * Reward findFirst
   */
  export type RewardFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reward
     */
    select?: RewardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardInclude<ExtArgs> | null
    /**
     * Filter, which Reward to fetch.
     */
    where?: RewardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rewards to fetch.
     */
    orderBy?: RewardOrderByWithRelationInput | RewardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rewards.
     */
    cursor?: RewardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rewards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rewards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rewards.
     */
    distinct?: RewardScalarFieldEnum | RewardScalarFieldEnum[]
  }

  /**
   * Reward findFirstOrThrow
   */
  export type RewardFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reward
     */
    select?: RewardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardInclude<ExtArgs> | null
    /**
     * Filter, which Reward to fetch.
     */
    where?: RewardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rewards to fetch.
     */
    orderBy?: RewardOrderByWithRelationInput | RewardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rewards.
     */
    cursor?: RewardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rewards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rewards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rewards.
     */
    distinct?: RewardScalarFieldEnum | RewardScalarFieldEnum[]
  }

  /**
   * Reward findMany
   */
  export type RewardFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reward
     */
    select?: RewardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardInclude<ExtArgs> | null
    /**
     * Filter, which Rewards to fetch.
     */
    where?: RewardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rewards to fetch.
     */
    orderBy?: RewardOrderByWithRelationInput | RewardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Rewards.
     */
    cursor?: RewardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rewards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rewards.
     */
    skip?: number
    distinct?: RewardScalarFieldEnum | RewardScalarFieldEnum[]
  }

  /**
   * Reward create
   */
  export type RewardCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reward
     */
    select?: RewardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardInclude<ExtArgs> | null
    /**
     * The data needed to create a Reward.
     */
    data: XOR<RewardCreateInput, RewardUncheckedCreateInput>
  }

  /**
   * Reward createMany
   */
  export type RewardCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Rewards.
     */
    data: RewardCreateManyInput | RewardCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Reward createManyAndReturn
   */
  export type RewardCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reward
     */
    select?: RewardSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Rewards.
     */
    data: RewardCreateManyInput | RewardCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Reward update
   */
  export type RewardUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reward
     */
    select?: RewardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardInclude<ExtArgs> | null
    /**
     * The data needed to update a Reward.
     */
    data: XOR<RewardUpdateInput, RewardUncheckedUpdateInput>
    /**
     * Choose, which Reward to update.
     */
    where: RewardWhereUniqueInput
  }

  /**
   * Reward updateMany
   */
  export type RewardUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Rewards.
     */
    data: XOR<RewardUpdateManyMutationInput, RewardUncheckedUpdateManyInput>
    /**
     * Filter which Rewards to update
     */
    where?: RewardWhereInput
  }

  /**
   * Reward upsert
   */
  export type RewardUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reward
     */
    select?: RewardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardInclude<ExtArgs> | null
    /**
     * The filter to search for the Reward to update in case it exists.
     */
    where: RewardWhereUniqueInput
    /**
     * In case the Reward found by the `where` argument doesn't exist, create a new Reward with this data.
     */
    create: XOR<RewardCreateInput, RewardUncheckedCreateInput>
    /**
     * In case the Reward was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RewardUpdateInput, RewardUncheckedUpdateInput>
  }

  /**
   * Reward delete
   */
  export type RewardDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reward
     */
    select?: RewardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardInclude<ExtArgs> | null
    /**
     * Filter which Reward to delete.
     */
    where: RewardWhereUniqueInput
  }

  /**
   * Reward deleteMany
   */
  export type RewardDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Rewards to delete
     */
    where?: RewardWhereInput
  }

  /**
   * Reward.posRewardItems
   */
  export type Reward$posRewardItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POSRewardItem
     */
    select?: POSRewardItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSRewardItemInclude<ExtArgs> | null
    where?: POSRewardItemWhereInput
    orderBy?: POSRewardItemOrderByWithRelationInput | POSRewardItemOrderByWithRelationInput[]
    cursor?: POSRewardItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: POSRewardItemScalarFieldEnum | POSRewardItemScalarFieldEnum[]
  }

  /**
   * Reward.redemptions
   */
  export type Reward$redemptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redemption
     */
    select?: RedemptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RedemptionInclude<ExtArgs> | null
    where?: RedemptionWhereInput
    orderBy?: RedemptionOrderByWithRelationInput | RedemptionOrderByWithRelationInput[]
    cursor?: RedemptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RedemptionScalarFieldEnum | RedemptionScalarFieldEnum[]
  }

  /**
   * Reward.itemCounts
   */
  export type Reward$itemCountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerItemCount
     */
    select?: CustomerItemCountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerItemCountInclude<ExtArgs> | null
    where?: CustomerItemCountWhereInput
    orderBy?: CustomerItemCountOrderByWithRelationInput | CustomerItemCountOrderByWithRelationInput[]
    cursor?: CustomerItemCountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerItemCountScalarFieldEnum | CustomerItemCountScalarFieldEnum[]
  }

  /**
   * Reward without action
   */
  export type RewardDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reward
     */
    select?: RewardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardInclude<ExtArgs> | null
  }


  /**
   * Model POSRewardItem
   */

  export type AggregatePOSRewardItem = {
    _count: POSRewardItemCountAggregateOutputType | null
    _min: POSRewardItemMinAggregateOutputType | null
    _max: POSRewardItemMaxAggregateOutputType | null
  }

  export type POSRewardItemMinAggregateOutputType = {
    id: string | null
    rewardId: string | null
    posProvider: $Enums.POSProvider | null
    posItemId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type POSRewardItemMaxAggregateOutputType = {
    id: string | null
    rewardId: string | null
    posProvider: $Enums.POSProvider | null
    posItemId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type POSRewardItemCountAggregateOutputType = {
    id: number
    rewardId: number
    posProvider: number
    posItemId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type POSRewardItemMinAggregateInputType = {
    id?: true
    rewardId?: true
    posProvider?: true
    posItemId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type POSRewardItemMaxAggregateInputType = {
    id?: true
    rewardId?: true
    posProvider?: true
    posItemId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type POSRewardItemCountAggregateInputType = {
    id?: true
    rewardId?: true
    posProvider?: true
    posItemId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type POSRewardItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which POSRewardItem to aggregate.
     */
    where?: POSRewardItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of POSRewardItems to fetch.
     */
    orderBy?: POSRewardItemOrderByWithRelationInput | POSRewardItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: POSRewardItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` POSRewardItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` POSRewardItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned POSRewardItems
    **/
    _count?: true | POSRewardItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: POSRewardItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: POSRewardItemMaxAggregateInputType
  }

  export type GetPOSRewardItemAggregateType<T extends POSRewardItemAggregateArgs> = {
        [P in keyof T & keyof AggregatePOSRewardItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePOSRewardItem[P]>
      : GetScalarType<T[P], AggregatePOSRewardItem[P]>
  }




  export type POSRewardItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: POSRewardItemWhereInput
    orderBy?: POSRewardItemOrderByWithAggregationInput | POSRewardItemOrderByWithAggregationInput[]
    by: POSRewardItemScalarFieldEnum[] | POSRewardItemScalarFieldEnum
    having?: POSRewardItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: POSRewardItemCountAggregateInputType | true
    _min?: POSRewardItemMinAggregateInputType
    _max?: POSRewardItemMaxAggregateInputType
  }

  export type POSRewardItemGroupByOutputType = {
    id: string
    rewardId: string
    posProvider: $Enums.POSProvider
    posItemId: string
    createdAt: Date
    updatedAt: Date
    _count: POSRewardItemCountAggregateOutputType | null
    _min: POSRewardItemMinAggregateOutputType | null
    _max: POSRewardItemMaxAggregateOutputType | null
  }

  type GetPOSRewardItemGroupByPayload<T extends POSRewardItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<POSRewardItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof POSRewardItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], POSRewardItemGroupByOutputType[P]>
            : GetScalarType<T[P], POSRewardItemGroupByOutputType[P]>
        }
      >
    >


  export type POSRewardItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rewardId?: boolean
    posProvider?: boolean
    posItemId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    reward?: boolean | RewardDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pOSRewardItem"]>

  export type POSRewardItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rewardId?: boolean
    posProvider?: boolean
    posItemId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    reward?: boolean | RewardDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pOSRewardItem"]>

  export type POSRewardItemSelectScalar = {
    id?: boolean
    rewardId?: boolean
    posProvider?: boolean
    posItemId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type POSRewardItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reward?: boolean | RewardDefaultArgs<ExtArgs>
  }
  export type POSRewardItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reward?: boolean | RewardDefaultArgs<ExtArgs>
  }

  export type $POSRewardItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "POSRewardItem"
    objects: {
      reward: Prisma.$RewardPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      rewardId: string
      posProvider: $Enums.POSProvider
      posItemId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["pOSRewardItem"]>
    composites: {}
  }

  type POSRewardItemGetPayload<S extends boolean | null | undefined | POSRewardItemDefaultArgs> = $Result.GetResult<Prisma.$POSRewardItemPayload, S>

  type POSRewardItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<POSRewardItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: POSRewardItemCountAggregateInputType | true
    }

  export interface POSRewardItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['POSRewardItem'], meta: { name: 'POSRewardItem' } }
    /**
     * Find zero or one POSRewardItem that matches the filter.
     * @param {POSRewardItemFindUniqueArgs} args - Arguments to find a POSRewardItem
     * @example
     * // Get one POSRewardItem
     * const pOSRewardItem = await prisma.pOSRewardItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends POSRewardItemFindUniqueArgs>(args: SelectSubset<T, POSRewardItemFindUniqueArgs<ExtArgs>>): Prisma__POSRewardItemClient<$Result.GetResult<Prisma.$POSRewardItemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one POSRewardItem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {POSRewardItemFindUniqueOrThrowArgs} args - Arguments to find a POSRewardItem
     * @example
     * // Get one POSRewardItem
     * const pOSRewardItem = await prisma.pOSRewardItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends POSRewardItemFindUniqueOrThrowArgs>(args: SelectSubset<T, POSRewardItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__POSRewardItemClient<$Result.GetResult<Prisma.$POSRewardItemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first POSRewardItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {POSRewardItemFindFirstArgs} args - Arguments to find a POSRewardItem
     * @example
     * // Get one POSRewardItem
     * const pOSRewardItem = await prisma.pOSRewardItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends POSRewardItemFindFirstArgs>(args?: SelectSubset<T, POSRewardItemFindFirstArgs<ExtArgs>>): Prisma__POSRewardItemClient<$Result.GetResult<Prisma.$POSRewardItemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first POSRewardItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {POSRewardItemFindFirstOrThrowArgs} args - Arguments to find a POSRewardItem
     * @example
     * // Get one POSRewardItem
     * const pOSRewardItem = await prisma.pOSRewardItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends POSRewardItemFindFirstOrThrowArgs>(args?: SelectSubset<T, POSRewardItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__POSRewardItemClient<$Result.GetResult<Prisma.$POSRewardItemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more POSRewardItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {POSRewardItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all POSRewardItems
     * const pOSRewardItems = await prisma.pOSRewardItem.findMany()
     * 
     * // Get first 10 POSRewardItems
     * const pOSRewardItems = await prisma.pOSRewardItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pOSRewardItemWithIdOnly = await prisma.pOSRewardItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends POSRewardItemFindManyArgs>(args?: SelectSubset<T, POSRewardItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$POSRewardItemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a POSRewardItem.
     * @param {POSRewardItemCreateArgs} args - Arguments to create a POSRewardItem.
     * @example
     * // Create one POSRewardItem
     * const POSRewardItem = await prisma.pOSRewardItem.create({
     *   data: {
     *     // ... data to create a POSRewardItem
     *   }
     * })
     * 
     */
    create<T extends POSRewardItemCreateArgs>(args: SelectSubset<T, POSRewardItemCreateArgs<ExtArgs>>): Prisma__POSRewardItemClient<$Result.GetResult<Prisma.$POSRewardItemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many POSRewardItems.
     * @param {POSRewardItemCreateManyArgs} args - Arguments to create many POSRewardItems.
     * @example
     * // Create many POSRewardItems
     * const pOSRewardItem = await prisma.pOSRewardItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends POSRewardItemCreateManyArgs>(args?: SelectSubset<T, POSRewardItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many POSRewardItems and returns the data saved in the database.
     * @param {POSRewardItemCreateManyAndReturnArgs} args - Arguments to create many POSRewardItems.
     * @example
     * // Create many POSRewardItems
     * const pOSRewardItem = await prisma.pOSRewardItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many POSRewardItems and only return the `id`
     * const pOSRewardItemWithIdOnly = await prisma.pOSRewardItem.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends POSRewardItemCreateManyAndReturnArgs>(args?: SelectSubset<T, POSRewardItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$POSRewardItemPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a POSRewardItem.
     * @param {POSRewardItemDeleteArgs} args - Arguments to delete one POSRewardItem.
     * @example
     * // Delete one POSRewardItem
     * const POSRewardItem = await prisma.pOSRewardItem.delete({
     *   where: {
     *     // ... filter to delete one POSRewardItem
     *   }
     * })
     * 
     */
    delete<T extends POSRewardItemDeleteArgs>(args: SelectSubset<T, POSRewardItemDeleteArgs<ExtArgs>>): Prisma__POSRewardItemClient<$Result.GetResult<Prisma.$POSRewardItemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one POSRewardItem.
     * @param {POSRewardItemUpdateArgs} args - Arguments to update one POSRewardItem.
     * @example
     * // Update one POSRewardItem
     * const pOSRewardItem = await prisma.pOSRewardItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends POSRewardItemUpdateArgs>(args: SelectSubset<T, POSRewardItemUpdateArgs<ExtArgs>>): Prisma__POSRewardItemClient<$Result.GetResult<Prisma.$POSRewardItemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more POSRewardItems.
     * @param {POSRewardItemDeleteManyArgs} args - Arguments to filter POSRewardItems to delete.
     * @example
     * // Delete a few POSRewardItems
     * const { count } = await prisma.pOSRewardItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends POSRewardItemDeleteManyArgs>(args?: SelectSubset<T, POSRewardItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more POSRewardItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {POSRewardItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many POSRewardItems
     * const pOSRewardItem = await prisma.pOSRewardItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends POSRewardItemUpdateManyArgs>(args: SelectSubset<T, POSRewardItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one POSRewardItem.
     * @param {POSRewardItemUpsertArgs} args - Arguments to update or create a POSRewardItem.
     * @example
     * // Update or create a POSRewardItem
     * const pOSRewardItem = await prisma.pOSRewardItem.upsert({
     *   create: {
     *     // ... data to create a POSRewardItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the POSRewardItem we want to update
     *   }
     * })
     */
    upsert<T extends POSRewardItemUpsertArgs>(args: SelectSubset<T, POSRewardItemUpsertArgs<ExtArgs>>): Prisma__POSRewardItemClient<$Result.GetResult<Prisma.$POSRewardItemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of POSRewardItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {POSRewardItemCountArgs} args - Arguments to filter POSRewardItems to count.
     * @example
     * // Count the number of POSRewardItems
     * const count = await prisma.pOSRewardItem.count({
     *   where: {
     *     // ... the filter for the POSRewardItems we want to count
     *   }
     * })
    **/
    count<T extends POSRewardItemCountArgs>(
      args?: Subset<T, POSRewardItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], POSRewardItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a POSRewardItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {POSRewardItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends POSRewardItemAggregateArgs>(args: Subset<T, POSRewardItemAggregateArgs>): Prisma.PrismaPromise<GetPOSRewardItemAggregateType<T>>

    /**
     * Group by POSRewardItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {POSRewardItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends POSRewardItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: POSRewardItemGroupByArgs['orderBy'] }
        : { orderBy?: POSRewardItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, POSRewardItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPOSRewardItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the POSRewardItem model
   */
  readonly fields: POSRewardItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for POSRewardItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__POSRewardItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    reward<T extends RewardDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RewardDefaultArgs<ExtArgs>>): Prisma__RewardClient<$Result.GetResult<Prisma.$RewardPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the POSRewardItem model
   */ 
  interface POSRewardItemFieldRefs {
    readonly id: FieldRef<"POSRewardItem", 'String'>
    readonly rewardId: FieldRef<"POSRewardItem", 'String'>
    readonly posProvider: FieldRef<"POSRewardItem", 'POSProvider'>
    readonly posItemId: FieldRef<"POSRewardItem", 'String'>
    readonly createdAt: FieldRef<"POSRewardItem", 'DateTime'>
    readonly updatedAt: FieldRef<"POSRewardItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * POSRewardItem findUnique
   */
  export type POSRewardItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POSRewardItem
     */
    select?: POSRewardItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSRewardItemInclude<ExtArgs> | null
    /**
     * Filter, which POSRewardItem to fetch.
     */
    where: POSRewardItemWhereUniqueInput
  }

  /**
   * POSRewardItem findUniqueOrThrow
   */
  export type POSRewardItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POSRewardItem
     */
    select?: POSRewardItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSRewardItemInclude<ExtArgs> | null
    /**
     * Filter, which POSRewardItem to fetch.
     */
    where: POSRewardItemWhereUniqueInput
  }

  /**
   * POSRewardItem findFirst
   */
  export type POSRewardItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POSRewardItem
     */
    select?: POSRewardItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSRewardItemInclude<ExtArgs> | null
    /**
     * Filter, which POSRewardItem to fetch.
     */
    where?: POSRewardItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of POSRewardItems to fetch.
     */
    orderBy?: POSRewardItemOrderByWithRelationInput | POSRewardItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for POSRewardItems.
     */
    cursor?: POSRewardItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` POSRewardItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` POSRewardItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of POSRewardItems.
     */
    distinct?: POSRewardItemScalarFieldEnum | POSRewardItemScalarFieldEnum[]
  }

  /**
   * POSRewardItem findFirstOrThrow
   */
  export type POSRewardItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POSRewardItem
     */
    select?: POSRewardItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSRewardItemInclude<ExtArgs> | null
    /**
     * Filter, which POSRewardItem to fetch.
     */
    where?: POSRewardItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of POSRewardItems to fetch.
     */
    orderBy?: POSRewardItemOrderByWithRelationInput | POSRewardItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for POSRewardItems.
     */
    cursor?: POSRewardItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` POSRewardItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` POSRewardItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of POSRewardItems.
     */
    distinct?: POSRewardItemScalarFieldEnum | POSRewardItemScalarFieldEnum[]
  }

  /**
   * POSRewardItem findMany
   */
  export type POSRewardItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POSRewardItem
     */
    select?: POSRewardItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSRewardItemInclude<ExtArgs> | null
    /**
     * Filter, which POSRewardItems to fetch.
     */
    where?: POSRewardItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of POSRewardItems to fetch.
     */
    orderBy?: POSRewardItemOrderByWithRelationInput | POSRewardItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing POSRewardItems.
     */
    cursor?: POSRewardItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` POSRewardItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` POSRewardItems.
     */
    skip?: number
    distinct?: POSRewardItemScalarFieldEnum | POSRewardItemScalarFieldEnum[]
  }

  /**
   * POSRewardItem create
   */
  export type POSRewardItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POSRewardItem
     */
    select?: POSRewardItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSRewardItemInclude<ExtArgs> | null
    /**
     * The data needed to create a POSRewardItem.
     */
    data: XOR<POSRewardItemCreateInput, POSRewardItemUncheckedCreateInput>
  }

  /**
   * POSRewardItem createMany
   */
  export type POSRewardItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many POSRewardItems.
     */
    data: POSRewardItemCreateManyInput | POSRewardItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * POSRewardItem createManyAndReturn
   */
  export type POSRewardItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POSRewardItem
     */
    select?: POSRewardItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many POSRewardItems.
     */
    data: POSRewardItemCreateManyInput | POSRewardItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSRewardItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * POSRewardItem update
   */
  export type POSRewardItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POSRewardItem
     */
    select?: POSRewardItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSRewardItemInclude<ExtArgs> | null
    /**
     * The data needed to update a POSRewardItem.
     */
    data: XOR<POSRewardItemUpdateInput, POSRewardItemUncheckedUpdateInput>
    /**
     * Choose, which POSRewardItem to update.
     */
    where: POSRewardItemWhereUniqueInput
  }

  /**
   * POSRewardItem updateMany
   */
  export type POSRewardItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update POSRewardItems.
     */
    data: XOR<POSRewardItemUpdateManyMutationInput, POSRewardItemUncheckedUpdateManyInput>
    /**
     * Filter which POSRewardItems to update
     */
    where?: POSRewardItemWhereInput
  }

  /**
   * POSRewardItem upsert
   */
  export type POSRewardItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POSRewardItem
     */
    select?: POSRewardItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSRewardItemInclude<ExtArgs> | null
    /**
     * The filter to search for the POSRewardItem to update in case it exists.
     */
    where: POSRewardItemWhereUniqueInput
    /**
     * In case the POSRewardItem found by the `where` argument doesn't exist, create a new POSRewardItem with this data.
     */
    create: XOR<POSRewardItemCreateInput, POSRewardItemUncheckedCreateInput>
    /**
     * In case the POSRewardItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<POSRewardItemUpdateInput, POSRewardItemUncheckedUpdateInput>
  }

  /**
   * POSRewardItem delete
   */
  export type POSRewardItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POSRewardItem
     */
    select?: POSRewardItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSRewardItemInclude<ExtArgs> | null
    /**
     * Filter which POSRewardItem to delete.
     */
    where: POSRewardItemWhereUniqueInput
  }

  /**
   * POSRewardItem deleteMany
   */
  export type POSRewardItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which POSRewardItems to delete
     */
    where?: POSRewardItemWhereInput
  }

  /**
   * POSRewardItem without action
   */
  export type POSRewardItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POSRewardItem
     */
    select?: POSRewardItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSRewardItemInclude<ExtArgs> | null
  }


  /**
   * Model Redemption
   */

  export type AggregateRedemption = {
    _count: RedemptionCountAggregateOutputType | null
    _avg: RedemptionAvgAggregateOutputType | null
    _sum: RedemptionSumAggregateOutputType | null
    _min: RedemptionMinAggregateOutputType | null
    _max: RedemptionMaxAggregateOutputType | null
  }

  export type RedemptionAvgAggregateOutputType = {
    pointsDeducted: number | null
  }

  export type RedemptionSumAggregateOutputType = {
    pointsDeducted: number | null
  }

  export type RedemptionMinAggregateOutputType = {
    id: string | null
    customerId: string | null
    merchantId: string | null
    rewardId: string | null
    qrToken: string | null
    pinCode: string | null
    status: $Enums.RedemptionStatus | null
    pointsDeducted: number | null
    redeemedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RedemptionMaxAggregateOutputType = {
    id: string | null
    customerId: string | null
    merchantId: string | null
    rewardId: string | null
    qrToken: string | null
    pinCode: string | null
    status: $Enums.RedemptionStatus | null
    pointsDeducted: number | null
    redeemedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RedemptionCountAggregateOutputType = {
    id: number
    customerId: number
    merchantId: number
    rewardId: number
    qrToken: number
    pinCode: number
    status: number
    pointsDeducted: number
    redeemedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RedemptionAvgAggregateInputType = {
    pointsDeducted?: true
  }

  export type RedemptionSumAggregateInputType = {
    pointsDeducted?: true
  }

  export type RedemptionMinAggregateInputType = {
    id?: true
    customerId?: true
    merchantId?: true
    rewardId?: true
    qrToken?: true
    pinCode?: true
    status?: true
    pointsDeducted?: true
    redeemedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RedemptionMaxAggregateInputType = {
    id?: true
    customerId?: true
    merchantId?: true
    rewardId?: true
    qrToken?: true
    pinCode?: true
    status?: true
    pointsDeducted?: true
    redeemedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RedemptionCountAggregateInputType = {
    id?: true
    customerId?: true
    merchantId?: true
    rewardId?: true
    qrToken?: true
    pinCode?: true
    status?: true
    pointsDeducted?: true
    redeemedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RedemptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Redemption to aggregate.
     */
    where?: RedemptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Redemptions to fetch.
     */
    orderBy?: RedemptionOrderByWithRelationInput | RedemptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RedemptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Redemptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Redemptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Redemptions
    **/
    _count?: true | RedemptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RedemptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RedemptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RedemptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RedemptionMaxAggregateInputType
  }

  export type GetRedemptionAggregateType<T extends RedemptionAggregateArgs> = {
        [P in keyof T & keyof AggregateRedemption]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRedemption[P]>
      : GetScalarType<T[P], AggregateRedemption[P]>
  }




  export type RedemptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RedemptionWhereInput
    orderBy?: RedemptionOrderByWithAggregationInput | RedemptionOrderByWithAggregationInput[]
    by: RedemptionScalarFieldEnum[] | RedemptionScalarFieldEnum
    having?: RedemptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RedemptionCountAggregateInputType | true
    _avg?: RedemptionAvgAggregateInputType
    _sum?: RedemptionSumAggregateInputType
    _min?: RedemptionMinAggregateInputType
    _max?: RedemptionMaxAggregateInputType
  }

  export type RedemptionGroupByOutputType = {
    id: string
    customerId: string
    merchantId: string
    rewardId: string
    qrToken: string
    pinCode: string
    status: $Enums.RedemptionStatus
    pointsDeducted: number | null
    redeemedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: RedemptionCountAggregateOutputType | null
    _avg: RedemptionAvgAggregateOutputType | null
    _sum: RedemptionSumAggregateOutputType | null
    _min: RedemptionMinAggregateOutputType | null
    _max: RedemptionMaxAggregateOutputType | null
  }

  type GetRedemptionGroupByPayload<T extends RedemptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RedemptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RedemptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RedemptionGroupByOutputType[P]>
            : GetScalarType<T[P], RedemptionGroupByOutputType[P]>
        }
      >
    >


  export type RedemptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    merchantId?: boolean
    rewardId?: boolean
    qrToken?: boolean
    pinCode?: boolean
    status?: boolean
    pointsDeducted?: boolean
    redeemedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    merchant?: boolean | MerchantDefaultArgs<ExtArgs>
    reward?: boolean | RewardDefaultArgs<ExtArgs>
    ledgerEntry?: boolean | Redemption$ledgerEntryArgs<ExtArgs>
  }, ExtArgs["result"]["redemption"]>

  export type RedemptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    merchantId?: boolean
    rewardId?: boolean
    qrToken?: boolean
    pinCode?: boolean
    status?: boolean
    pointsDeducted?: boolean
    redeemedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    merchant?: boolean | MerchantDefaultArgs<ExtArgs>
    reward?: boolean | RewardDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["redemption"]>

  export type RedemptionSelectScalar = {
    id?: boolean
    customerId?: boolean
    merchantId?: boolean
    rewardId?: boolean
    qrToken?: boolean
    pinCode?: boolean
    status?: boolean
    pointsDeducted?: boolean
    redeemedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RedemptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    merchant?: boolean | MerchantDefaultArgs<ExtArgs>
    reward?: boolean | RewardDefaultArgs<ExtArgs>
    ledgerEntry?: boolean | Redemption$ledgerEntryArgs<ExtArgs>
  }
  export type RedemptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    merchant?: boolean | MerchantDefaultArgs<ExtArgs>
    reward?: boolean | RewardDefaultArgs<ExtArgs>
  }

  export type $RedemptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Redemption"
    objects: {
      customer: Prisma.$CustomerPayload<ExtArgs>
      merchant: Prisma.$MerchantPayload<ExtArgs>
      reward: Prisma.$RewardPayload<ExtArgs>
      ledgerEntry: Prisma.$LedgerEntryPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      customerId: string
      merchantId: string
      rewardId: string
      qrToken: string
      pinCode: string
      status: $Enums.RedemptionStatus
      pointsDeducted: number | null
      redeemedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["redemption"]>
    composites: {}
  }

  type RedemptionGetPayload<S extends boolean | null | undefined | RedemptionDefaultArgs> = $Result.GetResult<Prisma.$RedemptionPayload, S>

  type RedemptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RedemptionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RedemptionCountAggregateInputType | true
    }

  export interface RedemptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Redemption'], meta: { name: 'Redemption' } }
    /**
     * Find zero or one Redemption that matches the filter.
     * @param {RedemptionFindUniqueArgs} args - Arguments to find a Redemption
     * @example
     * // Get one Redemption
     * const redemption = await prisma.redemption.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RedemptionFindUniqueArgs>(args: SelectSubset<T, RedemptionFindUniqueArgs<ExtArgs>>): Prisma__RedemptionClient<$Result.GetResult<Prisma.$RedemptionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Redemption that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RedemptionFindUniqueOrThrowArgs} args - Arguments to find a Redemption
     * @example
     * // Get one Redemption
     * const redemption = await prisma.redemption.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RedemptionFindUniqueOrThrowArgs>(args: SelectSubset<T, RedemptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RedemptionClient<$Result.GetResult<Prisma.$RedemptionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Redemption that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RedemptionFindFirstArgs} args - Arguments to find a Redemption
     * @example
     * // Get one Redemption
     * const redemption = await prisma.redemption.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RedemptionFindFirstArgs>(args?: SelectSubset<T, RedemptionFindFirstArgs<ExtArgs>>): Prisma__RedemptionClient<$Result.GetResult<Prisma.$RedemptionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Redemption that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RedemptionFindFirstOrThrowArgs} args - Arguments to find a Redemption
     * @example
     * // Get one Redemption
     * const redemption = await prisma.redemption.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RedemptionFindFirstOrThrowArgs>(args?: SelectSubset<T, RedemptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__RedemptionClient<$Result.GetResult<Prisma.$RedemptionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Redemptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RedemptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Redemptions
     * const redemptions = await prisma.redemption.findMany()
     * 
     * // Get first 10 Redemptions
     * const redemptions = await prisma.redemption.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const redemptionWithIdOnly = await prisma.redemption.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RedemptionFindManyArgs>(args?: SelectSubset<T, RedemptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RedemptionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Redemption.
     * @param {RedemptionCreateArgs} args - Arguments to create a Redemption.
     * @example
     * // Create one Redemption
     * const Redemption = await prisma.redemption.create({
     *   data: {
     *     // ... data to create a Redemption
     *   }
     * })
     * 
     */
    create<T extends RedemptionCreateArgs>(args: SelectSubset<T, RedemptionCreateArgs<ExtArgs>>): Prisma__RedemptionClient<$Result.GetResult<Prisma.$RedemptionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Redemptions.
     * @param {RedemptionCreateManyArgs} args - Arguments to create many Redemptions.
     * @example
     * // Create many Redemptions
     * const redemption = await prisma.redemption.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RedemptionCreateManyArgs>(args?: SelectSubset<T, RedemptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Redemptions and returns the data saved in the database.
     * @param {RedemptionCreateManyAndReturnArgs} args - Arguments to create many Redemptions.
     * @example
     * // Create many Redemptions
     * const redemption = await prisma.redemption.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Redemptions and only return the `id`
     * const redemptionWithIdOnly = await prisma.redemption.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RedemptionCreateManyAndReturnArgs>(args?: SelectSubset<T, RedemptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RedemptionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Redemption.
     * @param {RedemptionDeleteArgs} args - Arguments to delete one Redemption.
     * @example
     * // Delete one Redemption
     * const Redemption = await prisma.redemption.delete({
     *   where: {
     *     // ... filter to delete one Redemption
     *   }
     * })
     * 
     */
    delete<T extends RedemptionDeleteArgs>(args: SelectSubset<T, RedemptionDeleteArgs<ExtArgs>>): Prisma__RedemptionClient<$Result.GetResult<Prisma.$RedemptionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Redemption.
     * @param {RedemptionUpdateArgs} args - Arguments to update one Redemption.
     * @example
     * // Update one Redemption
     * const redemption = await prisma.redemption.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RedemptionUpdateArgs>(args: SelectSubset<T, RedemptionUpdateArgs<ExtArgs>>): Prisma__RedemptionClient<$Result.GetResult<Prisma.$RedemptionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Redemptions.
     * @param {RedemptionDeleteManyArgs} args - Arguments to filter Redemptions to delete.
     * @example
     * // Delete a few Redemptions
     * const { count } = await prisma.redemption.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RedemptionDeleteManyArgs>(args?: SelectSubset<T, RedemptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Redemptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RedemptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Redemptions
     * const redemption = await prisma.redemption.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RedemptionUpdateManyArgs>(args: SelectSubset<T, RedemptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Redemption.
     * @param {RedemptionUpsertArgs} args - Arguments to update or create a Redemption.
     * @example
     * // Update or create a Redemption
     * const redemption = await prisma.redemption.upsert({
     *   create: {
     *     // ... data to create a Redemption
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Redemption we want to update
     *   }
     * })
     */
    upsert<T extends RedemptionUpsertArgs>(args: SelectSubset<T, RedemptionUpsertArgs<ExtArgs>>): Prisma__RedemptionClient<$Result.GetResult<Prisma.$RedemptionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Redemptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RedemptionCountArgs} args - Arguments to filter Redemptions to count.
     * @example
     * // Count the number of Redemptions
     * const count = await prisma.redemption.count({
     *   where: {
     *     // ... the filter for the Redemptions we want to count
     *   }
     * })
    **/
    count<T extends RedemptionCountArgs>(
      args?: Subset<T, RedemptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RedemptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Redemption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RedemptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RedemptionAggregateArgs>(args: Subset<T, RedemptionAggregateArgs>): Prisma.PrismaPromise<GetRedemptionAggregateType<T>>

    /**
     * Group by Redemption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RedemptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RedemptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RedemptionGroupByArgs['orderBy'] }
        : { orderBy?: RedemptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RedemptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRedemptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Redemption model
   */
  readonly fields: RedemptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Redemption.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RedemptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    merchant<T extends MerchantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MerchantDefaultArgs<ExtArgs>>): Prisma__MerchantClient<$Result.GetResult<Prisma.$MerchantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    reward<T extends RewardDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RewardDefaultArgs<ExtArgs>>): Prisma__RewardClient<$Result.GetResult<Prisma.$RewardPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    ledgerEntry<T extends Redemption$ledgerEntryArgs<ExtArgs> = {}>(args?: Subset<T, Redemption$ledgerEntryArgs<ExtArgs>>): Prisma__LedgerEntryClient<$Result.GetResult<Prisma.$LedgerEntryPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Redemption model
   */ 
  interface RedemptionFieldRefs {
    readonly id: FieldRef<"Redemption", 'String'>
    readonly customerId: FieldRef<"Redemption", 'String'>
    readonly merchantId: FieldRef<"Redemption", 'String'>
    readonly rewardId: FieldRef<"Redemption", 'String'>
    readonly qrToken: FieldRef<"Redemption", 'String'>
    readonly pinCode: FieldRef<"Redemption", 'String'>
    readonly status: FieldRef<"Redemption", 'RedemptionStatus'>
    readonly pointsDeducted: FieldRef<"Redemption", 'Int'>
    readonly redeemedAt: FieldRef<"Redemption", 'DateTime'>
    readonly createdAt: FieldRef<"Redemption", 'DateTime'>
    readonly updatedAt: FieldRef<"Redemption", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Redemption findUnique
   */
  export type RedemptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redemption
     */
    select?: RedemptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RedemptionInclude<ExtArgs> | null
    /**
     * Filter, which Redemption to fetch.
     */
    where: RedemptionWhereUniqueInput
  }

  /**
   * Redemption findUniqueOrThrow
   */
  export type RedemptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redemption
     */
    select?: RedemptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RedemptionInclude<ExtArgs> | null
    /**
     * Filter, which Redemption to fetch.
     */
    where: RedemptionWhereUniqueInput
  }

  /**
   * Redemption findFirst
   */
  export type RedemptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redemption
     */
    select?: RedemptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RedemptionInclude<ExtArgs> | null
    /**
     * Filter, which Redemption to fetch.
     */
    where?: RedemptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Redemptions to fetch.
     */
    orderBy?: RedemptionOrderByWithRelationInput | RedemptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Redemptions.
     */
    cursor?: RedemptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Redemptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Redemptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Redemptions.
     */
    distinct?: RedemptionScalarFieldEnum | RedemptionScalarFieldEnum[]
  }

  /**
   * Redemption findFirstOrThrow
   */
  export type RedemptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redemption
     */
    select?: RedemptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RedemptionInclude<ExtArgs> | null
    /**
     * Filter, which Redemption to fetch.
     */
    where?: RedemptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Redemptions to fetch.
     */
    orderBy?: RedemptionOrderByWithRelationInput | RedemptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Redemptions.
     */
    cursor?: RedemptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Redemptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Redemptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Redemptions.
     */
    distinct?: RedemptionScalarFieldEnum | RedemptionScalarFieldEnum[]
  }

  /**
   * Redemption findMany
   */
  export type RedemptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redemption
     */
    select?: RedemptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RedemptionInclude<ExtArgs> | null
    /**
     * Filter, which Redemptions to fetch.
     */
    where?: RedemptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Redemptions to fetch.
     */
    orderBy?: RedemptionOrderByWithRelationInput | RedemptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Redemptions.
     */
    cursor?: RedemptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Redemptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Redemptions.
     */
    skip?: number
    distinct?: RedemptionScalarFieldEnum | RedemptionScalarFieldEnum[]
  }

  /**
   * Redemption create
   */
  export type RedemptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redemption
     */
    select?: RedemptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RedemptionInclude<ExtArgs> | null
    /**
     * The data needed to create a Redemption.
     */
    data: XOR<RedemptionCreateInput, RedemptionUncheckedCreateInput>
  }

  /**
   * Redemption createMany
   */
  export type RedemptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Redemptions.
     */
    data: RedemptionCreateManyInput | RedemptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Redemption createManyAndReturn
   */
  export type RedemptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redemption
     */
    select?: RedemptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Redemptions.
     */
    data: RedemptionCreateManyInput | RedemptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RedemptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Redemption update
   */
  export type RedemptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redemption
     */
    select?: RedemptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RedemptionInclude<ExtArgs> | null
    /**
     * The data needed to update a Redemption.
     */
    data: XOR<RedemptionUpdateInput, RedemptionUncheckedUpdateInput>
    /**
     * Choose, which Redemption to update.
     */
    where: RedemptionWhereUniqueInput
  }

  /**
   * Redemption updateMany
   */
  export type RedemptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Redemptions.
     */
    data: XOR<RedemptionUpdateManyMutationInput, RedemptionUncheckedUpdateManyInput>
    /**
     * Filter which Redemptions to update
     */
    where?: RedemptionWhereInput
  }

  /**
   * Redemption upsert
   */
  export type RedemptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redemption
     */
    select?: RedemptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RedemptionInclude<ExtArgs> | null
    /**
     * The filter to search for the Redemption to update in case it exists.
     */
    where: RedemptionWhereUniqueInput
    /**
     * In case the Redemption found by the `where` argument doesn't exist, create a new Redemption with this data.
     */
    create: XOR<RedemptionCreateInput, RedemptionUncheckedCreateInput>
    /**
     * In case the Redemption was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RedemptionUpdateInput, RedemptionUncheckedUpdateInput>
  }

  /**
   * Redemption delete
   */
  export type RedemptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redemption
     */
    select?: RedemptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RedemptionInclude<ExtArgs> | null
    /**
     * Filter which Redemption to delete.
     */
    where: RedemptionWhereUniqueInput
  }

  /**
   * Redemption deleteMany
   */
  export type RedemptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Redemptions to delete
     */
    where?: RedemptionWhereInput
  }

  /**
   * Redemption.ledgerEntry
   */
  export type Redemption$ledgerEntryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerEntry
     */
    select?: LedgerEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerEntryInclude<ExtArgs> | null
    where?: LedgerEntryWhereInput
  }

  /**
   * Redemption without action
   */
  export type RedemptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redemption
     */
    select?: RedemptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RedemptionInclude<ExtArgs> | null
  }


  /**
   * Model CustomerItemCount
   */

  export type AggregateCustomerItemCount = {
    _count: CustomerItemCountCountAggregateOutputType | null
    _avg: CustomerItemCountAvgAggregateOutputType | null
    _sum: CustomerItemCountSumAggregateOutputType | null
    _min: CustomerItemCountMinAggregateOutputType | null
    _max: CustomerItemCountMaxAggregateOutputType | null
  }

  export type CustomerItemCountAvgAggregateOutputType = {
    count: number | null
  }

  export type CustomerItemCountSumAggregateOutputType = {
    count: number | null
  }

  export type CustomerItemCountMinAggregateOutputType = {
    id: string | null
    customerId: string | null
    merchantId: string | null
    rewardId: string | null
    itemName: string | null
    count: number | null
    updatedAt: Date | null
  }

  export type CustomerItemCountMaxAggregateOutputType = {
    id: string | null
    customerId: string | null
    merchantId: string | null
    rewardId: string | null
    itemName: string | null
    count: number | null
    updatedAt: Date | null
  }

  export type CustomerItemCountCountAggregateOutputType = {
    id: number
    customerId: number
    merchantId: number
    rewardId: number
    itemName: number
    count: number
    updatedAt: number
    _all: number
  }


  export type CustomerItemCountAvgAggregateInputType = {
    count?: true
  }

  export type CustomerItemCountSumAggregateInputType = {
    count?: true
  }

  export type CustomerItemCountMinAggregateInputType = {
    id?: true
    customerId?: true
    merchantId?: true
    rewardId?: true
    itemName?: true
    count?: true
    updatedAt?: true
  }

  export type CustomerItemCountMaxAggregateInputType = {
    id?: true
    customerId?: true
    merchantId?: true
    rewardId?: true
    itemName?: true
    count?: true
    updatedAt?: true
  }

  export type CustomerItemCountCountAggregateInputType = {
    id?: true
    customerId?: true
    merchantId?: true
    rewardId?: true
    itemName?: true
    count?: true
    updatedAt?: true
    _all?: true
  }

  export type CustomerItemCountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomerItemCount to aggregate.
     */
    where?: CustomerItemCountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerItemCounts to fetch.
     */
    orderBy?: CustomerItemCountOrderByWithRelationInput | CustomerItemCountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerItemCountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerItemCounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerItemCounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CustomerItemCounts
    **/
    _count?: true | CustomerItemCountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomerItemCountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomerItemCountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerItemCountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerItemCountMaxAggregateInputType
  }

  export type GetCustomerItemCountAggregateType<T extends CustomerItemCountAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomerItemCount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomerItemCount[P]>
      : GetScalarType<T[P], AggregateCustomerItemCount[P]>
  }




  export type CustomerItemCountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerItemCountWhereInput
    orderBy?: CustomerItemCountOrderByWithAggregationInput | CustomerItemCountOrderByWithAggregationInput[]
    by: CustomerItemCountScalarFieldEnum[] | CustomerItemCountScalarFieldEnum
    having?: CustomerItemCountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerItemCountCountAggregateInputType | true
    _avg?: CustomerItemCountAvgAggregateInputType
    _sum?: CustomerItemCountSumAggregateInputType
    _min?: CustomerItemCountMinAggregateInputType
    _max?: CustomerItemCountMaxAggregateInputType
  }

  export type CustomerItemCountGroupByOutputType = {
    id: string
    customerId: string
    merchantId: string
    rewardId: string
    itemName: string
    count: number
    updatedAt: Date
    _count: CustomerItemCountCountAggregateOutputType | null
    _avg: CustomerItemCountAvgAggregateOutputType | null
    _sum: CustomerItemCountSumAggregateOutputType | null
    _min: CustomerItemCountMinAggregateOutputType | null
    _max: CustomerItemCountMaxAggregateOutputType | null
  }

  type GetCustomerItemCountGroupByPayload<T extends CustomerItemCountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerItemCountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerItemCountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerItemCountGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerItemCountGroupByOutputType[P]>
        }
      >
    >


  export type CustomerItemCountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    merchantId?: boolean
    rewardId?: boolean
    itemName?: boolean
    count?: boolean
    updatedAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    merchant?: boolean | MerchantDefaultArgs<ExtArgs>
    reward?: boolean | RewardDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerItemCount"]>

  export type CustomerItemCountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    merchantId?: boolean
    rewardId?: boolean
    itemName?: boolean
    count?: boolean
    updatedAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    merchant?: boolean | MerchantDefaultArgs<ExtArgs>
    reward?: boolean | RewardDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerItemCount"]>

  export type CustomerItemCountSelectScalar = {
    id?: boolean
    customerId?: boolean
    merchantId?: boolean
    rewardId?: boolean
    itemName?: boolean
    count?: boolean
    updatedAt?: boolean
  }

  export type CustomerItemCountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    merchant?: boolean | MerchantDefaultArgs<ExtArgs>
    reward?: boolean | RewardDefaultArgs<ExtArgs>
  }
  export type CustomerItemCountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    merchant?: boolean | MerchantDefaultArgs<ExtArgs>
    reward?: boolean | RewardDefaultArgs<ExtArgs>
  }

  export type $CustomerItemCountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CustomerItemCount"
    objects: {
      customer: Prisma.$CustomerPayload<ExtArgs>
      merchant: Prisma.$MerchantPayload<ExtArgs>
      reward: Prisma.$RewardPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      customerId: string
      merchantId: string
      rewardId: string
      itemName: string
      count: number
      updatedAt: Date
    }, ExtArgs["result"]["customerItemCount"]>
    composites: {}
  }

  type CustomerItemCountGetPayload<S extends boolean | null | undefined | CustomerItemCountDefaultArgs> = $Result.GetResult<Prisma.$CustomerItemCountPayload, S>

  type CustomerItemCountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CustomerItemCountFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CustomerItemCountCountAggregateInputType | true
    }

  export interface CustomerItemCountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CustomerItemCount'], meta: { name: 'CustomerItemCount' } }
    /**
     * Find zero or one CustomerItemCount that matches the filter.
     * @param {CustomerItemCountFindUniqueArgs} args - Arguments to find a CustomerItemCount
     * @example
     * // Get one CustomerItemCount
     * const customerItemCount = await prisma.customerItemCount.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomerItemCountFindUniqueArgs>(args: SelectSubset<T, CustomerItemCountFindUniqueArgs<ExtArgs>>): Prisma__CustomerItemCountClient<$Result.GetResult<Prisma.$CustomerItemCountPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CustomerItemCount that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CustomerItemCountFindUniqueOrThrowArgs} args - Arguments to find a CustomerItemCount
     * @example
     * // Get one CustomerItemCount
     * const customerItemCount = await prisma.customerItemCount.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomerItemCountFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomerItemCountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomerItemCountClient<$Result.GetResult<Prisma.$CustomerItemCountPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CustomerItemCount that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerItemCountFindFirstArgs} args - Arguments to find a CustomerItemCount
     * @example
     * // Get one CustomerItemCount
     * const customerItemCount = await prisma.customerItemCount.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomerItemCountFindFirstArgs>(args?: SelectSubset<T, CustomerItemCountFindFirstArgs<ExtArgs>>): Prisma__CustomerItemCountClient<$Result.GetResult<Prisma.$CustomerItemCountPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CustomerItemCount that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerItemCountFindFirstOrThrowArgs} args - Arguments to find a CustomerItemCount
     * @example
     * // Get one CustomerItemCount
     * const customerItemCount = await prisma.customerItemCount.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomerItemCountFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomerItemCountFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomerItemCountClient<$Result.GetResult<Prisma.$CustomerItemCountPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CustomerItemCounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerItemCountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CustomerItemCounts
     * const customerItemCounts = await prisma.customerItemCount.findMany()
     * 
     * // Get first 10 CustomerItemCounts
     * const customerItemCounts = await prisma.customerItemCount.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerItemCountWithIdOnly = await prisma.customerItemCount.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomerItemCountFindManyArgs>(args?: SelectSubset<T, CustomerItemCountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerItemCountPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CustomerItemCount.
     * @param {CustomerItemCountCreateArgs} args - Arguments to create a CustomerItemCount.
     * @example
     * // Create one CustomerItemCount
     * const CustomerItemCount = await prisma.customerItemCount.create({
     *   data: {
     *     // ... data to create a CustomerItemCount
     *   }
     * })
     * 
     */
    create<T extends CustomerItemCountCreateArgs>(args: SelectSubset<T, CustomerItemCountCreateArgs<ExtArgs>>): Prisma__CustomerItemCountClient<$Result.GetResult<Prisma.$CustomerItemCountPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CustomerItemCounts.
     * @param {CustomerItemCountCreateManyArgs} args - Arguments to create many CustomerItemCounts.
     * @example
     * // Create many CustomerItemCounts
     * const customerItemCount = await prisma.customerItemCount.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomerItemCountCreateManyArgs>(args?: SelectSubset<T, CustomerItemCountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CustomerItemCounts and returns the data saved in the database.
     * @param {CustomerItemCountCreateManyAndReturnArgs} args - Arguments to create many CustomerItemCounts.
     * @example
     * // Create many CustomerItemCounts
     * const customerItemCount = await prisma.customerItemCount.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CustomerItemCounts and only return the `id`
     * const customerItemCountWithIdOnly = await prisma.customerItemCount.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustomerItemCountCreateManyAndReturnArgs>(args?: SelectSubset<T, CustomerItemCountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerItemCountPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CustomerItemCount.
     * @param {CustomerItemCountDeleteArgs} args - Arguments to delete one CustomerItemCount.
     * @example
     * // Delete one CustomerItemCount
     * const CustomerItemCount = await prisma.customerItemCount.delete({
     *   where: {
     *     // ... filter to delete one CustomerItemCount
     *   }
     * })
     * 
     */
    delete<T extends CustomerItemCountDeleteArgs>(args: SelectSubset<T, CustomerItemCountDeleteArgs<ExtArgs>>): Prisma__CustomerItemCountClient<$Result.GetResult<Prisma.$CustomerItemCountPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CustomerItemCount.
     * @param {CustomerItemCountUpdateArgs} args - Arguments to update one CustomerItemCount.
     * @example
     * // Update one CustomerItemCount
     * const customerItemCount = await prisma.customerItemCount.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomerItemCountUpdateArgs>(args: SelectSubset<T, CustomerItemCountUpdateArgs<ExtArgs>>): Prisma__CustomerItemCountClient<$Result.GetResult<Prisma.$CustomerItemCountPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CustomerItemCounts.
     * @param {CustomerItemCountDeleteManyArgs} args - Arguments to filter CustomerItemCounts to delete.
     * @example
     * // Delete a few CustomerItemCounts
     * const { count } = await prisma.customerItemCount.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomerItemCountDeleteManyArgs>(args?: SelectSubset<T, CustomerItemCountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomerItemCounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerItemCountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CustomerItemCounts
     * const customerItemCount = await prisma.customerItemCount.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomerItemCountUpdateManyArgs>(args: SelectSubset<T, CustomerItemCountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CustomerItemCount.
     * @param {CustomerItemCountUpsertArgs} args - Arguments to update or create a CustomerItemCount.
     * @example
     * // Update or create a CustomerItemCount
     * const customerItemCount = await prisma.customerItemCount.upsert({
     *   create: {
     *     // ... data to create a CustomerItemCount
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CustomerItemCount we want to update
     *   }
     * })
     */
    upsert<T extends CustomerItemCountUpsertArgs>(args: SelectSubset<T, CustomerItemCountUpsertArgs<ExtArgs>>): Prisma__CustomerItemCountClient<$Result.GetResult<Prisma.$CustomerItemCountPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CustomerItemCounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerItemCountCountArgs} args - Arguments to filter CustomerItemCounts to count.
     * @example
     * // Count the number of CustomerItemCounts
     * const count = await prisma.customerItemCount.count({
     *   where: {
     *     // ... the filter for the CustomerItemCounts we want to count
     *   }
     * })
    **/
    count<T extends CustomerItemCountCountArgs>(
      args?: Subset<T, CustomerItemCountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerItemCountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CustomerItemCount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerItemCountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerItemCountAggregateArgs>(args: Subset<T, CustomerItemCountAggregateArgs>): Prisma.PrismaPromise<GetCustomerItemCountAggregateType<T>>

    /**
     * Group by CustomerItemCount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerItemCountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerItemCountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerItemCountGroupByArgs['orderBy'] }
        : { orderBy?: CustomerItemCountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerItemCountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerItemCountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CustomerItemCount model
   */
  readonly fields: CustomerItemCountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CustomerItemCount.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerItemCountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    merchant<T extends MerchantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MerchantDefaultArgs<ExtArgs>>): Prisma__MerchantClient<$Result.GetResult<Prisma.$MerchantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    reward<T extends RewardDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RewardDefaultArgs<ExtArgs>>): Prisma__RewardClient<$Result.GetResult<Prisma.$RewardPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CustomerItemCount model
   */ 
  interface CustomerItemCountFieldRefs {
    readonly id: FieldRef<"CustomerItemCount", 'String'>
    readonly customerId: FieldRef<"CustomerItemCount", 'String'>
    readonly merchantId: FieldRef<"CustomerItemCount", 'String'>
    readonly rewardId: FieldRef<"CustomerItemCount", 'String'>
    readonly itemName: FieldRef<"CustomerItemCount", 'String'>
    readonly count: FieldRef<"CustomerItemCount", 'Int'>
    readonly updatedAt: FieldRef<"CustomerItemCount", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CustomerItemCount findUnique
   */
  export type CustomerItemCountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerItemCount
     */
    select?: CustomerItemCountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerItemCountInclude<ExtArgs> | null
    /**
     * Filter, which CustomerItemCount to fetch.
     */
    where: CustomerItemCountWhereUniqueInput
  }

  /**
   * CustomerItemCount findUniqueOrThrow
   */
  export type CustomerItemCountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerItemCount
     */
    select?: CustomerItemCountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerItemCountInclude<ExtArgs> | null
    /**
     * Filter, which CustomerItemCount to fetch.
     */
    where: CustomerItemCountWhereUniqueInput
  }

  /**
   * CustomerItemCount findFirst
   */
  export type CustomerItemCountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerItemCount
     */
    select?: CustomerItemCountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerItemCountInclude<ExtArgs> | null
    /**
     * Filter, which CustomerItemCount to fetch.
     */
    where?: CustomerItemCountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerItemCounts to fetch.
     */
    orderBy?: CustomerItemCountOrderByWithRelationInput | CustomerItemCountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerItemCounts.
     */
    cursor?: CustomerItemCountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerItemCounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerItemCounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerItemCounts.
     */
    distinct?: CustomerItemCountScalarFieldEnum | CustomerItemCountScalarFieldEnum[]
  }

  /**
   * CustomerItemCount findFirstOrThrow
   */
  export type CustomerItemCountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerItemCount
     */
    select?: CustomerItemCountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerItemCountInclude<ExtArgs> | null
    /**
     * Filter, which CustomerItemCount to fetch.
     */
    where?: CustomerItemCountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerItemCounts to fetch.
     */
    orderBy?: CustomerItemCountOrderByWithRelationInput | CustomerItemCountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerItemCounts.
     */
    cursor?: CustomerItemCountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerItemCounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerItemCounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerItemCounts.
     */
    distinct?: CustomerItemCountScalarFieldEnum | CustomerItemCountScalarFieldEnum[]
  }

  /**
   * CustomerItemCount findMany
   */
  export type CustomerItemCountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerItemCount
     */
    select?: CustomerItemCountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerItemCountInclude<ExtArgs> | null
    /**
     * Filter, which CustomerItemCounts to fetch.
     */
    where?: CustomerItemCountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerItemCounts to fetch.
     */
    orderBy?: CustomerItemCountOrderByWithRelationInput | CustomerItemCountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CustomerItemCounts.
     */
    cursor?: CustomerItemCountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerItemCounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerItemCounts.
     */
    skip?: number
    distinct?: CustomerItemCountScalarFieldEnum | CustomerItemCountScalarFieldEnum[]
  }

  /**
   * CustomerItemCount create
   */
  export type CustomerItemCountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerItemCount
     */
    select?: CustomerItemCountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerItemCountInclude<ExtArgs> | null
    /**
     * The data needed to create a CustomerItemCount.
     */
    data: XOR<CustomerItemCountCreateInput, CustomerItemCountUncheckedCreateInput>
  }

  /**
   * CustomerItemCount createMany
   */
  export type CustomerItemCountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CustomerItemCounts.
     */
    data: CustomerItemCountCreateManyInput | CustomerItemCountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CustomerItemCount createManyAndReturn
   */
  export type CustomerItemCountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerItemCount
     */
    select?: CustomerItemCountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CustomerItemCounts.
     */
    data: CustomerItemCountCreateManyInput | CustomerItemCountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerItemCountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CustomerItemCount update
   */
  export type CustomerItemCountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerItemCount
     */
    select?: CustomerItemCountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerItemCountInclude<ExtArgs> | null
    /**
     * The data needed to update a CustomerItemCount.
     */
    data: XOR<CustomerItemCountUpdateInput, CustomerItemCountUncheckedUpdateInput>
    /**
     * Choose, which CustomerItemCount to update.
     */
    where: CustomerItemCountWhereUniqueInput
  }

  /**
   * CustomerItemCount updateMany
   */
  export type CustomerItemCountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CustomerItemCounts.
     */
    data: XOR<CustomerItemCountUpdateManyMutationInput, CustomerItemCountUncheckedUpdateManyInput>
    /**
     * Filter which CustomerItemCounts to update
     */
    where?: CustomerItemCountWhereInput
  }

  /**
   * CustomerItemCount upsert
   */
  export type CustomerItemCountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerItemCount
     */
    select?: CustomerItemCountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerItemCountInclude<ExtArgs> | null
    /**
     * The filter to search for the CustomerItemCount to update in case it exists.
     */
    where: CustomerItemCountWhereUniqueInput
    /**
     * In case the CustomerItemCount found by the `where` argument doesn't exist, create a new CustomerItemCount with this data.
     */
    create: XOR<CustomerItemCountCreateInput, CustomerItemCountUncheckedCreateInput>
    /**
     * In case the CustomerItemCount was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerItemCountUpdateInput, CustomerItemCountUncheckedUpdateInput>
  }

  /**
   * CustomerItemCount delete
   */
  export type CustomerItemCountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerItemCount
     */
    select?: CustomerItemCountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerItemCountInclude<ExtArgs> | null
    /**
     * Filter which CustomerItemCount to delete.
     */
    where: CustomerItemCountWhereUniqueInput
  }

  /**
   * CustomerItemCount deleteMany
   */
  export type CustomerItemCountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomerItemCounts to delete
     */
    where?: CustomerItemCountWhereInput
  }

  /**
   * CustomerItemCount without action
   */
  export type CustomerItemCountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerItemCount
     */
    select?: CustomerItemCountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerItemCountInclude<ExtArgs> | null
  }


  /**
   * Model LedgerEntry
   */

  export type AggregateLedgerEntry = {
    _count: LedgerEntryCountAggregateOutputType | null
    _avg: LedgerEntryAvgAggregateOutputType | null
    _sum: LedgerEntrySumAggregateOutputType | null
    _min: LedgerEntryMinAggregateOutputType | null
    _max: LedgerEntryMaxAggregateOutputType | null
  }

  export type LedgerEntryAvgAggregateOutputType = {
    points: number | null
  }

  export type LedgerEntrySumAggregateOutputType = {
    points: number | null
  }

  export type LedgerEntryMinAggregateOutputType = {
    id: string | null
    customerId: string | null
    merchantId: string | null
    type: $Enums.LedgerEntryType | null
    points: number | null
    transactionId: string | null
    redemptionId: string | null
    createdAt: Date | null
  }

  export type LedgerEntryMaxAggregateOutputType = {
    id: string | null
    customerId: string | null
    merchantId: string | null
    type: $Enums.LedgerEntryType | null
    points: number | null
    transactionId: string | null
    redemptionId: string | null
    createdAt: Date | null
  }

  export type LedgerEntryCountAggregateOutputType = {
    id: number
    customerId: number
    merchantId: number
    type: number
    points: number
    transactionId: number
    redemptionId: number
    createdAt: number
    _all: number
  }


  export type LedgerEntryAvgAggregateInputType = {
    points?: true
  }

  export type LedgerEntrySumAggregateInputType = {
    points?: true
  }

  export type LedgerEntryMinAggregateInputType = {
    id?: true
    customerId?: true
    merchantId?: true
    type?: true
    points?: true
    transactionId?: true
    redemptionId?: true
    createdAt?: true
  }

  export type LedgerEntryMaxAggregateInputType = {
    id?: true
    customerId?: true
    merchantId?: true
    type?: true
    points?: true
    transactionId?: true
    redemptionId?: true
    createdAt?: true
  }

  export type LedgerEntryCountAggregateInputType = {
    id?: true
    customerId?: true
    merchantId?: true
    type?: true
    points?: true
    transactionId?: true
    redemptionId?: true
    createdAt?: true
    _all?: true
  }

  export type LedgerEntryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LedgerEntry to aggregate.
     */
    where?: LedgerEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LedgerEntries to fetch.
     */
    orderBy?: LedgerEntryOrderByWithRelationInput | LedgerEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LedgerEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LedgerEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LedgerEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LedgerEntries
    **/
    _count?: true | LedgerEntryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LedgerEntryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LedgerEntrySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LedgerEntryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LedgerEntryMaxAggregateInputType
  }

  export type GetLedgerEntryAggregateType<T extends LedgerEntryAggregateArgs> = {
        [P in keyof T & keyof AggregateLedgerEntry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLedgerEntry[P]>
      : GetScalarType<T[P], AggregateLedgerEntry[P]>
  }




  export type LedgerEntryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LedgerEntryWhereInput
    orderBy?: LedgerEntryOrderByWithAggregationInput | LedgerEntryOrderByWithAggregationInput[]
    by: LedgerEntryScalarFieldEnum[] | LedgerEntryScalarFieldEnum
    having?: LedgerEntryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LedgerEntryCountAggregateInputType | true
    _avg?: LedgerEntryAvgAggregateInputType
    _sum?: LedgerEntrySumAggregateInputType
    _min?: LedgerEntryMinAggregateInputType
    _max?: LedgerEntryMaxAggregateInputType
  }

  export type LedgerEntryGroupByOutputType = {
    id: string
    customerId: string
    merchantId: string
    type: $Enums.LedgerEntryType
    points: number
    transactionId: string | null
    redemptionId: string | null
    createdAt: Date
    _count: LedgerEntryCountAggregateOutputType | null
    _avg: LedgerEntryAvgAggregateOutputType | null
    _sum: LedgerEntrySumAggregateOutputType | null
    _min: LedgerEntryMinAggregateOutputType | null
    _max: LedgerEntryMaxAggregateOutputType | null
  }

  type GetLedgerEntryGroupByPayload<T extends LedgerEntryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LedgerEntryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LedgerEntryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LedgerEntryGroupByOutputType[P]>
            : GetScalarType<T[P], LedgerEntryGroupByOutputType[P]>
        }
      >
    >


  export type LedgerEntrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    merchantId?: boolean
    type?: boolean
    points?: boolean
    transactionId?: boolean
    redemptionId?: boolean
    createdAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    merchant?: boolean | MerchantDefaultArgs<ExtArgs>
    transaction?: boolean | LedgerEntry$transactionArgs<ExtArgs>
    redemption?: boolean | LedgerEntry$redemptionArgs<ExtArgs>
  }, ExtArgs["result"]["ledgerEntry"]>

  export type LedgerEntrySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    merchantId?: boolean
    type?: boolean
    points?: boolean
    transactionId?: boolean
    redemptionId?: boolean
    createdAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    merchant?: boolean | MerchantDefaultArgs<ExtArgs>
    transaction?: boolean | LedgerEntry$transactionArgs<ExtArgs>
    redemption?: boolean | LedgerEntry$redemptionArgs<ExtArgs>
  }, ExtArgs["result"]["ledgerEntry"]>

  export type LedgerEntrySelectScalar = {
    id?: boolean
    customerId?: boolean
    merchantId?: boolean
    type?: boolean
    points?: boolean
    transactionId?: boolean
    redemptionId?: boolean
    createdAt?: boolean
  }

  export type LedgerEntryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    merchant?: boolean | MerchantDefaultArgs<ExtArgs>
    transaction?: boolean | LedgerEntry$transactionArgs<ExtArgs>
    redemption?: boolean | LedgerEntry$redemptionArgs<ExtArgs>
  }
  export type LedgerEntryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    merchant?: boolean | MerchantDefaultArgs<ExtArgs>
    transaction?: boolean | LedgerEntry$transactionArgs<ExtArgs>
    redemption?: boolean | LedgerEntry$redemptionArgs<ExtArgs>
  }

  export type $LedgerEntryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LedgerEntry"
    objects: {
      customer: Prisma.$CustomerPayload<ExtArgs>
      merchant: Prisma.$MerchantPayload<ExtArgs>
      transaction: Prisma.$TransactionPayload<ExtArgs> | null
      redemption: Prisma.$RedemptionPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      customerId: string
      merchantId: string
      type: $Enums.LedgerEntryType
      points: number
      transactionId: string | null
      redemptionId: string | null
      createdAt: Date
    }, ExtArgs["result"]["ledgerEntry"]>
    composites: {}
  }

  type LedgerEntryGetPayload<S extends boolean | null | undefined | LedgerEntryDefaultArgs> = $Result.GetResult<Prisma.$LedgerEntryPayload, S>

  type LedgerEntryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LedgerEntryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LedgerEntryCountAggregateInputType | true
    }

  export interface LedgerEntryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LedgerEntry'], meta: { name: 'LedgerEntry' } }
    /**
     * Find zero or one LedgerEntry that matches the filter.
     * @param {LedgerEntryFindUniqueArgs} args - Arguments to find a LedgerEntry
     * @example
     * // Get one LedgerEntry
     * const ledgerEntry = await prisma.ledgerEntry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LedgerEntryFindUniqueArgs>(args: SelectSubset<T, LedgerEntryFindUniqueArgs<ExtArgs>>): Prisma__LedgerEntryClient<$Result.GetResult<Prisma.$LedgerEntryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one LedgerEntry that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LedgerEntryFindUniqueOrThrowArgs} args - Arguments to find a LedgerEntry
     * @example
     * // Get one LedgerEntry
     * const ledgerEntry = await prisma.ledgerEntry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LedgerEntryFindUniqueOrThrowArgs>(args: SelectSubset<T, LedgerEntryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LedgerEntryClient<$Result.GetResult<Prisma.$LedgerEntryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first LedgerEntry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LedgerEntryFindFirstArgs} args - Arguments to find a LedgerEntry
     * @example
     * // Get one LedgerEntry
     * const ledgerEntry = await prisma.ledgerEntry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LedgerEntryFindFirstArgs>(args?: SelectSubset<T, LedgerEntryFindFirstArgs<ExtArgs>>): Prisma__LedgerEntryClient<$Result.GetResult<Prisma.$LedgerEntryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first LedgerEntry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LedgerEntryFindFirstOrThrowArgs} args - Arguments to find a LedgerEntry
     * @example
     * // Get one LedgerEntry
     * const ledgerEntry = await prisma.ledgerEntry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LedgerEntryFindFirstOrThrowArgs>(args?: SelectSubset<T, LedgerEntryFindFirstOrThrowArgs<ExtArgs>>): Prisma__LedgerEntryClient<$Result.GetResult<Prisma.$LedgerEntryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more LedgerEntries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LedgerEntryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LedgerEntries
     * const ledgerEntries = await prisma.ledgerEntry.findMany()
     * 
     * // Get first 10 LedgerEntries
     * const ledgerEntries = await prisma.ledgerEntry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ledgerEntryWithIdOnly = await prisma.ledgerEntry.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LedgerEntryFindManyArgs>(args?: SelectSubset<T, LedgerEntryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LedgerEntryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a LedgerEntry.
     * @param {LedgerEntryCreateArgs} args - Arguments to create a LedgerEntry.
     * @example
     * // Create one LedgerEntry
     * const LedgerEntry = await prisma.ledgerEntry.create({
     *   data: {
     *     // ... data to create a LedgerEntry
     *   }
     * })
     * 
     */
    create<T extends LedgerEntryCreateArgs>(args: SelectSubset<T, LedgerEntryCreateArgs<ExtArgs>>): Prisma__LedgerEntryClient<$Result.GetResult<Prisma.$LedgerEntryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many LedgerEntries.
     * @param {LedgerEntryCreateManyArgs} args - Arguments to create many LedgerEntries.
     * @example
     * // Create many LedgerEntries
     * const ledgerEntry = await prisma.ledgerEntry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LedgerEntryCreateManyArgs>(args?: SelectSubset<T, LedgerEntryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LedgerEntries and returns the data saved in the database.
     * @param {LedgerEntryCreateManyAndReturnArgs} args - Arguments to create many LedgerEntries.
     * @example
     * // Create many LedgerEntries
     * const ledgerEntry = await prisma.ledgerEntry.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LedgerEntries and only return the `id`
     * const ledgerEntryWithIdOnly = await prisma.ledgerEntry.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LedgerEntryCreateManyAndReturnArgs>(args?: SelectSubset<T, LedgerEntryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LedgerEntryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a LedgerEntry.
     * @param {LedgerEntryDeleteArgs} args - Arguments to delete one LedgerEntry.
     * @example
     * // Delete one LedgerEntry
     * const LedgerEntry = await prisma.ledgerEntry.delete({
     *   where: {
     *     // ... filter to delete one LedgerEntry
     *   }
     * })
     * 
     */
    delete<T extends LedgerEntryDeleteArgs>(args: SelectSubset<T, LedgerEntryDeleteArgs<ExtArgs>>): Prisma__LedgerEntryClient<$Result.GetResult<Prisma.$LedgerEntryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one LedgerEntry.
     * @param {LedgerEntryUpdateArgs} args - Arguments to update one LedgerEntry.
     * @example
     * // Update one LedgerEntry
     * const ledgerEntry = await prisma.ledgerEntry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LedgerEntryUpdateArgs>(args: SelectSubset<T, LedgerEntryUpdateArgs<ExtArgs>>): Prisma__LedgerEntryClient<$Result.GetResult<Prisma.$LedgerEntryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more LedgerEntries.
     * @param {LedgerEntryDeleteManyArgs} args - Arguments to filter LedgerEntries to delete.
     * @example
     * // Delete a few LedgerEntries
     * const { count } = await prisma.ledgerEntry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LedgerEntryDeleteManyArgs>(args?: SelectSubset<T, LedgerEntryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LedgerEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LedgerEntryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LedgerEntries
     * const ledgerEntry = await prisma.ledgerEntry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LedgerEntryUpdateManyArgs>(args: SelectSubset<T, LedgerEntryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LedgerEntry.
     * @param {LedgerEntryUpsertArgs} args - Arguments to update or create a LedgerEntry.
     * @example
     * // Update or create a LedgerEntry
     * const ledgerEntry = await prisma.ledgerEntry.upsert({
     *   create: {
     *     // ... data to create a LedgerEntry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LedgerEntry we want to update
     *   }
     * })
     */
    upsert<T extends LedgerEntryUpsertArgs>(args: SelectSubset<T, LedgerEntryUpsertArgs<ExtArgs>>): Prisma__LedgerEntryClient<$Result.GetResult<Prisma.$LedgerEntryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of LedgerEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LedgerEntryCountArgs} args - Arguments to filter LedgerEntries to count.
     * @example
     * // Count the number of LedgerEntries
     * const count = await prisma.ledgerEntry.count({
     *   where: {
     *     // ... the filter for the LedgerEntries we want to count
     *   }
     * })
    **/
    count<T extends LedgerEntryCountArgs>(
      args?: Subset<T, LedgerEntryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LedgerEntryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LedgerEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LedgerEntryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LedgerEntryAggregateArgs>(args: Subset<T, LedgerEntryAggregateArgs>): Prisma.PrismaPromise<GetLedgerEntryAggregateType<T>>

    /**
     * Group by LedgerEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LedgerEntryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LedgerEntryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LedgerEntryGroupByArgs['orderBy'] }
        : { orderBy?: LedgerEntryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LedgerEntryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLedgerEntryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LedgerEntry model
   */
  readonly fields: LedgerEntryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LedgerEntry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LedgerEntryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    merchant<T extends MerchantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MerchantDefaultArgs<ExtArgs>>): Prisma__MerchantClient<$Result.GetResult<Prisma.$MerchantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    transaction<T extends LedgerEntry$transactionArgs<ExtArgs> = {}>(args?: Subset<T, LedgerEntry$transactionArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    redemption<T extends LedgerEntry$redemptionArgs<ExtArgs> = {}>(args?: Subset<T, LedgerEntry$redemptionArgs<ExtArgs>>): Prisma__RedemptionClient<$Result.GetResult<Prisma.$RedemptionPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LedgerEntry model
   */ 
  interface LedgerEntryFieldRefs {
    readonly id: FieldRef<"LedgerEntry", 'String'>
    readonly customerId: FieldRef<"LedgerEntry", 'String'>
    readonly merchantId: FieldRef<"LedgerEntry", 'String'>
    readonly type: FieldRef<"LedgerEntry", 'LedgerEntryType'>
    readonly points: FieldRef<"LedgerEntry", 'Int'>
    readonly transactionId: FieldRef<"LedgerEntry", 'String'>
    readonly redemptionId: FieldRef<"LedgerEntry", 'String'>
    readonly createdAt: FieldRef<"LedgerEntry", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LedgerEntry findUnique
   */
  export type LedgerEntryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerEntry
     */
    select?: LedgerEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerEntryInclude<ExtArgs> | null
    /**
     * Filter, which LedgerEntry to fetch.
     */
    where: LedgerEntryWhereUniqueInput
  }

  /**
   * LedgerEntry findUniqueOrThrow
   */
  export type LedgerEntryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerEntry
     */
    select?: LedgerEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerEntryInclude<ExtArgs> | null
    /**
     * Filter, which LedgerEntry to fetch.
     */
    where: LedgerEntryWhereUniqueInput
  }

  /**
   * LedgerEntry findFirst
   */
  export type LedgerEntryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerEntry
     */
    select?: LedgerEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerEntryInclude<ExtArgs> | null
    /**
     * Filter, which LedgerEntry to fetch.
     */
    where?: LedgerEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LedgerEntries to fetch.
     */
    orderBy?: LedgerEntryOrderByWithRelationInput | LedgerEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LedgerEntries.
     */
    cursor?: LedgerEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LedgerEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LedgerEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LedgerEntries.
     */
    distinct?: LedgerEntryScalarFieldEnum | LedgerEntryScalarFieldEnum[]
  }

  /**
   * LedgerEntry findFirstOrThrow
   */
  export type LedgerEntryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerEntry
     */
    select?: LedgerEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerEntryInclude<ExtArgs> | null
    /**
     * Filter, which LedgerEntry to fetch.
     */
    where?: LedgerEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LedgerEntries to fetch.
     */
    orderBy?: LedgerEntryOrderByWithRelationInput | LedgerEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LedgerEntries.
     */
    cursor?: LedgerEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LedgerEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LedgerEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LedgerEntries.
     */
    distinct?: LedgerEntryScalarFieldEnum | LedgerEntryScalarFieldEnum[]
  }

  /**
   * LedgerEntry findMany
   */
  export type LedgerEntryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerEntry
     */
    select?: LedgerEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerEntryInclude<ExtArgs> | null
    /**
     * Filter, which LedgerEntries to fetch.
     */
    where?: LedgerEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LedgerEntries to fetch.
     */
    orderBy?: LedgerEntryOrderByWithRelationInput | LedgerEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LedgerEntries.
     */
    cursor?: LedgerEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LedgerEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LedgerEntries.
     */
    skip?: number
    distinct?: LedgerEntryScalarFieldEnum | LedgerEntryScalarFieldEnum[]
  }

  /**
   * LedgerEntry create
   */
  export type LedgerEntryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerEntry
     */
    select?: LedgerEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerEntryInclude<ExtArgs> | null
    /**
     * The data needed to create a LedgerEntry.
     */
    data: XOR<LedgerEntryCreateInput, LedgerEntryUncheckedCreateInput>
  }

  /**
   * LedgerEntry createMany
   */
  export type LedgerEntryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LedgerEntries.
     */
    data: LedgerEntryCreateManyInput | LedgerEntryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LedgerEntry createManyAndReturn
   */
  export type LedgerEntryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerEntry
     */
    select?: LedgerEntrySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many LedgerEntries.
     */
    data: LedgerEntryCreateManyInput | LedgerEntryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerEntryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LedgerEntry update
   */
  export type LedgerEntryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerEntry
     */
    select?: LedgerEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerEntryInclude<ExtArgs> | null
    /**
     * The data needed to update a LedgerEntry.
     */
    data: XOR<LedgerEntryUpdateInput, LedgerEntryUncheckedUpdateInput>
    /**
     * Choose, which LedgerEntry to update.
     */
    where: LedgerEntryWhereUniqueInput
  }

  /**
   * LedgerEntry updateMany
   */
  export type LedgerEntryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LedgerEntries.
     */
    data: XOR<LedgerEntryUpdateManyMutationInput, LedgerEntryUncheckedUpdateManyInput>
    /**
     * Filter which LedgerEntries to update
     */
    where?: LedgerEntryWhereInput
  }

  /**
   * LedgerEntry upsert
   */
  export type LedgerEntryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerEntry
     */
    select?: LedgerEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerEntryInclude<ExtArgs> | null
    /**
     * The filter to search for the LedgerEntry to update in case it exists.
     */
    where: LedgerEntryWhereUniqueInput
    /**
     * In case the LedgerEntry found by the `where` argument doesn't exist, create a new LedgerEntry with this data.
     */
    create: XOR<LedgerEntryCreateInput, LedgerEntryUncheckedCreateInput>
    /**
     * In case the LedgerEntry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LedgerEntryUpdateInput, LedgerEntryUncheckedUpdateInput>
  }

  /**
   * LedgerEntry delete
   */
  export type LedgerEntryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerEntry
     */
    select?: LedgerEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerEntryInclude<ExtArgs> | null
    /**
     * Filter which LedgerEntry to delete.
     */
    where: LedgerEntryWhereUniqueInput
  }

  /**
   * LedgerEntry deleteMany
   */
  export type LedgerEntryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LedgerEntries to delete
     */
    where?: LedgerEntryWhereInput
  }

  /**
   * LedgerEntry.transaction
   */
  export type LedgerEntry$transactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
  }

  /**
   * LedgerEntry.redemption
   */
  export type LedgerEntry$redemptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redemption
     */
    select?: RedemptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RedemptionInclude<ExtArgs> | null
    where?: RedemptionWhereInput
  }

  /**
   * LedgerEntry without action
   */
  export type LedgerEntryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerEntry
     */
    select?: LedgerEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerEntryInclude<ExtArgs> | null
  }


  /**
   * Model WebhookLog
   */

  export type AggregateWebhookLog = {
    _count: WebhookLogCountAggregateOutputType | null
    _min: WebhookLogMinAggregateOutputType | null
    _max: WebhookLogMaxAggregateOutputType | null
  }

  export type WebhookLogMinAggregateOutputType = {
    id: string | null
    provider: $Enums.POSProvider | null
    eventType: string | null
    signature: string | null
    status: $Enums.WebhookStatus | null
    errorMessage: string | null
    processedAt: Date | null
    createdAt: Date | null
  }

  export type WebhookLogMaxAggregateOutputType = {
    id: string | null
    provider: $Enums.POSProvider | null
    eventType: string | null
    signature: string | null
    status: $Enums.WebhookStatus | null
    errorMessage: string | null
    processedAt: Date | null
    createdAt: Date | null
  }

  export type WebhookLogCountAggregateOutputType = {
    id: number
    provider: number
    eventType: number
    payload: number
    signature: number
    status: number
    errorMessage: number
    processedAt: number
    createdAt: number
    _all: number
  }


  export type WebhookLogMinAggregateInputType = {
    id?: true
    provider?: true
    eventType?: true
    signature?: true
    status?: true
    errorMessage?: true
    processedAt?: true
    createdAt?: true
  }

  export type WebhookLogMaxAggregateInputType = {
    id?: true
    provider?: true
    eventType?: true
    signature?: true
    status?: true
    errorMessage?: true
    processedAt?: true
    createdAt?: true
  }

  export type WebhookLogCountAggregateInputType = {
    id?: true
    provider?: true
    eventType?: true
    payload?: true
    signature?: true
    status?: true
    errorMessage?: true
    processedAt?: true
    createdAt?: true
    _all?: true
  }

  export type WebhookLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WebhookLog to aggregate.
     */
    where?: WebhookLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebhookLogs to fetch.
     */
    orderBy?: WebhookLogOrderByWithRelationInput | WebhookLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WebhookLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebhookLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebhookLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WebhookLogs
    **/
    _count?: true | WebhookLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WebhookLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WebhookLogMaxAggregateInputType
  }

  export type GetWebhookLogAggregateType<T extends WebhookLogAggregateArgs> = {
        [P in keyof T & keyof AggregateWebhookLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWebhookLog[P]>
      : GetScalarType<T[P], AggregateWebhookLog[P]>
  }




  export type WebhookLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WebhookLogWhereInput
    orderBy?: WebhookLogOrderByWithAggregationInput | WebhookLogOrderByWithAggregationInput[]
    by: WebhookLogScalarFieldEnum[] | WebhookLogScalarFieldEnum
    having?: WebhookLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WebhookLogCountAggregateInputType | true
    _min?: WebhookLogMinAggregateInputType
    _max?: WebhookLogMaxAggregateInputType
  }

  export type WebhookLogGroupByOutputType = {
    id: string
    provider: $Enums.POSProvider
    eventType: string
    payload: JsonValue
    signature: string | null
    status: $Enums.WebhookStatus
    errorMessage: string | null
    processedAt: Date | null
    createdAt: Date
    _count: WebhookLogCountAggregateOutputType | null
    _min: WebhookLogMinAggregateOutputType | null
    _max: WebhookLogMaxAggregateOutputType | null
  }

  type GetWebhookLogGroupByPayload<T extends WebhookLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WebhookLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WebhookLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WebhookLogGroupByOutputType[P]>
            : GetScalarType<T[P], WebhookLogGroupByOutputType[P]>
        }
      >
    >


  export type WebhookLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    provider?: boolean
    eventType?: boolean
    payload?: boolean
    signature?: boolean
    status?: boolean
    errorMessage?: boolean
    processedAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["webhookLog"]>

  export type WebhookLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    provider?: boolean
    eventType?: boolean
    payload?: boolean
    signature?: boolean
    status?: boolean
    errorMessage?: boolean
    processedAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["webhookLog"]>

  export type WebhookLogSelectScalar = {
    id?: boolean
    provider?: boolean
    eventType?: boolean
    payload?: boolean
    signature?: boolean
    status?: boolean
    errorMessage?: boolean
    processedAt?: boolean
    createdAt?: boolean
  }


  export type $WebhookLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WebhookLog"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      provider: $Enums.POSProvider
      eventType: string
      payload: Prisma.JsonValue
      signature: string | null
      status: $Enums.WebhookStatus
      errorMessage: string | null
      processedAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["webhookLog"]>
    composites: {}
  }

  type WebhookLogGetPayload<S extends boolean | null | undefined | WebhookLogDefaultArgs> = $Result.GetResult<Prisma.$WebhookLogPayload, S>

  type WebhookLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WebhookLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WebhookLogCountAggregateInputType | true
    }

  export interface WebhookLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WebhookLog'], meta: { name: 'WebhookLog' } }
    /**
     * Find zero or one WebhookLog that matches the filter.
     * @param {WebhookLogFindUniqueArgs} args - Arguments to find a WebhookLog
     * @example
     * // Get one WebhookLog
     * const webhookLog = await prisma.webhookLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WebhookLogFindUniqueArgs>(args: SelectSubset<T, WebhookLogFindUniqueArgs<ExtArgs>>): Prisma__WebhookLogClient<$Result.GetResult<Prisma.$WebhookLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one WebhookLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WebhookLogFindUniqueOrThrowArgs} args - Arguments to find a WebhookLog
     * @example
     * // Get one WebhookLog
     * const webhookLog = await prisma.webhookLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WebhookLogFindUniqueOrThrowArgs>(args: SelectSubset<T, WebhookLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WebhookLogClient<$Result.GetResult<Prisma.$WebhookLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first WebhookLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookLogFindFirstArgs} args - Arguments to find a WebhookLog
     * @example
     * // Get one WebhookLog
     * const webhookLog = await prisma.webhookLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WebhookLogFindFirstArgs>(args?: SelectSubset<T, WebhookLogFindFirstArgs<ExtArgs>>): Prisma__WebhookLogClient<$Result.GetResult<Prisma.$WebhookLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first WebhookLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookLogFindFirstOrThrowArgs} args - Arguments to find a WebhookLog
     * @example
     * // Get one WebhookLog
     * const webhookLog = await prisma.webhookLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WebhookLogFindFirstOrThrowArgs>(args?: SelectSubset<T, WebhookLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__WebhookLogClient<$Result.GetResult<Prisma.$WebhookLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more WebhookLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WebhookLogs
     * const webhookLogs = await prisma.webhookLog.findMany()
     * 
     * // Get first 10 WebhookLogs
     * const webhookLogs = await prisma.webhookLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const webhookLogWithIdOnly = await prisma.webhookLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WebhookLogFindManyArgs>(args?: SelectSubset<T, WebhookLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebhookLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a WebhookLog.
     * @param {WebhookLogCreateArgs} args - Arguments to create a WebhookLog.
     * @example
     * // Create one WebhookLog
     * const WebhookLog = await prisma.webhookLog.create({
     *   data: {
     *     // ... data to create a WebhookLog
     *   }
     * })
     * 
     */
    create<T extends WebhookLogCreateArgs>(args: SelectSubset<T, WebhookLogCreateArgs<ExtArgs>>): Prisma__WebhookLogClient<$Result.GetResult<Prisma.$WebhookLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many WebhookLogs.
     * @param {WebhookLogCreateManyArgs} args - Arguments to create many WebhookLogs.
     * @example
     * // Create many WebhookLogs
     * const webhookLog = await prisma.webhookLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WebhookLogCreateManyArgs>(args?: SelectSubset<T, WebhookLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WebhookLogs and returns the data saved in the database.
     * @param {WebhookLogCreateManyAndReturnArgs} args - Arguments to create many WebhookLogs.
     * @example
     * // Create many WebhookLogs
     * const webhookLog = await prisma.webhookLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WebhookLogs and only return the `id`
     * const webhookLogWithIdOnly = await prisma.webhookLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WebhookLogCreateManyAndReturnArgs>(args?: SelectSubset<T, WebhookLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebhookLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a WebhookLog.
     * @param {WebhookLogDeleteArgs} args - Arguments to delete one WebhookLog.
     * @example
     * // Delete one WebhookLog
     * const WebhookLog = await prisma.webhookLog.delete({
     *   where: {
     *     // ... filter to delete one WebhookLog
     *   }
     * })
     * 
     */
    delete<T extends WebhookLogDeleteArgs>(args: SelectSubset<T, WebhookLogDeleteArgs<ExtArgs>>): Prisma__WebhookLogClient<$Result.GetResult<Prisma.$WebhookLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one WebhookLog.
     * @param {WebhookLogUpdateArgs} args - Arguments to update one WebhookLog.
     * @example
     * // Update one WebhookLog
     * const webhookLog = await prisma.webhookLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WebhookLogUpdateArgs>(args: SelectSubset<T, WebhookLogUpdateArgs<ExtArgs>>): Prisma__WebhookLogClient<$Result.GetResult<Prisma.$WebhookLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more WebhookLogs.
     * @param {WebhookLogDeleteManyArgs} args - Arguments to filter WebhookLogs to delete.
     * @example
     * // Delete a few WebhookLogs
     * const { count } = await prisma.webhookLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WebhookLogDeleteManyArgs>(args?: SelectSubset<T, WebhookLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WebhookLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WebhookLogs
     * const webhookLog = await prisma.webhookLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WebhookLogUpdateManyArgs>(args: SelectSubset<T, WebhookLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WebhookLog.
     * @param {WebhookLogUpsertArgs} args - Arguments to update or create a WebhookLog.
     * @example
     * // Update or create a WebhookLog
     * const webhookLog = await prisma.webhookLog.upsert({
     *   create: {
     *     // ... data to create a WebhookLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WebhookLog we want to update
     *   }
     * })
     */
    upsert<T extends WebhookLogUpsertArgs>(args: SelectSubset<T, WebhookLogUpsertArgs<ExtArgs>>): Prisma__WebhookLogClient<$Result.GetResult<Prisma.$WebhookLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of WebhookLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookLogCountArgs} args - Arguments to filter WebhookLogs to count.
     * @example
     * // Count the number of WebhookLogs
     * const count = await prisma.webhookLog.count({
     *   where: {
     *     // ... the filter for the WebhookLogs we want to count
     *   }
     * })
    **/
    count<T extends WebhookLogCountArgs>(
      args?: Subset<T, WebhookLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WebhookLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WebhookLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WebhookLogAggregateArgs>(args: Subset<T, WebhookLogAggregateArgs>): Prisma.PrismaPromise<GetWebhookLogAggregateType<T>>

    /**
     * Group by WebhookLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WebhookLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WebhookLogGroupByArgs['orderBy'] }
        : { orderBy?: WebhookLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WebhookLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWebhookLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WebhookLog model
   */
  readonly fields: WebhookLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WebhookLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WebhookLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WebhookLog model
   */ 
  interface WebhookLogFieldRefs {
    readonly id: FieldRef<"WebhookLog", 'String'>
    readonly provider: FieldRef<"WebhookLog", 'POSProvider'>
    readonly eventType: FieldRef<"WebhookLog", 'String'>
    readonly payload: FieldRef<"WebhookLog", 'Json'>
    readonly signature: FieldRef<"WebhookLog", 'String'>
    readonly status: FieldRef<"WebhookLog", 'WebhookStatus'>
    readonly errorMessage: FieldRef<"WebhookLog", 'String'>
    readonly processedAt: FieldRef<"WebhookLog", 'DateTime'>
    readonly createdAt: FieldRef<"WebhookLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WebhookLog findUnique
   */
  export type WebhookLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookLog
     */
    select?: WebhookLogSelect<ExtArgs> | null
    /**
     * Filter, which WebhookLog to fetch.
     */
    where: WebhookLogWhereUniqueInput
  }

  /**
   * WebhookLog findUniqueOrThrow
   */
  export type WebhookLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookLog
     */
    select?: WebhookLogSelect<ExtArgs> | null
    /**
     * Filter, which WebhookLog to fetch.
     */
    where: WebhookLogWhereUniqueInput
  }

  /**
   * WebhookLog findFirst
   */
  export type WebhookLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookLog
     */
    select?: WebhookLogSelect<ExtArgs> | null
    /**
     * Filter, which WebhookLog to fetch.
     */
    where?: WebhookLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebhookLogs to fetch.
     */
    orderBy?: WebhookLogOrderByWithRelationInput | WebhookLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WebhookLogs.
     */
    cursor?: WebhookLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebhookLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebhookLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WebhookLogs.
     */
    distinct?: WebhookLogScalarFieldEnum | WebhookLogScalarFieldEnum[]
  }

  /**
   * WebhookLog findFirstOrThrow
   */
  export type WebhookLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookLog
     */
    select?: WebhookLogSelect<ExtArgs> | null
    /**
     * Filter, which WebhookLog to fetch.
     */
    where?: WebhookLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebhookLogs to fetch.
     */
    orderBy?: WebhookLogOrderByWithRelationInput | WebhookLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WebhookLogs.
     */
    cursor?: WebhookLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebhookLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebhookLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WebhookLogs.
     */
    distinct?: WebhookLogScalarFieldEnum | WebhookLogScalarFieldEnum[]
  }

  /**
   * WebhookLog findMany
   */
  export type WebhookLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookLog
     */
    select?: WebhookLogSelect<ExtArgs> | null
    /**
     * Filter, which WebhookLogs to fetch.
     */
    where?: WebhookLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebhookLogs to fetch.
     */
    orderBy?: WebhookLogOrderByWithRelationInput | WebhookLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WebhookLogs.
     */
    cursor?: WebhookLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebhookLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebhookLogs.
     */
    skip?: number
    distinct?: WebhookLogScalarFieldEnum | WebhookLogScalarFieldEnum[]
  }

  /**
   * WebhookLog create
   */
  export type WebhookLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookLog
     */
    select?: WebhookLogSelect<ExtArgs> | null
    /**
     * The data needed to create a WebhookLog.
     */
    data: XOR<WebhookLogCreateInput, WebhookLogUncheckedCreateInput>
  }

  /**
   * WebhookLog createMany
   */
  export type WebhookLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WebhookLogs.
     */
    data: WebhookLogCreateManyInput | WebhookLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WebhookLog createManyAndReturn
   */
  export type WebhookLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookLog
     */
    select?: WebhookLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many WebhookLogs.
     */
    data: WebhookLogCreateManyInput | WebhookLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WebhookLog update
   */
  export type WebhookLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookLog
     */
    select?: WebhookLogSelect<ExtArgs> | null
    /**
     * The data needed to update a WebhookLog.
     */
    data: XOR<WebhookLogUpdateInput, WebhookLogUncheckedUpdateInput>
    /**
     * Choose, which WebhookLog to update.
     */
    where: WebhookLogWhereUniqueInput
  }

  /**
   * WebhookLog updateMany
   */
  export type WebhookLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WebhookLogs.
     */
    data: XOR<WebhookLogUpdateManyMutationInput, WebhookLogUncheckedUpdateManyInput>
    /**
     * Filter which WebhookLogs to update
     */
    where?: WebhookLogWhereInput
  }

  /**
   * WebhookLog upsert
   */
  export type WebhookLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookLog
     */
    select?: WebhookLogSelect<ExtArgs> | null
    /**
     * The filter to search for the WebhookLog to update in case it exists.
     */
    where: WebhookLogWhereUniqueInput
    /**
     * In case the WebhookLog found by the `where` argument doesn't exist, create a new WebhookLog with this data.
     */
    create: XOR<WebhookLogCreateInput, WebhookLogUncheckedCreateInput>
    /**
     * In case the WebhookLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WebhookLogUpdateInput, WebhookLogUncheckedUpdateInput>
  }

  /**
   * WebhookLog delete
   */
  export type WebhookLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookLog
     */
    select?: WebhookLogSelect<ExtArgs> | null
    /**
     * Filter which WebhookLog to delete.
     */
    where: WebhookLogWhereUniqueInput
  }

  /**
   * WebhookLog deleteMany
   */
  export type WebhookLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WebhookLogs to delete
     */
    where?: WebhookLogWhereInput
  }

  /**
   * WebhookLog without action
   */
  export type WebhookLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookLog
     */
    select?: WebhookLogSelect<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const MerchantScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MerchantScalarFieldEnum = (typeof MerchantScalarFieldEnum)[keyof typeof MerchantScalarFieldEnum]


  export const POSIntegrationScalarFieldEnum: {
    id: 'id',
    merchantId: 'merchantId',
    provider: 'provider',
    accessToken: 'accessToken',
    refreshToken: 'refreshToken',
    providerMerchantId: 'providerMerchantId',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type POSIntegrationScalarFieldEnum = (typeof POSIntegrationScalarFieldEnum)[keyof typeof POSIntegrationScalarFieldEnum]


  export const LocationScalarFieldEnum: {
    id: 'id',
    merchantId: 'merchantId',
    posIntegrationId: 'posIntegrationId',
    posLocationId: 'posLocationId',
    name: 'name',
    address: 'address',
    city: 'city',
    state: 'state',
    zipCode: 'zipCode',
    country: 'country',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LocationScalarFieldEnum = (typeof LocationScalarFieldEnum)[keyof typeof LocationScalarFieldEnum]


  export const CustomerScalarFieldEnum: {
    id: 'id',
    phoneNumber: 'phoneNumber',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CustomerScalarFieldEnum = (typeof CustomerScalarFieldEnum)[keyof typeof CustomerScalarFieldEnum]


  export const LinkedCardScalarFieldEnum: {
    id: 'id',
    customerId: 'customerId',
    cardFingerprint: 'cardFingerprint',
    last4: 'last4',
    brand: 'brand',
    zipCode: 'zipCode',
    posProvider: 'posProvider',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LinkedCardScalarFieldEnum = (typeof LinkedCardScalarFieldEnum)[keyof typeof LinkedCardScalarFieldEnum]


  export const TransactionScalarFieldEnum: {
    id: 'id',
    merchantId: 'merchantId',
    customerId: 'customerId',
    locationId: 'locationId',
    posProvider: 'posProvider',
    posTransactionId: 'posTransactionId',
    posLocationId: 'posLocationId',
    amount: 'amount',
    pointsEarned: 'pointsEarned',
    status: 'status',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TransactionScalarFieldEnum = (typeof TransactionScalarFieldEnum)[keyof typeof TransactionScalarFieldEnum]


  export const CustomerBalanceScalarFieldEnum: {
    id: 'id',
    customerId: 'customerId',
    merchantId: 'merchantId',
    points: 'points',
    updatedAt: 'updatedAt'
  };

  export type CustomerBalanceScalarFieldEnum = (typeof CustomerBalanceScalarFieldEnum)[keyof typeof CustomerBalanceScalarFieldEnum]


  export const RewardScalarFieldEnum: {
    id: 'id',
    merchantId: 'merchantId',
    name: 'name',
    description: 'description',
    type: 'type',
    pointsCost: 'pointsCost',
    itemName: 'itemName',
    itemCount: 'itemCount',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RewardScalarFieldEnum = (typeof RewardScalarFieldEnum)[keyof typeof RewardScalarFieldEnum]


  export const POSRewardItemScalarFieldEnum: {
    id: 'id',
    rewardId: 'rewardId',
    posProvider: 'posProvider',
    posItemId: 'posItemId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type POSRewardItemScalarFieldEnum = (typeof POSRewardItemScalarFieldEnum)[keyof typeof POSRewardItemScalarFieldEnum]


  export const RedemptionScalarFieldEnum: {
    id: 'id',
    customerId: 'customerId',
    merchantId: 'merchantId',
    rewardId: 'rewardId',
    qrToken: 'qrToken',
    pinCode: 'pinCode',
    status: 'status',
    pointsDeducted: 'pointsDeducted',
    redeemedAt: 'redeemedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RedemptionScalarFieldEnum = (typeof RedemptionScalarFieldEnum)[keyof typeof RedemptionScalarFieldEnum]


  export const CustomerItemCountScalarFieldEnum: {
    id: 'id',
    customerId: 'customerId',
    merchantId: 'merchantId',
    rewardId: 'rewardId',
    itemName: 'itemName',
    count: 'count',
    updatedAt: 'updatedAt'
  };

  export type CustomerItemCountScalarFieldEnum = (typeof CustomerItemCountScalarFieldEnum)[keyof typeof CustomerItemCountScalarFieldEnum]


  export const LedgerEntryScalarFieldEnum: {
    id: 'id',
    customerId: 'customerId',
    merchantId: 'merchantId',
    type: 'type',
    points: 'points',
    transactionId: 'transactionId',
    redemptionId: 'redemptionId',
    createdAt: 'createdAt'
  };

  export type LedgerEntryScalarFieldEnum = (typeof LedgerEntryScalarFieldEnum)[keyof typeof LedgerEntryScalarFieldEnum]


  export const WebhookLogScalarFieldEnum: {
    id: 'id',
    provider: 'provider',
    eventType: 'eventType',
    payload: 'payload',
    signature: 'signature',
    status: 'status',
    errorMessage: 'errorMessage',
    processedAt: 'processedAt',
    createdAt: 'createdAt'
  };

  export type WebhookLogScalarFieldEnum = (typeof WebhookLogScalarFieldEnum)[keyof typeof WebhookLogScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'POSProvider'
   */
  export type EnumPOSProviderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'POSProvider'>
    


  /**
   * Reference to a field of type 'POSProvider[]'
   */
  export type ListEnumPOSProviderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'POSProvider[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'TransactionStatus'
   */
  export type EnumTransactionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionStatus'>
    


  /**
   * Reference to a field of type 'TransactionStatus[]'
   */
  export type ListEnumTransactionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionStatus[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'RewardType'
   */
  export type EnumRewardTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RewardType'>
    


  /**
   * Reference to a field of type 'RewardType[]'
   */
  export type ListEnumRewardTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RewardType[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'RedemptionStatus'
   */
  export type EnumRedemptionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RedemptionStatus'>
    


  /**
   * Reference to a field of type 'RedemptionStatus[]'
   */
  export type ListEnumRedemptionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RedemptionStatus[]'>
    


  /**
   * Reference to a field of type 'LedgerEntryType'
   */
  export type EnumLedgerEntryTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LedgerEntryType'>
    


  /**
   * Reference to a field of type 'LedgerEntryType[]'
   */
  export type ListEnumLedgerEntryTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LedgerEntryType[]'>
    


  /**
   * Reference to a field of type 'WebhookStatus'
   */
  export type EnumWebhookStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WebhookStatus'>
    


  /**
   * Reference to a field of type 'WebhookStatus[]'
   */
  export type ListEnumWebhookStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WebhookStatus[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type MerchantWhereInput = {
    AND?: MerchantWhereInput | MerchantWhereInput[]
    OR?: MerchantWhereInput[]
    NOT?: MerchantWhereInput | MerchantWhereInput[]
    id?: StringFilter<"Merchant"> | string
    email?: StringFilter<"Merchant"> | string
    password?: StringFilter<"Merchant"> | string
    name?: StringFilter<"Merchant"> | string
    createdAt?: DateTimeFilter<"Merchant"> | Date | string
    updatedAt?: DateTimeFilter<"Merchant"> | Date | string
    posIntegrations?: POSIntegrationListRelationFilter
    locations?: LocationListRelationFilter
    rewards?: RewardListRelationFilter
    transactions?: TransactionListRelationFilter
    redemptions?: RedemptionListRelationFilter
    customerBalances?: CustomerBalanceListRelationFilter
    itemCounts?: CustomerItemCountListRelationFilter
    ledgerEntries?: LedgerEntryListRelationFilter
  }

  export type MerchantOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    posIntegrations?: POSIntegrationOrderByRelationAggregateInput
    locations?: LocationOrderByRelationAggregateInput
    rewards?: RewardOrderByRelationAggregateInput
    transactions?: TransactionOrderByRelationAggregateInput
    redemptions?: RedemptionOrderByRelationAggregateInput
    customerBalances?: CustomerBalanceOrderByRelationAggregateInput
    itemCounts?: CustomerItemCountOrderByRelationAggregateInput
    ledgerEntries?: LedgerEntryOrderByRelationAggregateInput
  }

  export type MerchantWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: MerchantWhereInput | MerchantWhereInput[]
    OR?: MerchantWhereInput[]
    NOT?: MerchantWhereInput | MerchantWhereInput[]
    password?: StringFilter<"Merchant"> | string
    name?: StringFilter<"Merchant"> | string
    createdAt?: DateTimeFilter<"Merchant"> | Date | string
    updatedAt?: DateTimeFilter<"Merchant"> | Date | string
    posIntegrations?: POSIntegrationListRelationFilter
    locations?: LocationListRelationFilter
    rewards?: RewardListRelationFilter
    transactions?: TransactionListRelationFilter
    redemptions?: RedemptionListRelationFilter
    customerBalances?: CustomerBalanceListRelationFilter
    itemCounts?: CustomerItemCountListRelationFilter
    ledgerEntries?: LedgerEntryListRelationFilter
  }, "id" | "email">

  export type MerchantOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MerchantCountOrderByAggregateInput
    _max?: MerchantMaxOrderByAggregateInput
    _min?: MerchantMinOrderByAggregateInput
  }

  export type MerchantScalarWhereWithAggregatesInput = {
    AND?: MerchantScalarWhereWithAggregatesInput | MerchantScalarWhereWithAggregatesInput[]
    OR?: MerchantScalarWhereWithAggregatesInput[]
    NOT?: MerchantScalarWhereWithAggregatesInput | MerchantScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Merchant"> | string
    email?: StringWithAggregatesFilter<"Merchant"> | string
    password?: StringWithAggregatesFilter<"Merchant"> | string
    name?: StringWithAggregatesFilter<"Merchant"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Merchant"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Merchant"> | Date | string
  }

  export type POSIntegrationWhereInput = {
    AND?: POSIntegrationWhereInput | POSIntegrationWhereInput[]
    OR?: POSIntegrationWhereInput[]
    NOT?: POSIntegrationWhereInput | POSIntegrationWhereInput[]
    id?: StringFilter<"POSIntegration"> | string
    merchantId?: StringFilter<"POSIntegration"> | string
    provider?: EnumPOSProviderFilter<"POSIntegration"> | $Enums.POSProvider
    accessToken?: StringFilter<"POSIntegration"> | string
    refreshToken?: StringNullableFilter<"POSIntegration"> | string | null
    providerMerchantId?: StringFilter<"POSIntegration"> | string
    expiresAt?: DateTimeNullableFilter<"POSIntegration"> | Date | string | null
    createdAt?: DateTimeFilter<"POSIntegration"> | Date | string
    updatedAt?: DateTimeFilter<"POSIntegration"> | Date | string
    merchant?: XOR<MerchantRelationFilter, MerchantWhereInput>
    locations?: LocationListRelationFilter
  }

  export type POSIntegrationOrderByWithRelationInput = {
    id?: SortOrder
    merchantId?: SortOrder
    provider?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrderInput | SortOrder
    providerMerchantId?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    merchant?: MerchantOrderByWithRelationInput
    locations?: LocationOrderByRelationAggregateInput
  }

  export type POSIntegrationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    merchantId_provider?: POSIntegrationMerchantIdProviderCompoundUniqueInput
    AND?: POSIntegrationWhereInput | POSIntegrationWhereInput[]
    OR?: POSIntegrationWhereInput[]
    NOT?: POSIntegrationWhereInput | POSIntegrationWhereInput[]
    merchantId?: StringFilter<"POSIntegration"> | string
    provider?: EnumPOSProviderFilter<"POSIntegration"> | $Enums.POSProvider
    accessToken?: StringFilter<"POSIntegration"> | string
    refreshToken?: StringNullableFilter<"POSIntegration"> | string | null
    providerMerchantId?: StringFilter<"POSIntegration"> | string
    expiresAt?: DateTimeNullableFilter<"POSIntegration"> | Date | string | null
    createdAt?: DateTimeFilter<"POSIntegration"> | Date | string
    updatedAt?: DateTimeFilter<"POSIntegration"> | Date | string
    merchant?: XOR<MerchantRelationFilter, MerchantWhereInput>
    locations?: LocationListRelationFilter
  }, "id" | "merchantId_provider">

  export type POSIntegrationOrderByWithAggregationInput = {
    id?: SortOrder
    merchantId?: SortOrder
    provider?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrderInput | SortOrder
    providerMerchantId?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: POSIntegrationCountOrderByAggregateInput
    _max?: POSIntegrationMaxOrderByAggregateInput
    _min?: POSIntegrationMinOrderByAggregateInput
  }

  export type POSIntegrationScalarWhereWithAggregatesInput = {
    AND?: POSIntegrationScalarWhereWithAggregatesInput | POSIntegrationScalarWhereWithAggregatesInput[]
    OR?: POSIntegrationScalarWhereWithAggregatesInput[]
    NOT?: POSIntegrationScalarWhereWithAggregatesInput | POSIntegrationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"POSIntegration"> | string
    merchantId?: StringWithAggregatesFilter<"POSIntegration"> | string
    provider?: EnumPOSProviderWithAggregatesFilter<"POSIntegration"> | $Enums.POSProvider
    accessToken?: StringWithAggregatesFilter<"POSIntegration"> | string
    refreshToken?: StringNullableWithAggregatesFilter<"POSIntegration"> | string | null
    providerMerchantId?: StringWithAggregatesFilter<"POSIntegration"> | string
    expiresAt?: DateTimeNullableWithAggregatesFilter<"POSIntegration"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"POSIntegration"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"POSIntegration"> | Date | string
  }

  export type LocationWhereInput = {
    AND?: LocationWhereInput | LocationWhereInput[]
    OR?: LocationWhereInput[]
    NOT?: LocationWhereInput | LocationWhereInput[]
    id?: StringFilter<"Location"> | string
    merchantId?: StringFilter<"Location"> | string
    posIntegrationId?: StringFilter<"Location"> | string
    posLocationId?: StringFilter<"Location"> | string
    name?: StringFilter<"Location"> | string
    address?: StringNullableFilter<"Location"> | string | null
    city?: StringNullableFilter<"Location"> | string | null
    state?: StringNullableFilter<"Location"> | string | null
    zipCode?: StringNullableFilter<"Location"> | string | null
    country?: StringNullableFilter<"Location"> | string | null
    createdAt?: DateTimeFilter<"Location"> | Date | string
    updatedAt?: DateTimeFilter<"Location"> | Date | string
    merchant?: XOR<MerchantRelationFilter, MerchantWhereInput>
    posIntegration?: XOR<POSIntegrationRelationFilter, POSIntegrationWhereInput>
    transactions?: TransactionListRelationFilter
  }

  export type LocationOrderByWithRelationInput = {
    id?: SortOrder
    merchantId?: SortOrder
    posIntegrationId?: SortOrder
    posLocationId?: SortOrder
    name?: SortOrder
    address?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    zipCode?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    merchant?: MerchantOrderByWithRelationInput
    posIntegration?: POSIntegrationOrderByWithRelationInput
    transactions?: TransactionOrderByRelationAggregateInput
  }

  export type LocationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    posIntegrationId_posLocationId?: LocationPosIntegrationIdPosLocationIdCompoundUniqueInput
    AND?: LocationWhereInput | LocationWhereInput[]
    OR?: LocationWhereInput[]
    NOT?: LocationWhereInput | LocationWhereInput[]
    merchantId?: StringFilter<"Location"> | string
    posIntegrationId?: StringFilter<"Location"> | string
    posLocationId?: StringFilter<"Location"> | string
    name?: StringFilter<"Location"> | string
    address?: StringNullableFilter<"Location"> | string | null
    city?: StringNullableFilter<"Location"> | string | null
    state?: StringNullableFilter<"Location"> | string | null
    zipCode?: StringNullableFilter<"Location"> | string | null
    country?: StringNullableFilter<"Location"> | string | null
    createdAt?: DateTimeFilter<"Location"> | Date | string
    updatedAt?: DateTimeFilter<"Location"> | Date | string
    merchant?: XOR<MerchantRelationFilter, MerchantWhereInput>
    posIntegration?: XOR<POSIntegrationRelationFilter, POSIntegrationWhereInput>
    transactions?: TransactionListRelationFilter
  }, "id" | "posIntegrationId_posLocationId">

  export type LocationOrderByWithAggregationInput = {
    id?: SortOrder
    merchantId?: SortOrder
    posIntegrationId?: SortOrder
    posLocationId?: SortOrder
    name?: SortOrder
    address?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    zipCode?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LocationCountOrderByAggregateInput
    _max?: LocationMaxOrderByAggregateInput
    _min?: LocationMinOrderByAggregateInput
  }

  export type LocationScalarWhereWithAggregatesInput = {
    AND?: LocationScalarWhereWithAggregatesInput | LocationScalarWhereWithAggregatesInput[]
    OR?: LocationScalarWhereWithAggregatesInput[]
    NOT?: LocationScalarWhereWithAggregatesInput | LocationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Location"> | string
    merchantId?: StringWithAggregatesFilter<"Location"> | string
    posIntegrationId?: StringWithAggregatesFilter<"Location"> | string
    posLocationId?: StringWithAggregatesFilter<"Location"> | string
    name?: StringWithAggregatesFilter<"Location"> | string
    address?: StringNullableWithAggregatesFilter<"Location"> | string | null
    city?: StringNullableWithAggregatesFilter<"Location"> | string | null
    state?: StringNullableWithAggregatesFilter<"Location"> | string | null
    zipCode?: StringNullableWithAggregatesFilter<"Location"> | string | null
    country?: StringNullableWithAggregatesFilter<"Location"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Location"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Location"> | Date | string
  }

  export type CustomerWhereInput = {
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    id?: StringFilter<"Customer"> | string
    phoneNumber?: StringNullableFilter<"Customer"> | string | null
    createdAt?: DateTimeFilter<"Customer"> | Date | string
    updatedAt?: DateTimeFilter<"Customer"> | Date | string
    linkedCards?: LinkedCardListRelationFilter
    transactions?: TransactionListRelationFilter
    customerBalances?: CustomerBalanceListRelationFilter
    redemptions?: RedemptionListRelationFilter
    ledgerEntries?: LedgerEntryListRelationFilter
    itemCounts?: CustomerItemCountListRelationFilter
  }

  export type CustomerOrderByWithRelationInput = {
    id?: SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    linkedCards?: LinkedCardOrderByRelationAggregateInput
    transactions?: TransactionOrderByRelationAggregateInput
    customerBalances?: CustomerBalanceOrderByRelationAggregateInput
    redemptions?: RedemptionOrderByRelationAggregateInput
    ledgerEntries?: LedgerEntryOrderByRelationAggregateInput
    itemCounts?: CustomerItemCountOrderByRelationAggregateInput
  }

  export type CustomerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    phoneNumber?: string
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    createdAt?: DateTimeFilter<"Customer"> | Date | string
    updatedAt?: DateTimeFilter<"Customer"> | Date | string
    linkedCards?: LinkedCardListRelationFilter
    transactions?: TransactionListRelationFilter
    customerBalances?: CustomerBalanceListRelationFilter
    redemptions?: RedemptionListRelationFilter
    ledgerEntries?: LedgerEntryListRelationFilter
    itemCounts?: CustomerItemCountListRelationFilter
  }, "id" | "phoneNumber">

  export type CustomerOrderByWithAggregationInput = {
    id?: SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CustomerCountOrderByAggregateInput
    _max?: CustomerMaxOrderByAggregateInput
    _min?: CustomerMinOrderByAggregateInput
  }

  export type CustomerScalarWhereWithAggregatesInput = {
    AND?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    OR?: CustomerScalarWhereWithAggregatesInput[]
    NOT?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Customer"> | string
    phoneNumber?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Customer"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Customer"> | Date | string
  }

  export type LinkedCardWhereInput = {
    AND?: LinkedCardWhereInput | LinkedCardWhereInput[]
    OR?: LinkedCardWhereInput[]
    NOT?: LinkedCardWhereInput | LinkedCardWhereInput[]
    id?: StringFilter<"LinkedCard"> | string
    customerId?: StringFilter<"LinkedCard"> | string
    cardFingerprint?: StringFilter<"LinkedCard"> | string
    last4?: StringFilter<"LinkedCard"> | string
    brand?: StringNullableFilter<"LinkedCard"> | string | null
    zipCode?: StringNullableFilter<"LinkedCard"> | string | null
    posProvider?: EnumPOSProviderFilter<"LinkedCard"> | $Enums.POSProvider
    createdAt?: DateTimeFilter<"LinkedCard"> | Date | string
    updatedAt?: DateTimeFilter<"LinkedCard"> | Date | string
    customer?: XOR<CustomerRelationFilter, CustomerWhereInput>
  }

  export type LinkedCardOrderByWithRelationInput = {
    id?: SortOrder
    customerId?: SortOrder
    cardFingerprint?: SortOrder
    last4?: SortOrder
    brand?: SortOrderInput | SortOrder
    zipCode?: SortOrderInput | SortOrder
    posProvider?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    customer?: CustomerOrderByWithRelationInput
  }

  export type LinkedCardWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    cardFingerprint_posProvider?: LinkedCardCardFingerprintPosProviderCompoundUniqueInput
    AND?: LinkedCardWhereInput | LinkedCardWhereInput[]
    OR?: LinkedCardWhereInput[]
    NOT?: LinkedCardWhereInput | LinkedCardWhereInput[]
    customerId?: StringFilter<"LinkedCard"> | string
    cardFingerprint?: StringFilter<"LinkedCard"> | string
    last4?: StringFilter<"LinkedCard"> | string
    brand?: StringNullableFilter<"LinkedCard"> | string | null
    zipCode?: StringNullableFilter<"LinkedCard"> | string | null
    posProvider?: EnumPOSProviderFilter<"LinkedCard"> | $Enums.POSProvider
    createdAt?: DateTimeFilter<"LinkedCard"> | Date | string
    updatedAt?: DateTimeFilter<"LinkedCard"> | Date | string
    customer?: XOR<CustomerRelationFilter, CustomerWhereInput>
  }, "id" | "cardFingerprint_posProvider">

  export type LinkedCardOrderByWithAggregationInput = {
    id?: SortOrder
    customerId?: SortOrder
    cardFingerprint?: SortOrder
    last4?: SortOrder
    brand?: SortOrderInput | SortOrder
    zipCode?: SortOrderInput | SortOrder
    posProvider?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LinkedCardCountOrderByAggregateInput
    _max?: LinkedCardMaxOrderByAggregateInput
    _min?: LinkedCardMinOrderByAggregateInput
  }

  export type LinkedCardScalarWhereWithAggregatesInput = {
    AND?: LinkedCardScalarWhereWithAggregatesInput | LinkedCardScalarWhereWithAggregatesInput[]
    OR?: LinkedCardScalarWhereWithAggregatesInput[]
    NOT?: LinkedCardScalarWhereWithAggregatesInput | LinkedCardScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LinkedCard"> | string
    customerId?: StringWithAggregatesFilter<"LinkedCard"> | string
    cardFingerprint?: StringWithAggregatesFilter<"LinkedCard"> | string
    last4?: StringWithAggregatesFilter<"LinkedCard"> | string
    brand?: StringNullableWithAggregatesFilter<"LinkedCard"> | string | null
    zipCode?: StringNullableWithAggregatesFilter<"LinkedCard"> | string | null
    posProvider?: EnumPOSProviderWithAggregatesFilter<"LinkedCard"> | $Enums.POSProvider
    createdAt?: DateTimeWithAggregatesFilter<"LinkedCard"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LinkedCard"> | Date | string
  }

  export type TransactionWhereInput = {
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    id?: StringFilter<"Transaction"> | string
    merchantId?: StringFilter<"Transaction"> | string
    customerId?: StringNullableFilter<"Transaction"> | string | null
    locationId?: StringNullableFilter<"Transaction"> | string | null
    posProvider?: EnumPOSProviderFilter<"Transaction"> | $Enums.POSProvider
    posTransactionId?: StringFilter<"Transaction"> | string
    posLocationId?: StringNullableFilter<"Transaction"> | string | null
    amount?: DecimalFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    pointsEarned?: IntFilter<"Transaction"> | number
    status?: EnumTransactionStatusFilter<"Transaction"> | $Enums.TransactionStatus
    metadata?: JsonNullableFilter<"Transaction">
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeFilter<"Transaction"> | Date | string
    merchant?: XOR<MerchantRelationFilter, MerchantWhereInput>
    customer?: XOR<CustomerNullableRelationFilter, CustomerWhereInput> | null
    location?: XOR<LocationNullableRelationFilter, LocationWhereInput> | null
    ledgerEntries?: LedgerEntryListRelationFilter
  }

  export type TransactionOrderByWithRelationInput = {
    id?: SortOrder
    merchantId?: SortOrder
    customerId?: SortOrderInput | SortOrder
    locationId?: SortOrderInput | SortOrder
    posProvider?: SortOrder
    posTransactionId?: SortOrder
    posLocationId?: SortOrderInput | SortOrder
    amount?: SortOrder
    pointsEarned?: SortOrder
    status?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    merchant?: MerchantOrderByWithRelationInput
    customer?: CustomerOrderByWithRelationInput
    location?: LocationOrderByWithRelationInput
    ledgerEntries?: LedgerEntryOrderByRelationAggregateInput
  }

  export type TransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    posProvider_posTransactionId?: TransactionPosProviderPosTransactionIdCompoundUniqueInput
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    merchantId?: StringFilter<"Transaction"> | string
    customerId?: StringNullableFilter<"Transaction"> | string | null
    locationId?: StringNullableFilter<"Transaction"> | string | null
    posProvider?: EnumPOSProviderFilter<"Transaction"> | $Enums.POSProvider
    posTransactionId?: StringFilter<"Transaction"> | string
    posLocationId?: StringNullableFilter<"Transaction"> | string | null
    amount?: DecimalFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    pointsEarned?: IntFilter<"Transaction"> | number
    status?: EnumTransactionStatusFilter<"Transaction"> | $Enums.TransactionStatus
    metadata?: JsonNullableFilter<"Transaction">
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeFilter<"Transaction"> | Date | string
    merchant?: XOR<MerchantRelationFilter, MerchantWhereInput>
    customer?: XOR<CustomerNullableRelationFilter, CustomerWhereInput> | null
    location?: XOR<LocationNullableRelationFilter, LocationWhereInput> | null
    ledgerEntries?: LedgerEntryListRelationFilter
  }, "id" | "posProvider_posTransactionId">

  export type TransactionOrderByWithAggregationInput = {
    id?: SortOrder
    merchantId?: SortOrder
    customerId?: SortOrderInput | SortOrder
    locationId?: SortOrderInput | SortOrder
    posProvider?: SortOrder
    posTransactionId?: SortOrder
    posLocationId?: SortOrderInput | SortOrder
    amount?: SortOrder
    pointsEarned?: SortOrder
    status?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TransactionCountOrderByAggregateInput
    _avg?: TransactionAvgOrderByAggregateInput
    _max?: TransactionMaxOrderByAggregateInput
    _min?: TransactionMinOrderByAggregateInput
    _sum?: TransactionSumOrderByAggregateInput
  }

  export type TransactionScalarWhereWithAggregatesInput = {
    AND?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    OR?: TransactionScalarWhereWithAggregatesInput[]
    NOT?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Transaction"> | string
    merchantId?: StringWithAggregatesFilter<"Transaction"> | string
    customerId?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    locationId?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    posProvider?: EnumPOSProviderWithAggregatesFilter<"Transaction"> | $Enums.POSProvider
    posTransactionId?: StringWithAggregatesFilter<"Transaction"> | string
    posLocationId?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    amount?: DecimalWithAggregatesFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    pointsEarned?: IntWithAggregatesFilter<"Transaction"> | number
    status?: EnumTransactionStatusWithAggregatesFilter<"Transaction"> | $Enums.TransactionStatus
    metadata?: JsonNullableWithAggregatesFilter<"Transaction">
    createdAt?: DateTimeWithAggregatesFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Transaction"> | Date | string
  }

  export type CustomerBalanceWhereInput = {
    AND?: CustomerBalanceWhereInput | CustomerBalanceWhereInput[]
    OR?: CustomerBalanceWhereInput[]
    NOT?: CustomerBalanceWhereInput | CustomerBalanceWhereInput[]
    id?: StringFilter<"CustomerBalance"> | string
    customerId?: StringFilter<"CustomerBalance"> | string
    merchantId?: StringFilter<"CustomerBalance"> | string
    points?: IntFilter<"CustomerBalance"> | number
    updatedAt?: DateTimeFilter<"CustomerBalance"> | Date | string
    customer?: XOR<CustomerRelationFilter, CustomerWhereInput>
    merchant?: XOR<MerchantRelationFilter, MerchantWhereInput>
  }

  export type CustomerBalanceOrderByWithRelationInput = {
    id?: SortOrder
    customerId?: SortOrder
    merchantId?: SortOrder
    points?: SortOrder
    updatedAt?: SortOrder
    customer?: CustomerOrderByWithRelationInput
    merchant?: MerchantOrderByWithRelationInput
  }

  export type CustomerBalanceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    customerId_merchantId?: CustomerBalanceCustomerIdMerchantIdCompoundUniqueInput
    AND?: CustomerBalanceWhereInput | CustomerBalanceWhereInput[]
    OR?: CustomerBalanceWhereInput[]
    NOT?: CustomerBalanceWhereInput | CustomerBalanceWhereInput[]
    customerId?: StringFilter<"CustomerBalance"> | string
    merchantId?: StringFilter<"CustomerBalance"> | string
    points?: IntFilter<"CustomerBalance"> | number
    updatedAt?: DateTimeFilter<"CustomerBalance"> | Date | string
    customer?: XOR<CustomerRelationFilter, CustomerWhereInput>
    merchant?: XOR<MerchantRelationFilter, MerchantWhereInput>
  }, "id" | "customerId_merchantId">

  export type CustomerBalanceOrderByWithAggregationInput = {
    id?: SortOrder
    customerId?: SortOrder
    merchantId?: SortOrder
    points?: SortOrder
    updatedAt?: SortOrder
    _count?: CustomerBalanceCountOrderByAggregateInput
    _avg?: CustomerBalanceAvgOrderByAggregateInput
    _max?: CustomerBalanceMaxOrderByAggregateInput
    _min?: CustomerBalanceMinOrderByAggregateInput
    _sum?: CustomerBalanceSumOrderByAggregateInput
  }

  export type CustomerBalanceScalarWhereWithAggregatesInput = {
    AND?: CustomerBalanceScalarWhereWithAggregatesInput | CustomerBalanceScalarWhereWithAggregatesInput[]
    OR?: CustomerBalanceScalarWhereWithAggregatesInput[]
    NOT?: CustomerBalanceScalarWhereWithAggregatesInput | CustomerBalanceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CustomerBalance"> | string
    customerId?: StringWithAggregatesFilter<"CustomerBalance"> | string
    merchantId?: StringWithAggregatesFilter<"CustomerBalance"> | string
    points?: IntWithAggregatesFilter<"CustomerBalance"> | number
    updatedAt?: DateTimeWithAggregatesFilter<"CustomerBalance"> | Date | string
  }

  export type RewardWhereInput = {
    AND?: RewardWhereInput | RewardWhereInput[]
    OR?: RewardWhereInput[]
    NOT?: RewardWhereInput | RewardWhereInput[]
    id?: StringFilter<"Reward"> | string
    merchantId?: StringFilter<"Reward"> | string
    name?: StringFilter<"Reward"> | string
    description?: StringNullableFilter<"Reward"> | string | null
    type?: EnumRewardTypeFilter<"Reward"> | $Enums.RewardType
    pointsCost?: IntNullableFilter<"Reward"> | number | null
    itemName?: StringNullableFilter<"Reward"> | string | null
    itemCount?: IntNullableFilter<"Reward"> | number | null
    isActive?: BoolFilter<"Reward"> | boolean
    createdAt?: DateTimeFilter<"Reward"> | Date | string
    updatedAt?: DateTimeFilter<"Reward"> | Date | string
    merchant?: XOR<MerchantRelationFilter, MerchantWhereInput>
    posRewardItems?: POSRewardItemListRelationFilter
    redemptions?: RedemptionListRelationFilter
    itemCounts?: CustomerItemCountListRelationFilter
  }

  export type RewardOrderByWithRelationInput = {
    id?: SortOrder
    merchantId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    pointsCost?: SortOrderInput | SortOrder
    itemName?: SortOrderInput | SortOrder
    itemCount?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    merchant?: MerchantOrderByWithRelationInput
    posRewardItems?: POSRewardItemOrderByRelationAggregateInput
    redemptions?: RedemptionOrderByRelationAggregateInput
    itemCounts?: CustomerItemCountOrderByRelationAggregateInput
  }

  export type RewardWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RewardWhereInput | RewardWhereInput[]
    OR?: RewardWhereInput[]
    NOT?: RewardWhereInput | RewardWhereInput[]
    merchantId?: StringFilter<"Reward"> | string
    name?: StringFilter<"Reward"> | string
    description?: StringNullableFilter<"Reward"> | string | null
    type?: EnumRewardTypeFilter<"Reward"> | $Enums.RewardType
    pointsCost?: IntNullableFilter<"Reward"> | number | null
    itemName?: StringNullableFilter<"Reward"> | string | null
    itemCount?: IntNullableFilter<"Reward"> | number | null
    isActive?: BoolFilter<"Reward"> | boolean
    createdAt?: DateTimeFilter<"Reward"> | Date | string
    updatedAt?: DateTimeFilter<"Reward"> | Date | string
    merchant?: XOR<MerchantRelationFilter, MerchantWhereInput>
    posRewardItems?: POSRewardItemListRelationFilter
    redemptions?: RedemptionListRelationFilter
    itemCounts?: CustomerItemCountListRelationFilter
  }, "id">

  export type RewardOrderByWithAggregationInput = {
    id?: SortOrder
    merchantId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    pointsCost?: SortOrderInput | SortOrder
    itemName?: SortOrderInput | SortOrder
    itemCount?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RewardCountOrderByAggregateInput
    _avg?: RewardAvgOrderByAggregateInput
    _max?: RewardMaxOrderByAggregateInput
    _min?: RewardMinOrderByAggregateInput
    _sum?: RewardSumOrderByAggregateInput
  }

  export type RewardScalarWhereWithAggregatesInput = {
    AND?: RewardScalarWhereWithAggregatesInput | RewardScalarWhereWithAggregatesInput[]
    OR?: RewardScalarWhereWithAggregatesInput[]
    NOT?: RewardScalarWhereWithAggregatesInput | RewardScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Reward"> | string
    merchantId?: StringWithAggregatesFilter<"Reward"> | string
    name?: StringWithAggregatesFilter<"Reward"> | string
    description?: StringNullableWithAggregatesFilter<"Reward"> | string | null
    type?: EnumRewardTypeWithAggregatesFilter<"Reward"> | $Enums.RewardType
    pointsCost?: IntNullableWithAggregatesFilter<"Reward"> | number | null
    itemName?: StringNullableWithAggregatesFilter<"Reward"> | string | null
    itemCount?: IntNullableWithAggregatesFilter<"Reward"> | number | null
    isActive?: BoolWithAggregatesFilter<"Reward"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Reward"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Reward"> | Date | string
  }

  export type POSRewardItemWhereInput = {
    AND?: POSRewardItemWhereInput | POSRewardItemWhereInput[]
    OR?: POSRewardItemWhereInput[]
    NOT?: POSRewardItemWhereInput | POSRewardItemWhereInput[]
    id?: StringFilter<"POSRewardItem"> | string
    rewardId?: StringFilter<"POSRewardItem"> | string
    posProvider?: EnumPOSProviderFilter<"POSRewardItem"> | $Enums.POSProvider
    posItemId?: StringFilter<"POSRewardItem"> | string
    createdAt?: DateTimeFilter<"POSRewardItem"> | Date | string
    updatedAt?: DateTimeFilter<"POSRewardItem"> | Date | string
    reward?: XOR<RewardRelationFilter, RewardWhereInput>
  }

  export type POSRewardItemOrderByWithRelationInput = {
    id?: SortOrder
    rewardId?: SortOrder
    posProvider?: SortOrder
    posItemId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    reward?: RewardOrderByWithRelationInput
  }

  export type POSRewardItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    rewardId_posProvider?: POSRewardItemRewardIdPosProviderCompoundUniqueInput
    AND?: POSRewardItemWhereInput | POSRewardItemWhereInput[]
    OR?: POSRewardItemWhereInput[]
    NOT?: POSRewardItemWhereInput | POSRewardItemWhereInput[]
    rewardId?: StringFilter<"POSRewardItem"> | string
    posProvider?: EnumPOSProviderFilter<"POSRewardItem"> | $Enums.POSProvider
    posItemId?: StringFilter<"POSRewardItem"> | string
    createdAt?: DateTimeFilter<"POSRewardItem"> | Date | string
    updatedAt?: DateTimeFilter<"POSRewardItem"> | Date | string
    reward?: XOR<RewardRelationFilter, RewardWhereInput>
  }, "id" | "rewardId_posProvider">

  export type POSRewardItemOrderByWithAggregationInput = {
    id?: SortOrder
    rewardId?: SortOrder
    posProvider?: SortOrder
    posItemId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: POSRewardItemCountOrderByAggregateInput
    _max?: POSRewardItemMaxOrderByAggregateInput
    _min?: POSRewardItemMinOrderByAggregateInput
  }

  export type POSRewardItemScalarWhereWithAggregatesInput = {
    AND?: POSRewardItemScalarWhereWithAggregatesInput | POSRewardItemScalarWhereWithAggregatesInput[]
    OR?: POSRewardItemScalarWhereWithAggregatesInput[]
    NOT?: POSRewardItemScalarWhereWithAggregatesInput | POSRewardItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"POSRewardItem"> | string
    rewardId?: StringWithAggregatesFilter<"POSRewardItem"> | string
    posProvider?: EnumPOSProviderWithAggregatesFilter<"POSRewardItem"> | $Enums.POSProvider
    posItemId?: StringWithAggregatesFilter<"POSRewardItem"> | string
    createdAt?: DateTimeWithAggregatesFilter<"POSRewardItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"POSRewardItem"> | Date | string
  }

  export type RedemptionWhereInput = {
    AND?: RedemptionWhereInput | RedemptionWhereInput[]
    OR?: RedemptionWhereInput[]
    NOT?: RedemptionWhereInput | RedemptionWhereInput[]
    id?: StringFilter<"Redemption"> | string
    customerId?: StringFilter<"Redemption"> | string
    merchantId?: StringFilter<"Redemption"> | string
    rewardId?: StringFilter<"Redemption"> | string
    qrToken?: StringFilter<"Redemption"> | string
    pinCode?: StringFilter<"Redemption"> | string
    status?: EnumRedemptionStatusFilter<"Redemption"> | $Enums.RedemptionStatus
    pointsDeducted?: IntNullableFilter<"Redemption"> | number | null
    redeemedAt?: DateTimeNullableFilter<"Redemption"> | Date | string | null
    createdAt?: DateTimeFilter<"Redemption"> | Date | string
    updatedAt?: DateTimeFilter<"Redemption"> | Date | string
    customer?: XOR<CustomerRelationFilter, CustomerWhereInput>
    merchant?: XOR<MerchantRelationFilter, MerchantWhereInput>
    reward?: XOR<RewardRelationFilter, RewardWhereInput>
    ledgerEntry?: XOR<LedgerEntryNullableRelationFilter, LedgerEntryWhereInput> | null
  }

  export type RedemptionOrderByWithRelationInput = {
    id?: SortOrder
    customerId?: SortOrder
    merchantId?: SortOrder
    rewardId?: SortOrder
    qrToken?: SortOrder
    pinCode?: SortOrder
    status?: SortOrder
    pointsDeducted?: SortOrderInput | SortOrder
    redeemedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    customer?: CustomerOrderByWithRelationInput
    merchant?: MerchantOrderByWithRelationInput
    reward?: RewardOrderByWithRelationInput
    ledgerEntry?: LedgerEntryOrderByWithRelationInput
  }

  export type RedemptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    qrToken?: string
    pinCode?: string
    AND?: RedemptionWhereInput | RedemptionWhereInput[]
    OR?: RedemptionWhereInput[]
    NOT?: RedemptionWhereInput | RedemptionWhereInput[]
    customerId?: StringFilter<"Redemption"> | string
    merchantId?: StringFilter<"Redemption"> | string
    rewardId?: StringFilter<"Redemption"> | string
    status?: EnumRedemptionStatusFilter<"Redemption"> | $Enums.RedemptionStatus
    pointsDeducted?: IntNullableFilter<"Redemption"> | number | null
    redeemedAt?: DateTimeNullableFilter<"Redemption"> | Date | string | null
    createdAt?: DateTimeFilter<"Redemption"> | Date | string
    updatedAt?: DateTimeFilter<"Redemption"> | Date | string
    customer?: XOR<CustomerRelationFilter, CustomerWhereInput>
    merchant?: XOR<MerchantRelationFilter, MerchantWhereInput>
    reward?: XOR<RewardRelationFilter, RewardWhereInput>
    ledgerEntry?: XOR<LedgerEntryNullableRelationFilter, LedgerEntryWhereInput> | null
  }, "id" | "qrToken" | "pinCode">

  export type RedemptionOrderByWithAggregationInput = {
    id?: SortOrder
    customerId?: SortOrder
    merchantId?: SortOrder
    rewardId?: SortOrder
    qrToken?: SortOrder
    pinCode?: SortOrder
    status?: SortOrder
    pointsDeducted?: SortOrderInput | SortOrder
    redeemedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RedemptionCountOrderByAggregateInput
    _avg?: RedemptionAvgOrderByAggregateInput
    _max?: RedemptionMaxOrderByAggregateInput
    _min?: RedemptionMinOrderByAggregateInput
    _sum?: RedemptionSumOrderByAggregateInput
  }

  export type RedemptionScalarWhereWithAggregatesInput = {
    AND?: RedemptionScalarWhereWithAggregatesInput | RedemptionScalarWhereWithAggregatesInput[]
    OR?: RedemptionScalarWhereWithAggregatesInput[]
    NOT?: RedemptionScalarWhereWithAggregatesInput | RedemptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Redemption"> | string
    customerId?: StringWithAggregatesFilter<"Redemption"> | string
    merchantId?: StringWithAggregatesFilter<"Redemption"> | string
    rewardId?: StringWithAggregatesFilter<"Redemption"> | string
    qrToken?: StringWithAggregatesFilter<"Redemption"> | string
    pinCode?: StringWithAggregatesFilter<"Redemption"> | string
    status?: EnumRedemptionStatusWithAggregatesFilter<"Redemption"> | $Enums.RedemptionStatus
    pointsDeducted?: IntNullableWithAggregatesFilter<"Redemption"> | number | null
    redeemedAt?: DateTimeNullableWithAggregatesFilter<"Redemption"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Redemption"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Redemption"> | Date | string
  }

  export type CustomerItemCountWhereInput = {
    AND?: CustomerItemCountWhereInput | CustomerItemCountWhereInput[]
    OR?: CustomerItemCountWhereInput[]
    NOT?: CustomerItemCountWhereInput | CustomerItemCountWhereInput[]
    id?: StringFilter<"CustomerItemCount"> | string
    customerId?: StringFilter<"CustomerItemCount"> | string
    merchantId?: StringFilter<"CustomerItemCount"> | string
    rewardId?: StringFilter<"CustomerItemCount"> | string
    itemName?: StringFilter<"CustomerItemCount"> | string
    count?: IntFilter<"CustomerItemCount"> | number
    updatedAt?: DateTimeFilter<"CustomerItemCount"> | Date | string
    customer?: XOR<CustomerRelationFilter, CustomerWhereInput>
    merchant?: XOR<MerchantRelationFilter, MerchantWhereInput>
    reward?: XOR<RewardRelationFilter, RewardWhereInput>
  }

  export type CustomerItemCountOrderByWithRelationInput = {
    id?: SortOrder
    customerId?: SortOrder
    merchantId?: SortOrder
    rewardId?: SortOrder
    itemName?: SortOrder
    count?: SortOrder
    updatedAt?: SortOrder
    customer?: CustomerOrderByWithRelationInput
    merchant?: MerchantOrderByWithRelationInput
    reward?: RewardOrderByWithRelationInput
  }

  export type CustomerItemCountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    customerId_merchantId_rewardId_itemName?: CustomerItemCountCustomerIdMerchantIdRewardIdItemNameCompoundUniqueInput
    AND?: CustomerItemCountWhereInput | CustomerItemCountWhereInput[]
    OR?: CustomerItemCountWhereInput[]
    NOT?: CustomerItemCountWhereInput | CustomerItemCountWhereInput[]
    customerId?: StringFilter<"CustomerItemCount"> | string
    merchantId?: StringFilter<"CustomerItemCount"> | string
    rewardId?: StringFilter<"CustomerItemCount"> | string
    itemName?: StringFilter<"CustomerItemCount"> | string
    count?: IntFilter<"CustomerItemCount"> | number
    updatedAt?: DateTimeFilter<"CustomerItemCount"> | Date | string
    customer?: XOR<CustomerRelationFilter, CustomerWhereInput>
    merchant?: XOR<MerchantRelationFilter, MerchantWhereInput>
    reward?: XOR<RewardRelationFilter, RewardWhereInput>
  }, "id" | "customerId_merchantId_rewardId_itemName">

  export type CustomerItemCountOrderByWithAggregationInput = {
    id?: SortOrder
    customerId?: SortOrder
    merchantId?: SortOrder
    rewardId?: SortOrder
    itemName?: SortOrder
    count?: SortOrder
    updatedAt?: SortOrder
    _count?: CustomerItemCountCountOrderByAggregateInput
    _avg?: CustomerItemCountAvgOrderByAggregateInput
    _max?: CustomerItemCountMaxOrderByAggregateInput
    _min?: CustomerItemCountMinOrderByAggregateInput
    _sum?: CustomerItemCountSumOrderByAggregateInput
  }

  export type CustomerItemCountScalarWhereWithAggregatesInput = {
    AND?: CustomerItemCountScalarWhereWithAggregatesInput | CustomerItemCountScalarWhereWithAggregatesInput[]
    OR?: CustomerItemCountScalarWhereWithAggregatesInput[]
    NOT?: CustomerItemCountScalarWhereWithAggregatesInput | CustomerItemCountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CustomerItemCount"> | string
    customerId?: StringWithAggregatesFilter<"CustomerItemCount"> | string
    merchantId?: StringWithAggregatesFilter<"CustomerItemCount"> | string
    rewardId?: StringWithAggregatesFilter<"CustomerItemCount"> | string
    itemName?: StringWithAggregatesFilter<"CustomerItemCount"> | string
    count?: IntWithAggregatesFilter<"CustomerItemCount"> | number
    updatedAt?: DateTimeWithAggregatesFilter<"CustomerItemCount"> | Date | string
  }

  export type LedgerEntryWhereInput = {
    AND?: LedgerEntryWhereInput | LedgerEntryWhereInput[]
    OR?: LedgerEntryWhereInput[]
    NOT?: LedgerEntryWhereInput | LedgerEntryWhereInput[]
    id?: StringFilter<"LedgerEntry"> | string
    customerId?: StringFilter<"LedgerEntry"> | string
    merchantId?: StringFilter<"LedgerEntry"> | string
    type?: EnumLedgerEntryTypeFilter<"LedgerEntry"> | $Enums.LedgerEntryType
    points?: IntFilter<"LedgerEntry"> | number
    transactionId?: StringNullableFilter<"LedgerEntry"> | string | null
    redemptionId?: StringNullableFilter<"LedgerEntry"> | string | null
    createdAt?: DateTimeFilter<"LedgerEntry"> | Date | string
    customer?: XOR<CustomerRelationFilter, CustomerWhereInput>
    merchant?: XOR<MerchantRelationFilter, MerchantWhereInput>
    transaction?: XOR<TransactionNullableRelationFilter, TransactionWhereInput> | null
    redemption?: XOR<RedemptionNullableRelationFilter, RedemptionWhereInput> | null
  }

  export type LedgerEntryOrderByWithRelationInput = {
    id?: SortOrder
    customerId?: SortOrder
    merchantId?: SortOrder
    type?: SortOrder
    points?: SortOrder
    transactionId?: SortOrderInput | SortOrder
    redemptionId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    customer?: CustomerOrderByWithRelationInput
    merchant?: MerchantOrderByWithRelationInput
    transaction?: TransactionOrderByWithRelationInput
    redemption?: RedemptionOrderByWithRelationInput
  }

  export type LedgerEntryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    redemptionId?: string
    AND?: LedgerEntryWhereInput | LedgerEntryWhereInput[]
    OR?: LedgerEntryWhereInput[]
    NOT?: LedgerEntryWhereInput | LedgerEntryWhereInput[]
    customerId?: StringFilter<"LedgerEntry"> | string
    merchantId?: StringFilter<"LedgerEntry"> | string
    type?: EnumLedgerEntryTypeFilter<"LedgerEntry"> | $Enums.LedgerEntryType
    points?: IntFilter<"LedgerEntry"> | number
    transactionId?: StringNullableFilter<"LedgerEntry"> | string | null
    createdAt?: DateTimeFilter<"LedgerEntry"> | Date | string
    customer?: XOR<CustomerRelationFilter, CustomerWhereInput>
    merchant?: XOR<MerchantRelationFilter, MerchantWhereInput>
    transaction?: XOR<TransactionNullableRelationFilter, TransactionWhereInput> | null
    redemption?: XOR<RedemptionNullableRelationFilter, RedemptionWhereInput> | null
  }, "id" | "redemptionId">

  export type LedgerEntryOrderByWithAggregationInput = {
    id?: SortOrder
    customerId?: SortOrder
    merchantId?: SortOrder
    type?: SortOrder
    points?: SortOrder
    transactionId?: SortOrderInput | SortOrder
    redemptionId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: LedgerEntryCountOrderByAggregateInput
    _avg?: LedgerEntryAvgOrderByAggregateInput
    _max?: LedgerEntryMaxOrderByAggregateInput
    _min?: LedgerEntryMinOrderByAggregateInput
    _sum?: LedgerEntrySumOrderByAggregateInput
  }

  export type LedgerEntryScalarWhereWithAggregatesInput = {
    AND?: LedgerEntryScalarWhereWithAggregatesInput | LedgerEntryScalarWhereWithAggregatesInput[]
    OR?: LedgerEntryScalarWhereWithAggregatesInput[]
    NOT?: LedgerEntryScalarWhereWithAggregatesInput | LedgerEntryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LedgerEntry"> | string
    customerId?: StringWithAggregatesFilter<"LedgerEntry"> | string
    merchantId?: StringWithAggregatesFilter<"LedgerEntry"> | string
    type?: EnumLedgerEntryTypeWithAggregatesFilter<"LedgerEntry"> | $Enums.LedgerEntryType
    points?: IntWithAggregatesFilter<"LedgerEntry"> | number
    transactionId?: StringNullableWithAggregatesFilter<"LedgerEntry"> | string | null
    redemptionId?: StringNullableWithAggregatesFilter<"LedgerEntry"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"LedgerEntry"> | Date | string
  }

  export type WebhookLogWhereInput = {
    AND?: WebhookLogWhereInput | WebhookLogWhereInput[]
    OR?: WebhookLogWhereInput[]
    NOT?: WebhookLogWhereInput | WebhookLogWhereInput[]
    id?: StringFilter<"WebhookLog"> | string
    provider?: EnumPOSProviderFilter<"WebhookLog"> | $Enums.POSProvider
    eventType?: StringFilter<"WebhookLog"> | string
    payload?: JsonFilter<"WebhookLog">
    signature?: StringNullableFilter<"WebhookLog"> | string | null
    status?: EnumWebhookStatusFilter<"WebhookLog"> | $Enums.WebhookStatus
    errorMessage?: StringNullableFilter<"WebhookLog"> | string | null
    processedAt?: DateTimeNullableFilter<"WebhookLog"> | Date | string | null
    createdAt?: DateTimeFilter<"WebhookLog"> | Date | string
  }

  export type WebhookLogOrderByWithRelationInput = {
    id?: SortOrder
    provider?: SortOrder
    eventType?: SortOrder
    payload?: SortOrder
    signature?: SortOrderInput | SortOrder
    status?: SortOrder
    errorMessage?: SortOrderInput | SortOrder
    processedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type WebhookLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WebhookLogWhereInput | WebhookLogWhereInput[]
    OR?: WebhookLogWhereInput[]
    NOT?: WebhookLogWhereInput | WebhookLogWhereInput[]
    provider?: EnumPOSProviderFilter<"WebhookLog"> | $Enums.POSProvider
    eventType?: StringFilter<"WebhookLog"> | string
    payload?: JsonFilter<"WebhookLog">
    signature?: StringNullableFilter<"WebhookLog"> | string | null
    status?: EnumWebhookStatusFilter<"WebhookLog"> | $Enums.WebhookStatus
    errorMessage?: StringNullableFilter<"WebhookLog"> | string | null
    processedAt?: DateTimeNullableFilter<"WebhookLog"> | Date | string | null
    createdAt?: DateTimeFilter<"WebhookLog"> | Date | string
  }, "id">

  export type WebhookLogOrderByWithAggregationInput = {
    id?: SortOrder
    provider?: SortOrder
    eventType?: SortOrder
    payload?: SortOrder
    signature?: SortOrderInput | SortOrder
    status?: SortOrder
    errorMessage?: SortOrderInput | SortOrder
    processedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: WebhookLogCountOrderByAggregateInput
    _max?: WebhookLogMaxOrderByAggregateInput
    _min?: WebhookLogMinOrderByAggregateInput
  }

  export type WebhookLogScalarWhereWithAggregatesInput = {
    AND?: WebhookLogScalarWhereWithAggregatesInput | WebhookLogScalarWhereWithAggregatesInput[]
    OR?: WebhookLogScalarWhereWithAggregatesInput[]
    NOT?: WebhookLogScalarWhereWithAggregatesInput | WebhookLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WebhookLog"> | string
    provider?: EnumPOSProviderWithAggregatesFilter<"WebhookLog"> | $Enums.POSProvider
    eventType?: StringWithAggregatesFilter<"WebhookLog"> | string
    payload?: JsonWithAggregatesFilter<"WebhookLog">
    signature?: StringNullableWithAggregatesFilter<"WebhookLog"> | string | null
    status?: EnumWebhookStatusWithAggregatesFilter<"WebhookLog"> | $Enums.WebhookStatus
    errorMessage?: StringNullableWithAggregatesFilter<"WebhookLog"> | string | null
    processedAt?: DateTimeNullableWithAggregatesFilter<"WebhookLog"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"WebhookLog"> | Date | string
  }

  export type MerchantCreateInput = {
    id?: string
    email: string
    password: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    posIntegrations?: POSIntegrationCreateNestedManyWithoutMerchantInput
    locations?: LocationCreateNestedManyWithoutMerchantInput
    rewards?: RewardCreateNestedManyWithoutMerchantInput
    transactions?: TransactionCreateNestedManyWithoutMerchantInput
    redemptions?: RedemptionCreateNestedManyWithoutMerchantInput
    customerBalances?: CustomerBalanceCreateNestedManyWithoutMerchantInput
    itemCounts?: CustomerItemCountCreateNestedManyWithoutMerchantInput
    ledgerEntries?: LedgerEntryCreateNestedManyWithoutMerchantInput
  }

  export type MerchantUncheckedCreateInput = {
    id?: string
    email: string
    password: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    posIntegrations?: POSIntegrationUncheckedCreateNestedManyWithoutMerchantInput
    locations?: LocationUncheckedCreateNestedManyWithoutMerchantInput
    rewards?: RewardUncheckedCreateNestedManyWithoutMerchantInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutMerchantInput
    redemptions?: RedemptionUncheckedCreateNestedManyWithoutMerchantInput
    customerBalances?: CustomerBalanceUncheckedCreateNestedManyWithoutMerchantInput
    itemCounts?: CustomerItemCountUncheckedCreateNestedManyWithoutMerchantInput
    ledgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutMerchantInput
  }

  export type MerchantUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posIntegrations?: POSIntegrationUpdateManyWithoutMerchantNestedInput
    locations?: LocationUpdateManyWithoutMerchantNestedInput
    rewards?: RewardUpdateManyWithoutMerchantNestedInput
    transactions?: TransactionUpdateManyWithoutMerchantNestedInput
    redemptions?: RedemptionUpdateManyWithoutMerchantNestedInput
    customerBalances?: CustomerBalanceUpdateManyWithoutMerchantNestedInput
    itemCounts?: CustomerItemCountUpdateManyWithoutMerchantNestedInput
    ledgerEntries?: LedgerEntryUpdateManyWithoutMerchantNestedInput
  }

  export type MerchantUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posIntegrations?: POSIntegrationUncheckedUpdateManyWithoutMerchantNestedInput
    locations?: LocationUncheckedUpdateManyWithoutMerchantNestedInput
    rewards?: RewardUncheckedUpdateManyWithoutMerchantNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutMerchantNestedInput
    redemptions?: RedemptionUncheckedUpdateManyWithoutMerchantNestedInput
    customerBalances?: CustomerBalanceUncheckedUpdateManyWithoutMerchantNestedInput
    itemCounts?: CustomerItemCountUncheckedUpdateManyWithoutMerchantNestedInput
    ledgerEntries?: LedgerEntryUncheckedUpdateManyWithoutMerchantNestedInput
  }

  export type MerchantCreateManyInput = {
    id?: string
    email: string
    password: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MerchantUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MerchantUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type POSIntegrationCreateInput = {
    id?: string
    provider: $Enums.POSProvider
    accessToken: string
    refreshToken?: string | null
    providerMerchantId: string
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    merchant: MerchantCreateNestedOneWithoutPosIntegrationsInput
    locations?: LocationCreateNestedManyWithoutPosIntegrationInput
  }

  export type POSIntegrationUncheckedCreateInput = {
    id?: string
    merchantId: string
    provider: $Enums.POSProvider
    accessToken: string
    refreshToken?: string | null
    providerMerchantId: string
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    locations?: LocationUncheckedCreateNestedManyWithoutPosIntegrationInput
  }

  export type POSIntegrationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumPOSProviderFieldUpdateOperationsInput | $Enums.POSProvider
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    providerMerchantId?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    merchant?: MerchantUpdateOneRequiredWithoutPosIntegrationsNestedInput
    locations?: LocationUpdateManyWithoutPosIntegrationNestedInput
  }

  export type POSIntegrationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    merchantId?: StringFieldUpdateOperationsInput | string
    provider?: EnumPOSProviderFieldUpdateOperationsInput | $Enums.POSProvider
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    providerMerchantId?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locations?: LocationUncheckedUpdateManyWithoutPosIntegrationNestedInput
  }

  export type POSIntegrationCreateManyInput = {
    id?: string
    merchantId: string
    provider: $Enums.POSProvider
    accessToken: string
    refreshToken?: string | null
    providerMerchantId: string
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type POSIntegrationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumPOSProviderFieldUpdateOperationsInput | $Enums.POSProvider
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    providerMerchantId?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type POSIntegrationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    merchantId?: StringFieldUpdateOperationsInput | string
    provider?: EnumPOSProviderFieldUpdateOperationsInput | $Enums.POSProvider
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    providerMerchantId?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocationCreateInput = {
    id?: string
    posLocationId: string
    name: string
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    country?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    merchant: MerchantCreateNestedOneWithoutLocationsInput
    posIntegration: POSIntegrationCreateNestedOneWithoutLocationsInput
    transactions?: TransactionCreateNestedManyWithoutLocationInput
  }

  export type LocationUncheckedCreateInput = {
    id?: string
    merchantId: string
    posIntegrationId: string
    posLocationId: string
    name: string
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    country?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: TransactionUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    posLocationId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    merchant?: MerchantUpdateOneRequiredWithoutLocationsNestedInput
    posIntegration?: POSIntegrationUpdateOneRequiredWithoutLocationsNestedInput
    transactions?: TransactionUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    merchantId?: StringFieldUpdateOperationsInput | string
    posIntegrationId?: StringFieldUpdateOperationsInput | string
    posLocationId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type LocationCreateManyInput = {
    id?: string
    merchantId: string
    posIntegrationId: string
    posLocationId: string
    name: string
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    country?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LocationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    posLocationId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    merchantId?: StringFieldUpdateOperationsInput | string
    posIntegrationId?: StringFieldUpdateOperationsInput | string
    posLocationId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerCreateInput = {
    id?: string
    phoneNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    linkedCards?: LinkedCardCreateNestedManyWithoutCustomerInput
    transactions?: TransactionCreateNestedManyWithoutCustomerInput
    customerBalances?: CustomerBalanceCreateNestedManyWithoutCustomerInput
    redemptions?: RedemptionCreateNestedManyWithoutCustomerInput
    ledgerEntries?: LedgerEntryCreateNestedManyWithoutCustomerInput
    itemCounts?: CustomerItemCountCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateInput = {
    id?: string
    phoneNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    linkedCards?: LinkedCardUncheckedCreateNestedManyWithoutCustomerInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCustomerInput
    customerBalances?: CustomerBalanceUncheckedCreateNestedManyWithoutCustomerInput
    redemptions?: RedemptionUncheckedCreateNestedManyWithoutCustomerInput
    ledgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutCustomerInput
    itemCounts?: CustomerItemCountUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    linkedCards?: LinkedCardUpdateManyWithoutCustomerNestedInput
    transactions?: TransactionUpdateManyWithoutCustomerNestedInput
    customerBalances?: CustomerBalanceUpdateManyWithoutCustomerNestedInput
    redemptions?: RedemptionUpdateManyWithoutCustomerNestedInput
    ledgerEntries?: LedgerEntryUpdateManyWithoutCustomerNestedInput
    itemCounts?: CustomerItemCountUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    linkedCards?: LinkedCardUncheckedUpdateManyWithoutCustomerNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCustomerNestedInput
    customerBalances?: CustomerBalanceUncheckedUpdateManyWithoutCustomerNestedInput
    redemptions?: RedemptionUncheckedUpdateManyWithoutCustomerNestedInput
    ledgerEntries?: LedgerEntryUncheckedUpdateManyWithoutCustomerNestedInput
    itemCounts?: CustomerItemCountUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerCreateManyInput = {
    id?: string
    phoneNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LinkedCardCreateInput = {
    id?: string
    cardFingerprint: string
    last4: string
    brand?: string | null
    zipCode?: string | null
    posProvider: $Enums.POSProvider
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutLinkedCardsInput
  }

  export type LinkedCardUncheckedCreateInput = {
    id?: string
    customerId: string
    cardFingerprint: string
    last4: string
    brand?: string | null
    zipCode?: string | null
    posProvider: $Enums.POSProvider
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LinkedCardUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    cardFingerprint?: StringFieldUpdateOperationsInput | string
    last4?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    posProvider?: EnumPOSProviderFieldUpdateOperationsInput | $Enums.POSProvider
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutLinkedCardsNestedInput
  }

  export type LinkedCardUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    cardFingerprint?: StringFieldUpdateOperationsInput | string
    last4?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    posProvider?: EnumPOSProviderFieldUpdateOperationsInput | $Enums.POSProvider
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LinkedCardCreateManyInput = {
    id?: string
    customerId: string
    cardFingerprint: string
    last4: string
    brand?: string | null
    zipCode?: string | null
    posProvider: $Enums.POSProvider
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LinkedCardUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    cardFingerprint?: StringFieldUpdateOperationsInput | string
    last4?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    posProvider?: EnumPOSProviderFieldUpdateOperationsInput | $Enums.POSProvider
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LinkedCardUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    cardFingerprint?: StringFieldUpdateOperationsInput | string
    last4?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    posProvider?: EnumPOSProviderFieldUpdateOperationsInput | $Enums.POSProvider
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionCreateInput = {
    id?: string
    posProvider: $Enums.POSProvider
    posTransactionId: string
    posLocationId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    pointsEarned?: number
    status?: $Enums.TransactionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    merchant: MerchantCreateNestedOneWithoutTransactionsInput
    customer?: CustomerCreateNestedOneWithoutTransactionsInput
    location?: LocationCreateNestedOneWithoutTransactionsInput
    ledgerEntries?: LedgerEntryCreateNestedManyWithoutTransactionInput
  }

  export type TransactionUncheckedCreateInput = {
    id?: string
    merchantId: string
    customerId?: string | null
    locationId?: string | null
    posProvider: $Enums.POSProvider
    posTransactionId: string
    posLocationId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    pointsEarned?: number
    status?: $Enums.TransactionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    ledgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutTransactionInput
  }

  export type TransactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    posProvider?: EnumPOSProviderFieldUpdateOperationsInput | $Enums.POSProvider
    posTransactionId?: StringFieldUpdateOperationsInput | string
    posLocationId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pointsEarned?: IntFieldUpdateOperationsInput | number
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    merchant?: MerchantUpdateOneRequiredWithoutTransactionsNestedInput
    customer?: CustomerUpdateOneWithoutTransactionsNestedInput
    location?: LocationUpdateOneWithoutTransactionsNestedInput
    ledgerEntries?: LedgerEntryUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    merchantId?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    posProvider?: EnumPOSProviderFieldUpdateOperationsInput | $Enums.POSProvider
    posTransactionId?: StringFieldUpdateOperationsInput | string
    posLocationId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pointsEarned?: IntFieldUpdateOperationsInput | number
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ledgerEntries?: LedgerEntryUncheckedUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionCreateManyInput = {
    id?: string
    merchantId: string
    customerId?: string | null
    locationId?: string | null
    posProvider: $Enums.POSProvider
    posTransactionId: string
    posLocationId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    pointsEarned?: number
    status?: $Enums.TransactionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    posProvider?: EnumPOSProviderFieldUpdateOperationsInput | $Enums.POSProvider
    posTransactionId?: StringFieldUpdateOperationsInput | string
    posLocationId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pointsEarned?: IntFieldUpdateOperationsInput | number
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    merchantId?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    posProvider?: EnumPOSProviderFieldUpdateOperationsInput | $Enums.POSProvider
    posTransactionId?: StringFieldUpdateOperationsInput | string
    posLocationId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pointsEarned?: IntFieldUpdateOperationsInput | number
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerBalanceCreateInput = {
    id?: string
    points?: number
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutCustomerBalancesInput
    merchant: MerchantCreateNestedOneWithoutCustomerBalancesInput
  }

  export type CustomerBalanceUncheckedCreateInput = {
    id?: string
    customerId: string
    merchantId: string
    points?: number
    updatedAt?: Date | string
  }

  export type CustomerBalanceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutCustomerBalancesNestedInput
    merchant?: MerchantUpdateOneRequiredWithoutCustomerBalancesNestedInput
  }

  export type CustomerBalanceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    merchantId?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerBalanceCreateManyInput = {
    id?: string
    customerId: string
    merchantId: string
    points?: number
    updatedAt?: Date | string
  }

  export type CustomerBalanceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerBalanceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    merchantId?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RewardCreateInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.RewardType
    pointsCost?: number | null
    itemName?: string | null
    itemCount?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    merchant: MerchantCreateNestedOneWithoutRewardsInput
    posRewardItems?: POSRewardItemCreateNestedManyWithoutRewardInput
    redemptions?: RedemptionCreateNestedManyWithoutRewardInput
    itemCounts?: CustomerItemCountCreateNestedManyWithoutRewardInput
  }

  export type RewardUncheckedCreateInput = {
    id?: string
    merchantId: string
    name: string
    description?: string | null
    type: $Enums.RewardType
    pointsCost?: number | null
    itemName?: string | null
    itemCount?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    posRewardItems?: POSRewardItemUncheckedCreateNestedManyWithoutRewardInput
    redemptions?: RedemptionUncheckedCreateNestedManyWithoutRewardInput
    itemCounts?: CustomerItemCountUncheckedCreateNestedManyWithoutRewardInput
  }

  export type RewardUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumRewardTypeFieldUpdateOperationsInput | $Enums.RewardType
    pointsCost?: NullableIntFieldUpdateOperationsInput | number | null
    itemName?: NullableStringFieldUpdateOperationsInput | string | null
    itemCount?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    merchant?: MerchantUpdateOneRequiredWithoutRewardsNestedInput
    posRewardItems?: POSRewardItemUpdateManyWithoutRewardNestedInput
    redemptions?: RedemptionUpdateManyWithoutRewardNestedInput
    itemCounts?: CustomerItemCountUpdateManyWithoutRewardNestedInput
  }

  export type RewardUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    merchantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumRewardTypeFieldUpdateOperationsInput | $Enums.RewardType
    pointsCost?: NullableIntFieldUpdateOperationsInput | number | null
    itemName?: NullableStringFieldUpdateOperationsInput | string | null
    itemCount?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posRewardItems?: POSRewardItemUncheckedUpdateManyWithoutRewardNestedInput
    redemptions?: RedemptionUncheckedUpdateManyWithoutRewardNestedInput
    itemCounts?: CustomerItemCountUncheckedUpdateManyWithoutRewardNestedInput
  }

  export type RewardCreateManyInput = {
    id?: string
    merchantId: string
    name: string
    description?: string | null
    type: $Enums.RewardType
    pointsCost?: number | null
    itemName?: string | null
    itemCount?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RewardUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumRewardTypeFieldUpdateOperationsInput | $Enums.RewardType
    pointsCost?: NullableIntFieldUpdateOperationsInput | number | null
    itemName?: NullableStringFieldUpdateOperationsInput | string | null
    itemCount?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RewardUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    merchantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumRewardTypeFieldUpdateOperationsInput | $Enums.RewardType
    pointsCost?: NullableIntFieldUpdateOperationsInput | number | null
    itemName?: NullableStringFieldUpdateOperationsInput | string | null
    itemCount?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type POSRewardItemCreateInput = {
    id?: string
    posProvider: $Enums.POSProvider
    posItemId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    reward: RewardCreateNestedOneWithoutPosRewardItemsInput
  }

  export type POSRewardItemUncheckedCreateInput = {
    id?: string
    rewardId: string
    posProvider: $Enums.POSProvider
    posItemId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type POSRewardItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    posProvider?: EnumPOSProviderFieldUpdateOperationsInput | $Enums.POSProvider
    posItemId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reward?: RewardUpdateOneRequiredWithoutPosRewardItemsNestedInput
  }

  export type POSRewardItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rewardId?: StringFieldUpdateOperationsInput | string
    posProvider?: EnumPOSProviderFieldUpdateOperationsInput | $Enums.POSProvider
    posItemId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type POSRewardItemCreateManyInput = {
    id?: string
    rewardId: string
    posProvider: $Enums.POSProvider
    posItemId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type POSRewardItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    posProvider?: EnumPOSProviderFieldUpdateOperationsInput | $Enums.POSProvider
    posItemId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type POSRewardItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    rewardId?: StringFieldUpdateOperationsInput | string
    posProvider?: EnumPOSProviderFieldUpdateOperationsInput | $Enums.POSProvider
    posItemId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RedemptionCreateInput = {
    id?: string
    qrToken: string
    pinCode: string
    status?: $Enums.RedemptionStatus
    pointsDeducted?: number | null
    redeemedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutRedemptionsInput
    merchant: MerchantCreateNestedOneWithoutRedemptionsInput
    reward: RewardCreateNestedOneWithoutRedemptionsInput
    ledgerEntry?: LedgerEntryCreateNestedOneWithoutRedemptionInput
  }

  export type RedemptionUncheckedCreateInput = {
    id?: string
    customerId: string
    merchantId: string
    rewardId: string
    qrToken: string
    pinCode: string
    status?: $Enums.RedemptionStatus
    pointsDeducted?: number | null
    redeemedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ledgerEntry?: LedgerEntryUncheckedCreateNestedOneWithoutRedemptionInput
  }

  export type RedemptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    qrToken?: StringFieldUpdateOperationsInput | string
    pinCode?: StringFieldUpdateOperationsInput | string
    status?: EnumRedemptionStatusFieldUpdateOperationsInput | $Enums.RedemptionStatus
    pointsDeducted?: NullableIntFieldUpdateOperationsInput | number | null
    redeemedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutRedemptionsNestedInput
    merchant?: MerchantUpdateOneRequiredWithoutRedemptionsNestedInput
    reward?: RewardUpdateOneRequiredWithoutRedemptionsNestedInput
    ledgerEntry?: LedgerEntryUpdateOneWithoutRedemptionNestedInput
  }

  export type RedemptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    merchantId?: StringFieldUpdateOperationsInput | string
    rewardId?: StringFieldUpdateOperationsInput | string
    qrToken?: StringFieldUpdateOperationsInput | string
    pinCode?: StringFieldUpdateOperationsInput | string
    status?: EnumRedemptionStatusFieldUpdateOperationsInput | $Enums.RedemptionStatus
    pointsDeducted?: NullableIntFieldUpdateOperationsInput | number | null
    redeemedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ledgerEntry?: LedgerEntryUncheckedUpdateOneWithoutRedemptionNestedInput
  }

  export type RedemptionCreateManyInput = {
    id?: string
    customerId: string
    merchantId: string
    rewardId: string
    qrToken: string
    pinCode: string
    status?: $Enums.RedemptionStatus
    pointsDeducted?: number | null
    redeemedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RedemptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    qrToken?: StringFieldUpdateOperationsInput | string
    pinCode?: StringFieldUpdateOperationsInput | string
    status?: EnumRedemptionStatusFieldUpdateOperationsInput | $Enums.RedemptionStatus
    pointsDeducted?: NullableIntFieldUpdateOperationsInput | number | null
    redeemedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RedemptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    merchantId?: StringFieldUpdateOperationsInput | string
    rewardId?: StringFieldUpdateOperationsInput | string
    qrToken?: StringFieldUpdateOperationsInput | string
    pinCode?: StringFieldUpdateOperationsInput | string
    status?: EnumRedemptionStatusFieldUpdateOperationsInput | $Enums.RedemptionStatus
    pointsDeducted?: NullableIntFieldUpdateOperationsInput | number | null
    redeemedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerItemCountCreateInput = {
    id?: string
    itemName: string
    count?: number
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutItemCountsInput
    merchant: MerchantCreateNestedOneWithoutItemCountsInput
    reward: RewardCreateNestedOneWithoutItemCountsInput
  }

  export type CustomerItemCountUncheckedCreateInput = {
    id?: string
    customerId: string
    merchantId: string
    rewardId: string
    itemName: string
    count?: number
    updatedAt?: Date | string
  }

  export type CustomerItemCountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemName?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutItemCountsNestedInput
    merchant?: MerchantUpdateOneRequiredWithoutItemCountsNestedInput
    reward?: RewardUpdateOneRequiredWithoutItemCountsNestedInput
  }

  export type CustomerItemCountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    merchantId?: StringFieldUpdateOperationsInput | string
    rewardId?: StringFieldUpdateOperationsInput | string
    itemName?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerItemCountCreateManyInput = {
    id?: string
    customerId: string
    merchantId: string
    rewardId: string
    itemName: string
    count?: number
    updatedAt?: Date | string
  }

  export type CustomerItemCountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemName?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerItemCountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    merchantId?: StringFieldUpdateOperationsInput | string
    rewardId?: StringFieldUpdateOperationsInput | string
    itemName?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LedgerEntryCreateInput = {
    id?: string
    type: $Enums.LedgerEntryType
    points: number
    createdAt?: Date | string
    customer: CustomerCreateNestedOneWithoutLedgerEntriesInput
    merchant: MerchantCreateNestedOneWithoutLedgerEntriesInput
    transaction?: TransactionCreateNestedOneWithoutLedgerEntriesInput
    redemption?: RedemptionCreateNestedOneWithoutLedgerEntryInput
  }

  export type LedgerEntryUncheckedCreateInput = {
    id?: string
    customerId: string
    merchantId: string
    type: $Enums.LedgerEntryType
    points: number
    transactionId?: string | null
    redemptionId?: string | null
    createdAt?: Date | string
  }

  export type LedgerEntryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumLedgerEntryTypeFieldUpdateOperationsInput | $Enums.LedgerEntryType
    points?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutLedgerEntriesNestedInput
    merchant?: MerchantUpdateOneRequiredWithoutLedgerEntriesNestedInput
    transaction?: TransactionUpdateOneWithoutLedgerEntriesNestedInput
    redemption?: RedemptionUpdateOneWithoutLedgerEntryNestedInput
  }

  export type LedgerEntryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    merchantId?: StringFieldUpdateOperationsInput | string
    type?: EnumLedgerEntryTypeFieldUpdateOperationsInput | $Enums.LedgerEntryType
    points?: IntFieldUpdateOperationsInput | number
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    redemptionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LedgerEntryCreateManyInput = {
    id?: string
    customerId: string
    merchantId: string
    type: $Enums.LedgerEntryType
    points: number
    transactionId?: string | null
    redemptionId?: string | null
    createdAt?: Date | string
  }

  export type LedgerEntryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumLedgerEntryTypeFieldUpdateOperationsInput | $Enums.LedgerEntryType
    points?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LedgerEntryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    merchantId?: StringFieldUpdateOperationsInput | string
    type?: EnumLedgerEntryTypeFieldUpdateOperationsInput | $Enums.LedgerEntryType
    points?: IntFieldUpdateOperationsInput | number
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    redemptionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebhookLogCreateInput = {
    id?: string
    provider: $Enums.POSProvider
    eventType: string
    payload: JsonNullValueInput | InputJsonValue
    signature?: string | null
    status?: $Enums.WebhookStatus
    errorMessage?: string | null
    processedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type WebhookLogUncheckedCreateInput = {
    id?: string
    provider: $Enums.POSProvider
    eventType: string
    payload: JsonNullValueInput | InputJsonValue
    signature?: string | null
    status?: $Enums.WebhookStatus
    errorMessage?: string | null
    processedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type WebhookLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumPOSProviderFieldUpdateOperationsInput | $Enums.POSProvider
    eventType?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumWebhookStatusFieldUpdateOperationsInput | $Enums.WebhookStatus
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebhookLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumPOSProviderFieldUpdateOperationsInput | $Enums.POSProvider
    eventType?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumWebhookStatusFieldUpdateOperationsInput | $Enums.WebhookStatus
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebhookLogCreateManyInput = {
    id?: string
    provider: $Enums.POSProvider
    eventType: string
    payload: JsonNullValueInput | InputJsonValue
    signature?: string | null
    status?: $Enums.WebhookStatus
    errorMessage?: string | null
    processedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type WebhookLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumPOSProviderFieldUpdateOperationsInput | $Enums.POSProvider
    eventType?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumWebhookStatusFieldUpdateOperationsInput | $Enums.WebhookStatus
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebhookLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumPOSProviderFieldUpdateOperationsInput | $Enums.POSProvider
    eventType?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumWebhookStatusFieldUpdateOperationsInput | $Enums.WebhookStatus
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type POSIntegrationListRelationFilter = {
    every?: POSIntegrationWhereInput
    some?: POSIntegrationWhereInput
    none?: POSIntegrationWhereInput
  }

  export type LocationListRelationFilter = {
    every?: LocationWhereInput
    some?: LocationWhereInput
    none?: LocationWhereInput
  }

  export type RewardListRelationFilter = {
    every?: RewardWhereInput
    some?: RewardWhereInput
    none?: RewardWhereInput
  }

  export type TransactionListRelationFilter = {
    every?: TransactionWhereInput
    some?: TransactionWhereInput
    none?: TransactionWhereInput
  }

  export type RedemptionListRelationFilter = {
    every?: RedemptionWhereInput
    some?: RedemptionWhereInput
    none?: RedemptionWhereInput
  }

  export type CustomerBalanceListRelationFilter = {
    every?: CustomerBalanceWhereInput
    some?: CustomerBalanceWhereInput
    none?: CustomerBalanceWhereInput
  }

  export type CustomerItemCountListRelationFilter = {
    every?: CustomerItemCountWhereInput
    some?: CustomerItemCountWhereInput
    none?: CustomerItemCountWhereInput
  }

  export type LedgerEntryListRelationFilter = {
    every?: LedgerEntryWhereInput
    some?: LedgerEntryWhereInput
    none?: LedgerEntryWhereInput
  }

  export type POSIntegrationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LocationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RewardOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RedemptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomerBalanceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomerItemCountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LedgerEntryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MerchantCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MerchantMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MerchantMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumPOSProviderFilter<$PrismaModel = never> = {
    equals?: $Enums.POSProvider | EnumPOSProviderFieldRefInput<$PrismaModel>
    in?: $Enums.POSProvider[] | ListEnumPOSProviderFieldRefInput<$PrismaModel>
    notIn?: $Enums.POSProvider[] | ListEnumPOSProviderFieldRefInput<$PrismaModel>
    not?: NestedEnumPOSProviderFilter<$PrismaModel> | $Enums.POSProvider
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type MerchantRelationFilter = {
    is?: MerchantWhereInput
    isNot?: MerchantWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type POSIntegrationMerchantIdProviderCompoundUniqueInput = {
    merchantId: string
    provider: $Enums.POSProvider
  }

  export type POSIntegrationCountOrderByAggregateInput = {
    id?: SortOrder
    merchantId?: SortOrder
    provider?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    providerMerchantId?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type POSIntegrationMaxOrderByAggregateInput = {
    id?: SortOrder
    merchantId?: SortOrder
    provider?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    providerMerchantId?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type POSIntegrationMinOrderByAggregateInput = {
    id?: SortOrder
    merchantId?: SortOrder
    provider?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    providerMerchantId?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumPOSProviderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.POSProvider | EnumPOSProviderFieldRefInput<$PrismaModel>
    in?: $Enums.POSProvider[] | ListEnumPOSProviderFieldRefInput<$PrismaModel>
    notIn?: $Enums.POSProvider[] | ListEnumPOSProviderFieldRefInput<$PrismaModel>
    not?: NestedEnumPOSProviderWithAggregatesFilter<$PrismaModel> | $Enums.POSProvider
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPOSProviderFilter<$PrismaModel>
    _max?: NestedEnumPOSProviderFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type POSIntegrationRelationFilter = {
    is?: POSIntegrationWhereInput
    isNot?: POSIntegrationWhereInput
  }

  export type LocationPosIntegrationIdPosLocationIdCompoundUniqueInput = {
    posIntegrationId: string
    posLocationId: string
  }

  export type LocationCountOrderByAggregateInput = {
    id?: SortOrder
    merchantId?: SortOrder
    posIntegrationId?: SortOrder
    posLocationId?: SortOrder
    name?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    country?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LocationMaxOrderByAggregateInput = {
    id?: SortOrder
    merchantId?: SortOrder
    posIntegrationId?: SortOrder
    posLocationId?: SortOrder
    name?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    country?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LocationMinOrderByAggregateInput = {
    id?: SortOrder
    merchantId?: SortOrder
    posIntegrationId?: SortOrder
    posLocationId?: SortOrder
    name?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    country?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LinkedCardListRelationFilter = {
    every?: LinkedCardWhereInput
    some?: LinkedCardWhereInput
    none?: LinkedCardWhereInput
  }

  export type LinkedCardOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomerCountOrderByAggregateInput = {
    id?: SortOrder
    phoneNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerMaxOrderByAggregateInput = {
    id?: SortOrder
    phoneNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerMinOrderByAggregateInput = {
    id?: SortOrder
    phoneNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerRelationFilter = {
    is?: CustomerWhereInput
    isNot?: CustomerWhereInput
  }

  export type LinkedCardCardFingerprintPosProviderCompoundUniqueInput = {
    cardFingerprint: string
    posProvider: $Enums.POSProvider
  }

  export type LinkedCardCountOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    cardFingerprint?: SortOrder
    last4?: SortOrder
    brand?: SortOrder
    zipCode?: SortOrder
    posProvider?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LinkedCardMaxOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    cardFingerprint?: SortOrder
    last4?: SortOrder
    brand?: SortOrder
    zipCode?: SortOrder
    posProvider?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LinkedCardMinOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    cardFingerprint?: SortOrder
    last4?: SortOrder
    brand?: SortOrder
    zipCode?: SortOrder
    posProvider?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type EnumTransactionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionStatus | EnumTransactionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionStatusFilter<$PrismaModel> | $Enums.TransactionStatus
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type CustomerNullableRelationFilter = {
    is?: CustomerWhereInput | null
    isNot?: CustomerWhereInput | null
  }

  export type LocationNullableRelationFilter = {
    is?: LocationWhereInput | null
    isNot?: LocationWhereInput | null
  }

  export type TransactionPosProviderPosTransactionIdCompoundUniqueInput = {
    posProvider: $Enums.POSProvider
    posTransactionId: string
  }

  export type TransactionCountOrderByAggregateInput = {
    id?: SortOrder
    merchantId?: SortOrder
    customerId?: SortOrder
    locationId?: SortOrder
    posProvider?: SortOrder
    posTransactionId?: SortOrder
    posLocationId?: SortOrder
    amount?: SortOrder
    pointsEarned?: SortOrder
    status?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransactionAvgOrderByAggregateInput = {
    amount?: SortOrder
    pointsEarned?: SortOrder
  }

  export type TransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    merchantId?: SortOrder
    customerId?: SortOrder
    locationId?: SortOrder
    posProvider?: SortOrder
    posTransactionId?: SortOrder
    posLocationId?: SortOrder
    amount?: SortOrder
    pointsEarned?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransactionMinOrderByAggregateInput = {
    id?: SortOrder
    merchantId?: SortOrder
    customerId?: SortOrder
    locationId?: SortOrder
    posProvider?: SortOrder
    posTransactionId?: SortOrder
    posLocationId?: SortOrder
    amount?: SortOrder
    pointsEarned?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransactionSumOrderByAggregateInput = {
    amount?: SortOrder
    pointsEarned?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumTransactionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionStatus | EnumTransactionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionStatusWithAggregatesFilter<$PrismaModel> | $Enums.TransactionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionStatusFilter<$PrismaModel>
    _max?: NestedEnumTransactionStatusFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type CustomerBalanceCustomerIdMerchantIdCompoundUniqueInput = {
    customerId: string
    merchantId: string
  }

  export type CustomerBalanceCountOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    merchantId?: SortOrder
    points?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerBalanceAvgOrderByAggregateInput = {
    points?: SortOrder
  }

  export type CustomerBalanceMaxOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    merchantId?: SortOrder
    points?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerBalanceMinOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    merchantId?: SortOrder
    points?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerBalanceSumOrderByAggregateInput = {
    points?: SortOrder
  }

  export type EnumRewardTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.RewardType | EnumRewardTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RewardType[] | ListEnumRewardTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RewardType[] | ListEnumRewardTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRewardTypeFilter<$PrismaModel> | $Enums.RewardType
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type POSRewardItemListRelationFilter = {
    every?: POSRewardItemWhereInput
    some?: POSRewardItemWhereInput
    none?: POSRewardItemWhereInput
  }

  export type POSRewardItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RewardCountOrderByAggregateInput = {
    id?: SortOrder
    merchantId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    pointsCost?: SortOrder
    itemName?: SortOrder
    itemCount?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RewardAvgOrderByAggregateInput = {
    pointsCost?: SortOrder
    itemCount?: SortOrder
  }

  export type RewardMaxOrderByAggregateInput = {
    id?: SortOrder
    merchantId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    pointsCost?: SortOrder
    itemName?: SortOrder
    itemCount?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RewardMinOrderByAggregateInput = {
    id?: SortOrder
    merchantId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    pointsCost?: SortOrder
    itemName?: SortOrder
    itemCount?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RewardSumOrderByAggregateInput = {
    pointsCost?: SortOrder
    itemCount?: SortOrder
  }

  export type EnumRewardTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RewardType | EnumRewardTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RewardType[] | ListEnumRewardTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RewardType[] | ListEnumRewardTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRewardTypeWithAggregatesFilter<$PrismaModel> | $Enums.RewardType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRewardTypeFilter<$PrismaModel>
    _max?: NestedEnumRewardTypeFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type RewardRelationFilter = {
    is?: RewardWhereInput
    isNot?: RewardWhereInput
  }

  export type POSRewardItemRewardIdPosProviderCompoundUniqueInput = {
    rewardId: string
    posProvider: $Enums.POSProvider
  }

  export type POSRewardItemCountOrderByAggregateInput = {
    id?: SortOrder
    rewardId?: SortOrder
    posProvider?: SortOrder
    posItemId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type POSRewardItemMaxOrderByAggregateInput = {
    id?: SortOrder
    rewardId?: SortOrder
    posProvider?: SortOrder
    posItemId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type POSRewardItemMinOrderByAggregateInput = {
    id?: SortOrder
    rewardId?: SortOrder
    posProvider?: SortOrder
    posItemId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumRedemptionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RedemptionStatus | EnumRedemptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RedemptionStatus[] | ListEnumRedemptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RedemptionStatus[] | ListEnumRedemptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRedemptionStatusFilter<$PrismaModel> | $Enums.RedemptionStatus
  }

  export type LedgerEntryNullableRelationFilter = {
    is?: LedgerEntryWhereInput | null
    isNot?: LedgerEntryWhereInput | null
  }

  export type RedemptionCountOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    merchantId?: SortOrder
    rewardId?: SortOrder
    qrToken?: SortOrder
    pinCode?: SortOrder
    status?: SortOrder
    pointsDeducted?: SortOrder
    redeemedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RedemptionAvgOrderByAggregateInput = {
    pointsDeducted?: SortOrder
  }

  export type RedemptionMaxOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    merchantId?: SortOrder
    rewardId?: SortOrder
    qrToken?: SortOrder
    pinCode?: SortOrder
    status?: SortOrder
    pointsDeducted?: SortOrder
    redeemedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RedemptionMinOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    merchantId?: SortOrder
    rewardId?: SortOrder
    qrToken?: SortOrder
    pinCode?: SortOrder
    status?: SortOrder
    pointsDeducted?: SortOrder
    redeemedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RedemptionSumOrderByAggregateInput = {
    pointsDeducted?: SortOrder
  }

  export type EnumRedemptionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RedemptionStatus | EnumRedemptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RedemptionStatus[] | ListEnumRedemptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RedemptionStatus[] | ListEnumRedemptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRedemptionStatusWithAggregatesFilter<$PrismaModel> | $Enums.RedemptionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRedemptionStatusFilter<$PrismaModel>
    _max?: NestedEnumRedemptionStatusFilter<$PrismaModel>
  }

  export type CustomerItemCountCustomerIdMerchantIdRewardIdItemNameCompoundUniqueInput = {
    customerId: string
    merchantId: string
    rewardId: string
    itemName: string
  }

  export type CustomerItemCountCountOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    merchantId?: SortOrder
    rewardId?: SortOrder
    itemName?: SortOrder
    count?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerItemCountAvgOrderByAggregateInput = {
    count?: SortOrder
  }

  export type CustomerItemCountMaxOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    merchantId?: SortOrder
    rewardId?: SortOrder
    itemName?: SortOrder
    count?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerItemCountMinOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    merchantId?: SortOrder
    rewardId?: SortOrder
    itemName?: SortOrder
    count?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerItemCountSumOrderByAggregateInput = {
    count?: SortOrder
  }

  export type EnumLedgerEntryTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.LedgerEntryType | EnumLedgerEntryTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LedgerEntryType[] | ListEnumLedgerEntryTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LedgerEntryType[] | ListEnumLedgerEntryTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLedgerEntryTypeFilter<$PrismaModel> | $Enums.LedgerEntryType
  }

  export type TransactionNullableRelationFilter = {
    is?: TransactionWhereInput | null
    isNot?: TransactionWhereInput | null
  }

  export type RedemptionNullableRelationFilter = {
    is?: RedemptionWhereInput | null
    isNot?: RedemptionWhereInput | null
  }

  export type LedgerEntryCountOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    merchantId?: SortOrder
    type?: SortOrder
    points?: SortOrder
    transactionId?: SortOrder
    redemptionId?: SortOrder
    createdAt?: SortOrder
  }

  export type LedgerEntryAvgOrderByAggregateInput = {
    points?: SortOrder
  }

  export type LedgerEntryMaxOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    merchantId?: SortOrder
    type?: SortOrder
    points?: SortOrder
    transactionId?: SortOrder
    redemptionId?: SortOrder
    createdAt?: SortOrder
  }

  export type LedgerEntryMinOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    merchantId?: SortOrder
    type?: SortOrder
    points?: SortOrder
    transactionId?: SortOrder
    redemptionId?: SortOrder
    createdAt?: SortOrder
  }

  export type LedgerEntrySumOrderByAggregateInput = {
    points?: SortOrder
  }

  export type EnumLedgerEntryTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LedgerEntryType | EnumLedgerEntryTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LedgerEntryType[] | ListEnumLedgerEntryTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LedgerEntryType[] | ListEnumLedgerEntryTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLedgerEntryTypeWithAggregatesFilter<$PrismaModel> | $Enums.LedgerEntryType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLedgerEntryTypeFilter<$PrismaModel>
    _max?: NestedEnumLedgerEntryTypeFilter<$PrismaModel>
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type EnumWebhookStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.WebhookStatus | EnumWebhookStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WebhookStatus[] | ListEnumWebhookStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WebhookStatus[] | ListEnumWebhookStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWebhookStatusFilter<$PrismaModel> | $Enums.WebhookStatus
  }

  export type WebhookLogCountOrderByAggregateInput = {
    id?: SortOrder
    provider?: SortOrder
    eventType?: SortOrder
    payload?: SortOrder
    signature?: SortOrder
    status?: SortOrder
    errorMessage?: SortOrder
    processedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type WebhookLogMaxOrderByAggregateInput = {
    id?: SortOrder
    provider?: SortOrder
    eventType?: SortOrder
    signature?: SortOrder
    status?: SortOrder
    errorMessage?: SortOrder
    processedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type WebhookLogMinOrderByAggregateInput = {
    id?: SortOrder
    provider?: SortOrder
    eventType?: SortOrder
    signature?: SortOrder
    status?: SortOrder
    errorMessage?: SortOrder
    processedAt?: SortOrder
    createdAt?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type EnumWebhookStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WebhookStatus | EnumWebhookStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WebhookStatus[] | ListEnumWebhookStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WebhookStatus[] | ListEnumWebhookStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWebhookStatusWithAggregatesFilter<$PrismaModel> | $Enums.WebhookStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWebhookStatusFilter<$PrismaModel>
    _max?: NestedEnumWebhookStatusFilter<$PrismaModel>
  }

  export type POSIntegrationCreateNestedManyWithoutMerchantInput = {
    create?: XOR<POSIntegrationCreateWithoutMerchantInput, POSIntegrationUncheckedCreateWithoutMerchantInput> | POSIntegrationCreateWithoutMerchantInput[] | POSIntegrationUncheckedCreateWithoutMerchantInput[]
    connectOrCreate?: POSIntegrationCreateOrConnectWithoutMerchantInput | POSIntegrationCreateOrConnectWithoutMerchantInput[]
    createMany?: POSIntegrationCreateManyMerchantInputEnvelope
    connect?: POSIntegrationWhereUniqueInput | POSIntegrationWhereUniqueInput[]
  }

  export type LocationCreateNestedManyWithoutMerchantInput = {
    create?: XOR<LocationCreateWithoutMerchantInput, LocationUncheckedCreateWithoutMerchantInput> | LocationCreateWithoutMerchantInput[] | LocationUncheckedCreateWithoutMerchantInput[]
    connectOrCreate?: LocationCreateOrConnectWithoutMerchantInput | LocationCreateOrConnectWithoutMerchantInput[]
    createMany?: LocationCreateManyMerchantInputEnvelope
    connect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
  }

  export type RewardCreateNestedManyWithoutMerchantInput = {
    create?: XOR<RewardCreateWithoutMerchantInput, RewardUncheckedCreateWithoutMerchantInput> | RewardCreateWithoutMerchantInput[] | RewardUncheckedCreateWithoutMerchantInput[]
    connectOrCreate?: RewardCreateOrConnectWithoutMerchantInput | RewardCreateOrConnectWithoutMerchantInput[]
    createMany?: RewardCreateManyMerchantInputEnvelope
    connect?: RewardWhereUniqueInput | RewardWhereUniqueInput[]
  }

  export type TransactionCreateNestedManyWithoutMerchantInput = {
    create?: XOR<TransactionCreateWithoutMerchantInput, TransactionUncheckedCreateWithoutMerchantInput> | TransactionCreateWithoutMerchantInput[] | TransactionUncheckedCreateWithoutMerchantInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutMerchantInput | TransactionCreateOrConnectWithoutMerchantInput[]
    createMany?: TransactionCreateManyMerchantInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type RedemptionCreateNestedManyWithoutMerchantInput = {
    create?: XOR<RedemptionCreateWithoutMerchantInput, RedemptionUncheckedCreateWithoutMerchantInput> | RedemptionCreateWithoutMerchantInput[] | RedemptionUncheckedCreateWithoutMerchantInput[]
    connectOrCreate?: RedemptionCreateOrConnectWithoutMerchantInput | RedemptionCreateOrConnectWithoutMerchantInput[]
    createMany?: RedemptionCreateManyMerchantInputEnvelope
    connect?: RedemptionWhereUniqueInput | RedemptionWhereUniqueInput[]
  }

  export type CustomerBalanceCreateNestedManyWithoutMerchantInput = {
    create?: XOR<CustomerBalanceCreateWithoutMerchantInput, CustomerBalanceUncheckedCreateWithoutMerchantInput> | CustomerBalanceCreateWithoutMerchantInput[] | CustomerBalanceUncheckedCreateWithoutMerchantInput[]
    connectOrCreate?: CustomerBalanceCreateOrConnectWithoutMerchantInput | CustomerBalanceCreateOrConnectWithoutMerchantInput[]
    createMany?: CustomerBalanceCreateManyMerchantInputEnvelope
    connect?: CustomerBalanceWhereUniqueInput | CustomerBalanceWhereUniqueInput[]
  }

  export type CustomerItemCountCreateNestedManyWithoutMerchantInput = {
    create?: XOR<CustomerItemCountCreateWithoutMerchantInput, CustomerItemCountUncheckedCreateWithoutMerchantInput> | CustomerItemCountCreateWithoutMerchantInput[] | CustomerItemCountUncheckedCreateWithoutMerchantInput[]
    connectOrCreate?: CustomerItemCountCreateOrConnectWithoutMerchantInput | CustomerItemCountCreateOrConnectWithoutMerchantInput[]
    createMany?: CustomerItemCountCreateManyMerchantInputEnvelope
    connect?: CustomerItemCountWhereUniqueInput | CustomerItemCountWhereUniqueInput[]
  }

  export type LedgerEntryCreateNestedManyWithoutMerchantInput = {
    create?: XOR<LedgerEntryCreateWithoutMerchantInput, LedgerEntryUncheckedCreateWithoutMerchantInput> | LedgerEntryCreateWithoutMerchantInput[] | LedgerEntryUncheckedCreateWithoutMerchantInput[]
    connectOrCreate?: LedgerEntryCreateOrConnectWithoutMerchantInput | LedgerEntryCreateOrConnectWithoutMerchantInput[]
    createMany?: LedgerEntryCreateManyMerchantInputEnvelope
    connect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
  }

  export type POSIntegrationUncheckedCreateNestedManyWithoutMerchantInput = {
    create?: XOR<POSIntegrationCreateWithoutMerchantInput, POSIntegrationUncheckedCreateWithoutMerchantInput> | POSIntegrationCreateWithoutMerchantInput[] | POSIntegrationUncheckedCreateWithoutMerchantInput[]
    connectOrCreate?: POSIntegrationCreateOrConnectWithoutMerchantInput | POSIntegrationCreateOrConnectWithoutMerchantInput[]
    createMany?: POSIntegrationCreateManyMerchantInputEnvelope
    connect?: POSIntegrationWhereUniqueInput | POSIntegrationWhereUniqueInput[]
  }

  export type LocationUncheckedCreateNestedManyWithoutMerchantInput = {
    create?: XOR<LocationCreateWithoutMerchantInput, LocationUncheckedCreateWithoutMerchantInput> | LocationCreateWithoutMerchantInput[] | LocationUncheckedCreateWithoutMerchantInput[]
    connectOrCreate?: LocationCreateOrConnectWithoutMerchantInput | LocationCreateOrConnectWithoutMerchantInput[]
    createMany?: LocationCreateManyMerchantInputEnvelope
    connect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
  }

  export type RewardUncheckedCreateNestedManyWithoutMerchantInput = {
    create?: XOR<RewardCreateWithoutMerchantInput, RewardUncheckedCreateWithoutMerchantInput> | RewardCreateWithoutMerchantInput[] | RewardUncheckedCreateWithoutMerchantInput[]
    connectOrCreate?: RewardCreateOrConnectWithoutMerchantInput | RewardCreateOrConnectWithoutMerchantInput[]
    createMany?: RewardCreateManyMerchantInputEnvelope
    connect?: RewardWhereUniqueInput | RewardWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutMerchantInput = {
    create?: XOR<TransactionCreateWithoutMerchantInput, TransactionUncheckedCreateWithoutMerchantInput> | TransactionCreateWithoutMerchantInput[] | TransactionUncheckedCreateWithoutMerchantInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutMerchantInput | TransactionCreateOrConnectWithoutMerchantInput[]
    createMany?: TransactionCreateManyMerchantInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type RedemptionUncheckedCreateNestedManyWithoutMerchantInput = {
    create?: XOR<RedemptionCreateWithoutMerchantInput, RedemptionUncheckedCreateWithoutMerchantInput> | RedemptionCreateWithoutMerchantInput[] | RedemptionUncheckedCreateWithoutMerchantInput[]
    connectOrCreate?: RedemptionCreateOrConnectWithoutMerchantInput | RedemptionCreateOrConnectWithoutMerchantInput[]
    createMany?: RedemptionCreateManyMerchantInputEnvelope
    connect?: RedemptionWhereUniqueInput | RedemptionWhereUniqueInput[]
  }

  export type CustomerBalanceUncheckedCreateNestedManyWithoutMerchantInput = {
    create?: XOR<CustomerBalanceCreateWithoutMerchantInput, CustomerBalanceUncheckedCreateWithoutMerchantInput> | CustomerBalanceCreateWithoutMerchantInput[] | CustomerBalanceUncheckedCreateWithoutMerchantInput[]
    connectOrCreate?: CustomerBalanceCreateOrConnectWithoutMerchantInput | CustomerBalanceCreateOrConnectWithoutMerchantInput[]
    createMany?: CustomerBalanceCreateManyMerchantInputEnvelope
    connect?: CustomerBalanceWhereUniqueInput | CustomerBalanceWhereUniqueInput[]
  }

  export type CustomerItemCountUncheckedCreateNestedManyWithoutMerchantInput = {
    create?: XOR<CustomerItemCountCreateWithoutMerchantInput, CustomerItemCountUncheckedCreateWithoutMerchantInput> | CustomerItemCountCreateWithoutMerchantInput[] | CustomerItemCountUncheckedCreateWithoutMerchantInput[]
    connectOrCreate?: CustomerItemCountCreateOrConnectWithoutMerchantInput | CustomerItemCountCreateOrConnectWithoutMerchantInput[]
    createMany?: CustomerItemCountCreateManyMerchantInputEnvelope
    connect?: CustomerItemCountWhereUniqueInput | CustomerItemCountWhereUniqueInput[]
  }

  export type LedgerEntryUncheckedCreateNestedManyWithoutMerchantInput = {
    create?: XOR<LedgerEntryCreateWithoutMerchantInput, LedgerEntryUncheckedCreateWithoutMerchantInput> | LedgerEntryCreateWithoutMerchantInput[] | LedgerEntryUncheckedCreateWithoutMerchantInput[]
    connectOrCreate?: LedgerEntryCreateOrConnectWithoutMerchantInput | LedgerEntryCreateOrConnectWithoutMerchantInput[]
    createMany?: LedgerEntryCreateManyMerchantInputEnvelope
    connect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type POSIntegrationUpdateManyWithoutMerchantNestedInput = {
    create?: XOR<POSIntegrationCreateWithoutMerchantInput, POSIntegrationUncheckedCreateWithoutMerchantInput> | POSIntegrationCreateWithoutMerchantInput[] | POSIntegrationUncheckedCreateWithoutMerchantInput[]
    connectOrCreate?: POSIntegrationCreateOrConnectWithoutMerchantInput | POSIntegrationCreateOrConnectWithoutMerchantInput[]
    upsert?: POSIntegrationUpsertWithWhereUniqueWithoutMerchantInput | POSIntegrationUpsertWithWhereUniqueWithoutMerchantInput[]
    createMany?: POSIntegrationCreateManyMerchantInputEnvelope
    set?: POSIntegrationWhereUniqueInput | POSIntegrationWhereUniqueInput[]
    disconnect?: POSIntegrationWhereUniqueInput | POSIntegrationWhereUniqueInput[]
    delete?: POSIntegrationWhereUniqueInput | POSIntegrationWhereUniqueInput[]
    connect?: POSIntegrationWhereUniqueInput | POSIntegrationWhereUniqueInput[]
    update?: POSIntegrationUpdateWithWhereUniqueWithoutMerchantInput | POSIntegrationUpdateWithWhereUniqueWithoutMerchantInput[]
    updateMany?: POSIntegrationUpdateManyWithWhereWithoutMerchantInput | POSIntegrationUpdateManyWithWhereWithoutMerchantInput[]
    deleteMany?: POSIntegrationScalarWhereInput | POSIntegrationScalarWhereInput[]
  }

  export type LocationUpdateManyWithoutMerchantNestedInput = {
    create?: XOR<LocationCreateWithoutMerchantInput, LocationUncheckedCreateWithoutMerchantInput> | LocationCreateWithoutMerchantInput[] | LocationUncheckedCreateWithoutMerchantInput[]
    connectOrCreate?: LocationCreateOrConnectWithoutMerchantInput | LocationCreateOrConnectWithoutMerchantInput[]
    upsert?: LocationUpsertWithWhereUniqueWithoutMerchantInput | LocationUpsertWithWhereUniqueWithoutMerchantInput[]
    createMany?: LocationCreateManyMerchantInputEnvelope
    set?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    disconnect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    delete?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    connect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    update?: LocationUpdateWithWhereUniqueWithoutMerchantInput | LocationUpdateWithWhereUniqueWithoutMerchantInput[]
    updateMany?: LocationUpdateManyWithWhereWithoutMerchantInput | LocationUpdateManyWithWhereWithoutMerchantInput[]
    deleteMany?: LocationScalarWhereInput | LocationScalarWhereInput[]
  }

  export type RewardUpdateManyWithoutMerchantNestedInput = {
    create?: XOR<RewardCreateWithoutMerchantInput, RewardUncheckedCreateWithoutMerchantInput> | RewardCreateWithoutMerchantInput[] | RewardUncheckedCreateWithoutMerchantInput[]
    connectOrCreate?: RewardCreateOrConnectWithoutMerchantInput | RewardCreateOrConnectWithoutMerchantInput[]
    upsert?: RewardUpsertWithWhereUniqueWithoutMerchantInput | RewardUpsertWithWhereUniqueWithoutMerchantInput[]
    createMany?: RewardCreateManyMerchantInputEnvelope
    set?: RewardWhereUniqueInput | RewardWhereUniqueInput[]
    disconnect?: RewardWhereUniqueInput | RewardWhereUniqueInput[]
    delete?: RewardWhereUniqueInput | RewardWhereUniqueInput[]
    connect?: RewardWhereUniqueInput | RewardWhereUniqueInput[]
    update?: RewardUpdateWithWhereUniqueWithoutMerchantInput | RewardUpdateWithWhereUniqueWithoutMerchantInput[]
    updateMany?: RewardUpdateManyWithWhereWithoutMerchantInput | RewardUpdateManyWithWhereWithoutMerchantInput[]
    deleteMany?: RewardScalarWhereInput | RewardScalarWhereInput[]
  }

  export type TransactionUpdateManyWithoutMerchantNestedInput = {
    create?: XOR<TransactionCreateWithoutMerchantInput, TransactionUncheckedCreateWithoutMerchantInput> | TransactionCreateWithoutMerchantInput[] | TransactionUncheckedCreateWithoutMerchantInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutMerchantInput | TransactionCreateOrConnectWithoutMerchantInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutMerchantInput | TransactionUpsertWithWhereUniqueWithoutMerchantInput[]
    createMany?: TransactionCreateManyMerchantInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutMerchantInput | TransactionUpdateWithWhereUniqueWithoutMerchantInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutMerchantInput | TransactionUpdateManyWithWhereWithoutMerchantInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type RedemptionUpdateManyWithoutMerchantNestedInput = {
    create?: XOR<RedemptionCreateWithoutMerchantInput, RedemptionUncheckedCreateWithoutMerchantInput> | RedemptionCreateWithoutMerchantInput[] | RedemptionUncheckedCreateWithoutMerchantInput[]
    connectOrCreate?: RedemptionCreateOrConnectWithoutMerchantInput | RedemptionCreateOrConnectWithoutMerchantInput[]
    upsert?: RedemptionUpsertWithWhereUniqueWithoutMerchantInput | RedemptionUpsertWithWhereUniqueWithoutMerchantInput[]
    createMany?: RedemptionCreateManyMerchantInputEnvelope
    set?: RedemptionWhereUniqueInput | RedemptionWhereUniqueInput[]
    disconnect?: RedemptionWhereUniqueInput | RedemptionWhereUniqueInput[]
    delete?: RedemptionWhereUniqueInput | RedemptionWhereUniqueInput[]
    connect?: RedemptionWhereUniqueInput | RedemptionWhereUniqueInput[]
    update?: RedemptionUpdateWithWhereUniqueWithoutMerchantInput | RedemptionUpdateWithWhereUniqueWithoutMerchantInput[]
    updateMany?: RedemptionUpdateManyWithWhereWithoutMerchantInput | RedemptionUpdateManyWithWhereWithoutMerchantInput[]
    deleteMany?: RedemptionScalarWhereInput | RedemptionScalarWhereInput[]
  }

  export type CustomerBalanceUpdateManyWithoutMerchantNestedInput = {
    create?: XOR<CustomerBalanceCreateWithoutMerchantInput, CustomerBalanceUncheckedCreateWithoutMerchantInput> | CustomerBalanceCreateWithoutMerchantInput[] | CustomerBalanceUncheckedCreateWithoutMerchantInput[]
    connectOrCreate?: CustomerBalanceCreateOrConnectWithoutMerchantInput | CustomerBalanceCreateOrConnectWithoutMerchantInput[]
    upsert?: CustomerBalanceUpsertWithWhereUniqueWithoutMerchantInput | CustomerBalanceUpsertWithWhereUniqueWithoutMerchantInput[]
    createMany?: CustomerBalanceCreateManyMerchantInputEnvelope
    set?: CustomerBalanceWhereUniqueInput | CustomerBalanceWhereUniqueInput[]
    disconnect?: CustomerBalanceWhereUniqueInput | CustomerBalanceWhereUniqueInput[]
    delete?: CustomerBalanceWhereUniqueInput | CustomerBalanceWhereUniqueInput[]
    connect?: CustomerBalanceWhereUniqueInput | CustomerBalanceWhereUniqueInput[]
    update?: CustomerBalanceUpdateWithWhereUniqueWithoutMerchantInput | CustomerBalanceUpdateWithWhereUniqueWithoutMerchantInput[]
    updateMany?: CustomerBalanceUpdateManyWithWhereWithoutMerchantInput | CustomerBalanceUpdateManyWithWhereWithoutMerchantInput[]
    deleteMany?: CustomerBalanceScalarWhereInput | CustomerBalanceScalarWhereInput[]
  }

  export type CustomerItemCountUpdateManyWithoutMerchantNestedInput = {
    create?: XOR<CustomerItemCountCreateWithoutMerchantInput, CustomerItemCountUncheckedCreateWithoutMerchantInput> | CustomerItemCountCreateWithoutMerchantInput[] | CustomerItemCountUncheckedCreateWithoutMerchantInput[]
    connectOrCreate?: CustomerItemCountCreateOrConnectWithoutMerchantInput | CustomerItemCountCreateOrConnectWithoutMerchantInput[]
    upsert?: CustomerItemCountUpsertWithWhereUniqueWithoutMerchantInput | CustomerItemCountUpsertWithWhereUniqueWithoutMerchantInput[]
    createMany?: CustomerItemCountCreateManyMerchantInputEnvelope
    set?: CustomerItemCountWhereUniqueInput | CustomerItemCountWhereUniqueInput[]
    disconnect?: CustomerItemCountWhereUniqueInput | CustomerItemCountWhereUniqueInput[]
    delete?: CustomerItemCountWhereUniqueInput | CustomerItemCountWhereUniqueInput[]
    connect?: CustomerItemCountWhereUniqueInput | CustomerItemCountWhereUniqueInput[]
    update?: CustomerItemCountUpdateWithWhereUniqueWithoutMerchantInput | CustomerItemCountUpdateWithWhereUniqueWithoutMerchantInput[]
    updateMany?: CustomerItemCountUpdateManyWithWhereWithoutMerchantInput | CustomerItemCountUpdateManyWithWhereWithoutMerchantInput[]
    deleteMany?: CustomerItemCountScalarWhereInput | CustomerItemCountScalarWhereInput[]
  }

  export type LedgerEntryUpdateManyWithoutMerchantNestedInput = {
    create?: XOR<LedgerEntryCreateWithoutMerchantInput, LedgerEntryUncheckedCreateWithoutMerchantInput> | LedgerEntryCreateWithoutMerchantInput[] | LedgerEntryUncheckedCreateWithoutMerchantInput[]
    connectOrCreate?: LedgerEntryCreateOrConnectWithoutMerchantInput | LedgerEntryCreateOrConnectWithoutMerchantInput[]
    upsert?: LedgerEntryUpsertWithWhereUniqueWithoutMerchantInput | LedgerEntryUpsertWithWhereUniqueWithoutMerchantInput[]
    createMany?: LedgerEntryCreateManyMerchantInputEnvelope
    set?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    disconnect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    delete?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    connect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    update?: LedgerEntryUpdateWithWhereUniqueWithoutMerchantInput | LedgerEntryUpdateWithWhereUniqueWithoutMerchantInput[]
    updateMany?: LedgerEntryUpdateManyWithWhereWithoutMerchantInput | LedgerEntryUpdateManyWithWhereWithoutMerchantInput[]
    deleteMany?: LedgerEntryScalarWhereInput | LedgerEntryScalarWhereInput[]
  }

  export type POSIntegrationUncheckedUpdateManyWithoutMerchantNestedInput = {
    create?: XOR<POSIntegrationCreateWithoutMerchantInput, POSIntegrationUncheckedCreateWithoutMerchantInput> | POSIntegrationCreateWithoutMerchantInput[] | POSIntegrationUncheckedCreateWithoutMerchantInput[]
    connectOrCreate?: POSIntegrationCreateOrConnectWithoutMerchantInput | POSIntegrationCreateOrConnectWithoutMerchantInput[]
    upsert?: POSIntegrationUpsertWithWhereUniqueWithoutMerchantInput | POSIntegrationUpsertWithWhereUniqueWithoutMerchantInput[]
    createMany?: POSIntegrationCreateManyMerchantInputEnvelope
    set?: POSIntegrationWhereUniqueInput | POSIntegrationWhereUniqueInput[]
    disconnect?: POSIntegrationWhereUniqueInput | POSIntegrationWhereUniqueInput[]
    delete?: POSIntegrationWhereUniqueInput | POSIntegrationWhereUniqueInput[]
    connect?: POSIntegrationWhereUniqueInput | POSIntegrationWhereUniqueInput[]
    update?: POSIntegrationUpdateWithWhereUniqueWithoutMerchantInput | POSIntegrationUpdateWithWhereUniqueWithoutMerchantInput[]
    updateMany?: POSIntegrationUpdateManyWithWhereWithoutMerchantInput | POSIntegrationUpdateManyWithWhereWithoutMerchantInput[]
    deleteMany?: POSIntegrationScalarWhereInput | POSIntegrationScalarWhereInput[]
  }

  export type LocationUncheckedUpdateManyWithoutMerchantNestedInput = {
    create?: XOR<LocationCreateWithoutMerchantInput, LocationUncheckedCreateWithoutMerchantInput> | LocationCreateWithoutMerchantInput[] | LocationUncheckedCreateWithoutMerchantInput[]
    connectOrCreate?: LocationCreateOrConnectWithoutMerchantInput | LocationCreateOrConnectWithoutMerchantInput[]
    upsert?: LocationUpsertWithWhereUniqueWithoutMerchantInput | LocationUpsertWithWhereUniqueWithoutMerchantInput[]
    createMany?: LocationCreateManyMerchantInputEnvelope
    set?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    disconnect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    delete?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    connect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    update?: LocationUpdateWithWhereUniqueWithoutMerchantInput | LocationUpdateWithWhereUniqueWithoutMerchantInput[]
    updateMany?: LocationUpdateManyWithWhereWithoutMerchantInput | LocationUpdateManyWithWhereWithoutMerchantInput[]
    deleteMany?: LocationScalarWhereInput | LocationScalarWhereInput[]
  }

  export type RewardUncheckedUpdateManyWithoutMerchantNestedInput = {
    create?: XOR<RewardCreateWithoutMerchantInput, RewardUncheckedCreateWithoutMerchantInput> | RewardCreateWithoutMerchantInput[] | RewardUncheckedCreateWithoutMerchantInput[]
    connectOrCreate?: RewardCreateOrConnectWithoutMerchantInput | RewardCreateOrConnectWithoutMerchantInput[]
    upsert?: RewardUpsertWithWhereUniqueWithoutMerchantInput | RewardUpsertWithWhereUniqueWithoutMerchantInput[]
    createMany?: RewardCreateManyMerchantInputEnvelope
    set?: RewardWhereUniqueInput | RewardWhereUniqueInput[]
    disconnect?: RewardWhereUniqueInput | RewardWhereUniqueInput[]
    delete?: RewardWhereUniqueInput | RewardWhereUniqueInput[]
    connect?: RewardWhereUniqueInput | RewardWhereUniqueInput[]
    update?: RewardUpdateWithWhereUniqueWithoutMerchantInput | RewardUpdateWithWhereUniqueWithoutMerchantInput[]
    updateMany?: RewardUpdateManyWithWhereWithoutMerchantInput | RewardUpdateManyWithWhereWithoutMerchantInput[]
    deleteMany?: RewardScalarWhereInput | RewardScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutMerchantNestedInput = {
    create?: XOR<TransactionCreateWithoutMerchantInput, TransactionUncheckedCreateWithoutMerchantInput> | TransactionCreateWithoutMerchantInput[] | TransactionUncheckedCreateWithoutMerchantInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutMerchantInput | TransactionCreateOrConnectWithoutMerchantInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutMerchantInput | TransactionUpsertWithWhereUniqueWithoutMerchantInput[]
    createMany?: TransactionCreateManyMerchantInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutMerchantInput | TransactionUpdateWithWhereUniqueWithoutMerchantInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutMerchantInput | TransactionUpdateManyWithWhereWithoutMerchantInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type RedemptionUncheckedUpdateManyWithoutMerchantNestedInput = {
    create?: XOR<RedemptionCreateWithoutMerchantInput, RedemptionUncheckedCreateWithoutMerchantInput> | RedemptionCreateWithoutMerchantInput[] | RedemptionUncheckedCreateWithoutMerchantInput[]
    connectOrCreate?: RedemptionCreateOrConnectWithoutMerchantInput | RedemptionCreateOrConnectWithoutMerchantInput[]
    upsert?: RedemptionUpsertWithWhereUniqueWithoutMerchantInput | RedemptionUpsertWithWhereUniqueWithoutMerchantInput[]
    createMany?: RedemptionCreateManyMerchantInputEnvelope
    set?: RedemptionWhereUniqueInput | RedemptionWhereUniqueInput[]
    disconnect?: RedemptionWhereUniqueInput | RedemptionWhereUniqueInput[]
    delete?: RedemptionWhereUniqueInput | RedemptionWhereUniqueInput[]
    connect?: RedemptionWhereUniqueInput | RedemptionWhereUniqueInput[]
    update?: RedemptionUpdateWithWhereUniqueWithoutMerchantInput | RedemptionUpdateWithWhereUniqueWithoutMerchantInput[]
    updateMany?: RedemptionUpdateManyWithWhereWithoutMerchantInput | RedemptionUpdateManyWithWhereWithoutMerchantInput[]
    deleteMany?: RedemptionScalarWhereInput | RedemptionScalarWhereInput[]
  }

  export type CustomerBalanceUncheckedUpdateManyWithoutMerchantNestedInput = {
    create?: XOR<CustomerBalanceCreateWithoutMerchantInput, CustomerBalanceUncheckedCreateWithoutMerchantInput> | CustomerBalanceCreateWithoutMerchantInput[] | CustomerBalanceUncheckedCreateWithoutMerchantInput[]
    connectOrCreate?: CustomerBalanceCreateOrConnectWithoutMerchantInput | CustomerBalanceCreateOrConnectWithoutMerchantInput[]
    upsert?: CustomerBalanceUpsertWithWhereUniqueWithoutMerchantInput | CustomerBalanceUpsertWithWhereUniqueWithoutMerchantInput[]
    createMany?: CustomerBalanceCreateManyMerchantInputEnvelope
    set?: CustomerBalanceWhereUniqueInput | CustomerBalanceWhereUniqueInput[]
    disconnect?: CustomerBalanceWhereUniqueInput | CustomerBalanceWhereUniqueInput[]
    delete?: CustomerBalanceWhereUniqueInput | CustomerBalanceWhereUniqueInput[]
    connect?: CustomerBalanceWhereUniqueInput | CustomerBalanceWhereUniqueInput[]
    update?: CustomerBalanceUpdateWithWhereUniqueWithoutMerchantInput | CustomerBalanceUpdateWithWhereUniqueWithoutMerchantInput[]
    updateMany?: CustomerBalanceUpdateManyWithWhereWithoutMerchantInput | CustomerBalanceUpdateManyWithWhereWithoutMerchantInput[]
    deleteMany?: CustomerBalanceScalarWhereInput | CustomerBalanceScalarWhereInput[]
  }

  export type CustomerItemCountUncheckedUpdateManyWithoutMerchantNestedInput = {
    create?: XOR<CustomerItemCountCreateWithoutMerchantInput, CustomerItemCountUncheckedCreateWithoutMerchantInput> | CustomerItemCountCreateWithoutMerchantInput[] | CustomerItemCountUncheckedCreateWithoutMerchantInput[]
    connectOrCreate?: CustomerItemCountCreateOrConnectWithoutMerchantInput | CustomerItemCountCreateOrConnectWithoutMerchantInput[]
    upsert?: CustomerItemCountUpsertWithWhereUniqueWithoutMerchantInput | CustomerItemCountUpsertWithWhereUniqueWithoutMerchantInput[]
    createMany?: CustomerItemCountCreateManyMerchantInputEnvelope
    set?: CustomerItemCountWhereUniqueInput | CustomerItemCountWhereUniqueInput[]
    disconnect?: CustomerItemCountWhereUniqueInput | CustomerItemCountWhereUniqueInput[]
    delete?: CustomerItemCountWhereUniqueInput | CustomerItemCountWhereUniqueInput[]
    connect?: CustomerItemCountWhereUniqueInput | CustomerItemCountWhereUniqueInput[]
    update?: CustomerItemCountUpdateWithWhereUniqueWithoutMerchantInput | CustomerItemCountUpdateWithWhereUniqueWithoutMerchantInput[]
    updateMany?: CustomerItemCountUpdateManyWithWhereWithoutMerchantInput | CustomerItemCountUpdateManyWithWhereWithoutMerchantInput[]
    deleteMany?: CustomerItemCountScalarWhereInput | CustomerItemCountScalarWhereInput[]
  }

  export type LedgerEntryUncheckedUpdateManyWithoutMerchantNestedInput = {
    create?: XOR<LedgerEntryCreateWithoutMerchantInput, LedgerEntryUncheckedCreateWithoutMerchantInput> | LedgerEntryCreateWithoutMerchantInput[] | LedgerEntryUncheckedCreateWithoutMerchantInput[]
    connectOrCreate?: LedgerEntryCreateOrConnectWithoutMerchantInput | LedgerEntryCreateOrConnectWithoutMerchantInput[]
    upsert?: LedgerEntryUpsertWithWhereUniqueWithoutMerchantInput | LedgerEntryUpsertWithWhereUniqueWithoutMerchantInput[]
    createMany?: LedgerEntryCreateManyMerchantInputEnvelope
    set?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    disconnect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    delete?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    connect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    update?: LedgerEntryUpdateWithWhereUniqueWithoutMerchantInput | LedgerEntryUpdateWithWhereUniqueWithoutMerchantInput[]
    updateMany?: LedgerEntryUpdateManyWithWhereWithoutMerchantInput | LedgerEntryUpdateManyWithWhereWithoutMerchantInput[]
    deleteMany?: LedgerEntryScalarWhereInput | LedgerEntryScalarWhereInput[]
  }

  export type MerchantCreateNestedOneWithoutPosIntegrationsInput = {
    create?: XOR<MerchantCreateWithoutPosIntegrationsInput, MerchantUncheckedCreateWithoutPosIntegrationsInput>
    connectOrCreate?: MerchantCreateOrConnectWithoutPosIntegrationsInput
    connect?: MerchantWhereUniqueInput
  }

  export type LocationCreateNestedManyWithoutPosIntegrationInput = {
    create?: XOR<LocationCreateWithoutPosIntegrationInput, LocationUncheckedCreateWithoutPosIntegrationInput> | LocationCreateWithoutPosIntegrationInput[] | LocationUncheckedCreateWithoutPosIntegrationInput[]
    connectOrCreate?: LocationCreateOrConnectWithoutPosIntegrationInput | LocationCreateOrConnectWithoutPosIntegrationInput[]
    createMany?: LocationCreateManyPosIntegrationInputEnvelope
    connect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
  }

  export type LocationUncheckedCreateNestedManyWithoutPosIntegrationInput = {
    create?: XOR<LocationCreateWithoutPosIntegrationInput, LocationUncheckedCreateWithoutPosIntegrationInput> | LocationCreateWithoutPosIntegrationInput[] | LocationUncheckedCreateWithoutPosIntegrationInput[]
    connectOrCreate?: LocationCreateOrConnectWithoutPosIntegrationInput | LocationCreateOrConnectWithoutPosIntegrationInput[]
    createMany?: LocationCreateManyPosIntegrationInputEnvelope
    connect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
  }

  export type EnumPOSProviderFieldUpdateOperationsInput = {
    set?: $Enums.POSProvider
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type MerchantUpdateOneRequiredWithoutPosIntegrationsNestedInput = {
    create?: XOR<MerchantCreateWithoutPosIntegrationsInput, MerchantUncheckedCreateWithoutPosIntegrationsInput>
    connectOrCreate?: MerchantCreateOrConnectWithoutPosIntegrationsInput
    upsert?: MerchantUpsertWithoutPosIntegrationsInput
    connect?: MerchantWhereUniqueInput
    update?: XOR<XOR<MerchantUpdateToOneWithWhereWithoutPosIntegrationsInput, MerchantUpdateWithoutPosIntegrationsInput>, MerchantUncheckedUpdateWithoutPosIntegrationsInput>
  }

  export type LocationUpdateManyWithoutPosIntegrationNestedInput = {
    create?: XOR<LocationCreateWithoutPosIntegrationInput, LocationUncheckedCreateWithoutPosIntegrationInput> | LocationCreateWithoutPosIntegrationInput[] | LocationUncheckedCreateWithoutPosIntegrationInput[]
    connectOrCreate?: LocationCreateOrConnectWithoutPosIntegrationInput | LocationCreateOrConnectWithoutPosIntegrationInput[]
    upsert?: LocationUpsertWithWhereUniqueWithoutPosIntegrationInput | LocationUpsertWithWhereUniqueWithoutPosIntegrationInput[]
    createMany?: LocationCreateManyPosIntegrationInputEnvelope
    set?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    disconnect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    delete?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    connect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    update?: LocationUpdateWithWhereUniqueWithoutPosIntegrationInput | LocationUpdateWithWhereUniqueWithoutPosIntegrationInput[]
    updateMany?: LocationUpdateManyWithWhereWithoutPosIntegrationInput | LocationUpdateManyWithWhereWithoutPosIntegrationInput[]
    deleteMany?: LocationScalarWhereInput | LocationScalarWhereInput[]
  }

  export type LocationUncheckedUpdateManyWithoutPosIntegrationNestedInput = {
    create?: XOR<LocationCreateWithoutPosIntegrationInput, LocationUncheckedCreateWithoutPosIntegrationInput> | LocationCreateWithoutPosIntegrationInput[] | LocationUncheckedCreateWithoutPosIntegrationInput[]
    connectOrCreate?: LocationCreateOrConnectWithoutPosIntegrationInput | LocationCreateOrConnectWithoutPosIntegrationInput[]
    upsert?: LocationUpsertWithWhereUniqueWithoutPosIntegrationInput | LocationUpsertWithWhereUniqueWithoutPosIntegrationInput[]
    createMany?: LocationCreateManyPosIntegrationInputEnvelope
    set?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    disconnect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    delete?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    connect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    update?: LocationUpdateWithWhereUniqueWithoutPosIntegrationInput | LocationUpdateWithWhereUniqueWithoutPosIntegrationInput[]
    updateMany?: LocationUpdateManyWithWhereWithoutPosIntegrationInput | LocationUpdateManyWithWhereWithoutPosIntegrationInput[]
    deleteMany?: LocationScalarWhereInput | LocationScalarWhereInput[]
  }

  export type MerchantCreateNestedOneWithoutLocationsInput = {
    create?: XOR<MerchantCreateWithoutLocationsInput, MerchantUncheckedCreateWithoutLocationsInput>
    connectOrCreate?: MerchantCreateOrConnectWithoutLocationsInput
    connect?: MerchantWhereUniqueInput
  }

  export type POSIntegrationCreateNestedOneWithoutLocationsInput = {
    create?: XOR<POSIntegrationCreateWithoutLocationsInput, POSIntegrationUncheckedCreateWithoutLocationsInput>
    connectOrCreate?: POSIntegrationCreateOrConnectWithoutLocationsInput
    connect?: POSIntegrationWhereUniqueInput
  }

  export type TransactionCreateNestedManyWithoutLocationInput = {
    create?: XOR<TransactionCreateWithoutLocationInput, TransactionUncheckedCreateWithoutLocationInput> | TransactionCreateWithoutLocationInput[] | TransactionUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutLocationInput | TransactionCreateOrConnectWithoutLocationInput[]
    createMany?: TransactionCreateManyLocationInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutLocationInput = {
    create?: XOR<TransactionCreateWithoutLocationInput, TransactionUncheckedCreateWithoutLocationInput> | TransactionCreateWithoutLocationInput[] | TransactionUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutLocationInput | TransactionCreateOrConnectWithoutLocationInput[]
    createMany?: TransactionCreateManyLocationInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type MerchantUpdateOneRequiredWithoutLocationsNestedInput = {
    create?: XOR<MerchantCreateWithoutLocationsInput, MerchantUncheckedCreateWithoutLocationsInput>
    connectOrCreate?: MerchantCreateOrConnectWithoutLocationsInput
    upsert?: MerchantUpsertWithoutLocationsInput
    connect?: MerchantWhereUniqueInput
    update?: XOR<XOR<MerchantUpdateToOneWithWhereWithoutLocationsInput, MerchantUpdateWithoutLocationsInput>, MerchantUncheckedUpdateWithoutLocationsInput>
  }

  export type POSIntegrationUpdateOneRequiredWithoutLocationsNestedInput = {
    create?: XOR<POSIntegrationCreateWithoutLocationsInput, POSIntegrationUncheckedCreateWithoutLocationsInput>
    connectOrCreate?: POSIntegrationCreateOrConnectWithoutLocationsInput
    upsert?: POSIntegrationUpsertWithoutLocationsInput
    connect?: POSIntegrationWhereUniqueInput
    update?: XOR<XOR<POSIntegrationUpdateToOneWithWhereWithoutLocationsInput, POSIntegrationUpdateWithoutLocationsInput>, POSIntegrationUncheckedUpdateWithoutLocationsInput>
  }

  export type TransactionUpdateManyWithoutLocationNestedInput = {
    create?: XOR<TransactionCreateWithoutLocationInput, TransactionUncheckedCreateWithoutLocationInput> | TransactionCreateWithoutLocationInput[] | TransactionUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutLocationInput | TransactionCreateOrConnectWithoutLocationInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutLocationInput | TransactionUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: TransactionCreateManyLocationInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutLocationInput | TransactionUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutLocationInput | TransactionUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutLocationNestedInput = {
    create?: XOR<TransactionCreateWithoutLocationInput, TransactionUncheckedCreateWithoutLocationInput> | TransactionCreateWithoutLocationInput[] | TransactionUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutLocationInput | TransactionCreateOrConnectWithoutLocationInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutLocationInput | TransactionUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: TransactionCreateManyLocationInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutLocationInput | TransactionUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutLocationInput | TransactionUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type LinkedCardCreateNestedManyWithoutCustomerInput = {
    create?: XOR<LinkedCardCreateWithoutCustomerInput, LinkedCardUncheckedCreateWithoutCustomerInput> | LinkedCardCreateWithoutCustomerInput[] | LinkedCardUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: LinkedCardCreateOrConnectWithoutCustomerInput | LinkedCardCreateOrConnectWithoutCustomerInput[]
    createMany?: LinkedCardCreateManyCustomerInputEnvelope
    connect?: LinkedCardWhereUniqueInput | LinkedCardWhereUniqueInput[]
  }

  export type TransactionCreateNestedManyWithoutCustomerInput = {
    create?: XOR<TransactionCreateWithoutCustomerInput, TransactionUncheckedCreateWithoutCustomerInput> | TransactionCreateWithoutCustomerInput[] | TransactionUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutCustomerInput | TransactionCreateOrConnectWithoutCustomerInput[]
    createMany?: TransactionCreateManyCustomerInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type CustomerBalanceCreateNestedManyWithoutCustomerInput = {
    create?: XOR<CustomerBalanceCreateWithoutCustomerInput, CustomerBalanceUncheckedCreateWithoutCustomerInput> | CustomerBalanceCreateWithoutCustomerInput[] | CustomerBalanceUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CustomerBalanceCreateOrConnectWithoutCustomerInput | CustomerBalanceCreateOrConnectWithoutCustomerInput[]
    createMany?: CustomerBalanceCreateManyCustomerInputEnvelope
    connect?: CustomerBalanceWhereUniqueInput | CustomerBalanceWhereUniqueInput[]
  }

  export type RedemptionCreateNestedManyWithoutCustomerInput = {
    create?: XOR<RedemptionCreateWithoutCustomerInput, RedemptionUncheckedCreateWithoutCustomerInput> | RedemptionCreateWithoutCustomerInput[] | RedemptionUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: RedemptionCreateOrConnectWithoutCustomerInput | RedemptionCreateOrConnectWithoutCustomerInput[]
    createMany?: RedemptionCreateManyCustomerInputEnvelope
    connect?: RedemptionWhereUniqueInput | RedemptionWhereUniqueInput[]
  }

  export type LedgerEntryCreateNestedManyWithoutCustomerInput = {
    create?: XOR<LedgerEntryCreateWithoutCustomerInput, LedgerEntryUncheckedCreateWithoutCustomerInput> | LedgerEntryCreateWithoutCustomerInput[] | LedgerEntryUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: LedgerEntryCreateOrConnectWithoutCustomerInput | LedgerEntryCreateOrConnectWithoutCustomerInput[]
    createMany?: LedgerEntryCreateManyCustomerInputEnvelope
    connect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
  }

  export type CustomerItemCountCreateNestedManyWithoutCustomerInput = {
    create?: XOR<CustomerItemCountCreateWithoutCustomerInput, CustomerItemCountUncheckedCreateWithoutCustomerInput> | CustomerItemCountCreateWithoutCustomerInput[] | CustomerItemCountUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CustomerItemCountCreateOrConnectWithoutCustomerInput | CustomerItemCountCreateOrConnectWithoutCustomerInput[]
    createMany?: CustomerItemCountCreateManyCustomerInputEnvelope
    connect?: CustomerItemCountWhereUniqueInput | CustomerItemCountWhereUniqueInput[]
  }

  export type LinkedCardUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<LinkedCardCreateWithoutCustomerInput, LinkedCardUncheckedCreateWithoutCustomerInput> | LinkedCardCreateWithoutCustomerInput[] | LinkedCardUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: LinkedCardCreateOrConnectWithoutCustomerInput | LinkedCardCreateOrConnectWithoutCustomerInput[]
    createMany?: LinkedCardCreateManyCustomerInputEnvelope
    connect?: LinkedCardWhereUniqueInput | LinkedCardWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<TransactionCreateWithoutCustomerInput, TransactionUncheckedCreateWithoutCustomerInput> | TransactionCreateWithoutCustomerInput[] | TransactionUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutCustomerInput | TransactionCreateOrConnectWithoutCustomerInput[]
    createMany?: TransactionCreateManyCustomerInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type CustomerBalanceUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<CustomerBalanceCreateWithoutCustomerInput, CustomerBalanceUncheckedCreateWithoutCustomerInput> | CustomerBalanceCreateWithoutCustomerInput[] | CustomerBalanceUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CustomerBalanceCreateOrConnectWithoutCustomerInput | CustomerBalanceCreateOrConnectWithoutCustomerInput[]
    createMany?: CustomerBalanceCreateManyCustomerInputEnvelope
    connect?: CustomerBalanceWhereUniqueInput | CustomerBalanceWhereUniqueInput[]
  }

  export type RedemptionUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<RedemptionCreateWithoutCustomerInput, RedemptionUncheckedCreateWithoutCustomerInput> | RedemptionCreateWithoutCustomerInput[] | RedemptionUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: RedemptionCreateOrConnectWithoutCustomerInput | RedemptionCreateOrConnectWithoutCustomerInput[]
    createMany?: RedemptionCreateManyCustomerInputEnvelope
    connect?: RedemptionWhereUniqueInput | RedemptionWhereUniqueInput[]
  }

  export type LedgerEntryUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<LedgerEntryCreateWithoutCustomerInput, LedgerEntryUncheckedCreateWithoutCustomerInput> | LedgerEntryCreateWithoutCustomerInput[] | LedgerEntryUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: LedgerEntryCreateOrConnectWithoutCustomerInput | LedgerEntryCreateOrConnectWithoutCustomerInput[]
    createMany?: LedgerEntryCreateManyCustomerInputEnvelope
    connect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
  }

  export type CustomerItemCountUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<CustomerItemCountCreateWithoutCustomerInput, CustomerItemCountUncheckedCreateWithoutCustomerInput> | CustomerItemCountCreateWithoutCustomerInput[] | CustomerItemCountUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CustomerItemCountCreateOrConnectWithoutCustomerInput | CustomerItemCountCreateOrConnectWithoutCustomerInput[]
    createMany?: CustomerItemCountCreateManyCustomerInputEnvelope
    connect?: CustomerItemCountWhereUniqueInput | CustomerItemCountWhereUniqueInput[]
  }

  export type LinkedCardUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<LinkedCardCreateWithoutCustomerInput, LinkedCardUncheckedCreateWithoutCustomerInput> | LinkedCardCreateWithoutCustomerInput[] | LinkedCardUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: LinkedCardCreateOrConnectWithoutCustomerInput | LinkedCardCreateOrConnectWithoutCustomerInput[]
    upsert?: LinkedCardUpsertWithWhereUniqueWithoutCustomerInput | LinkedCardUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: LinkedCardCreateManyCustomerInputEnvelope
    set?: LinkedCardWhereUniqueInput | LinkedCardWhereUniqueInput[]
    disconnect?: LinkedCardWhereUniqueInput | LinkedCardWhereUniqueInput[]
    delete?: LinkedCardWhereUniqueInput | LinkedCardWhereUniqueInput[]
    connect?: LinkedCardWhereUniqueInput | LinkedCardWhereUniqueInput[]
    update?: LinkedCardUpdateWithWhereUniqueWithoutCustomerInput | LinkedCardUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: LinkedCardUpdateManyWithWhereWithoutCustomerInput | LinkedCardUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: LinkedCardScalarWhereInput | LinkedCardScalarWhereInput[]
  }

  export type TransactionUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<TransactionCreateWithoutCustomerInput, TransactionUncheckedCreateWithoutCustomerInput> | TransactionCreateWithoutCustomerInput[] | TransactionUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutCustomerInput | TransactionCreateOrConnectWithoutCustomerInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutCustomerInput | TransactionUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: TransactionCreateManyCustomerInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutCustomerInput | TransactionUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutCustomerInput | TransactionUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type CustomerBalanceUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<CustomerBalanceCreateWithoutCustomerInput, CustomerBalanceUncheckedCreateWithoutCustomerInput> | CustomerBalanceCreateWithoutCustomerInput[] | CustomerBalanceUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CustomerBalanceCreateOrConnectWithoutCustomerInput | CustomerBalanceCreateOrConnectWithoutCustomerInput[]
    upsert?: CustomerBalanceUpsertWithWhereUniqueWithoutCustomerInput | CustomerBalanceUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: CustomerBalanceCreateManyCustomerInputEnvelope
    set?: CustomerBalanceWhereUniqueInput | CustomerBalanceWhereUniqueInput[]
    disconnect?: CustomerBalanceWhereUniqueInput | CustomerBalanceWhereUniqueInput[]
    delete?: CustomerBalanceWhereUniqueInput | CustomerBalanceWhereUniqueInput[]
    connect?: CustomerBalanceWhereUniqueInput | CustomerBalanceWhereUniqueInput[]
    update?: CustomerBalanceUpdateWithWhereUniqueWithoutCustomerInput | CustomerBalanceUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: CustomerBalanceUpdateManyWithWhereWithoutCustomerInput | CustomerBalanceUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: CustomerBalanceScalarWhereInput | CustomerBalanceScalarWhereInput[]
  }

  export type RedemptionUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<RedemptionCreateWithoutCustomerInput, RedemptionUncheckedCreateWithoutCustomerInput> | RedemptionCreateWithoutCustomerInput[] | RedemptionUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: RedemptionCreateOrConnectWithoutCustomerInput | RedemptionCreateOrConnectWithoutCustomerInput[]
    upsert?: RedemptionUpsertWithWhereUniqueWithoutCustomerInput | RedemptionUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: RedemptionCreateManyCustomerInputEnvelope
    set?: RedemptionWhereUniqueInput | RedemptionWhereUniqueInput[]
    disconnect?: RedemptionWhereUniqueInput | RedemptionWhereUniqueInput[]
    delete?: RedemptionWhereUniqueInput | RedemptionWhereUniqueInput[]
    connect?: RedemptionWhereUniqueInput | RedemptionWhereUniqueInput[]
    update?: RedemptionUpdateWithWhereUniqueWithoutCustomerInput | RedemptionUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: RedemptionUpdateManyWithWhereWithoutCustomerInput | RedemptionUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: RedemptionScalarWhereInput | RedemptionScalarWhereInput[]
  }

  export type LedgerEntryUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<LedgerEntryCreateWithoutCustomerInput, LedgerEntryUncheckedCreateWithoutCustomerInput> | LedgerEntryCreateWithoutCustomerInput[] | LedgerEntryUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: LedgerEntryCreateOrConnectWithoutCustomerInput | LedgerEntryCreateOrConnectWithoutCustomerInput[]
    upsert?: LedgerEntryUpsertWithWhereUniqueWithoutCustomerInput | LedgerEntryUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: LedgerEntryCreateManyCustomerInputEnvelope
    set?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    disconnect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    delete?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    connect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    update?: LedgerEntryUpdateWithWhereUniqueWithoutCustomerInput | LedgerEntryUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: LedgerEntryUpdateManyWithWhereWithoutCustomerInput | LedgerEntryUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: LedgerEntryScalarWhereInput | LedgerEntryScalarWhereInput[]
  }

  export type CustomerItemCountUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<CustomerItemCountCreateWithoutCustomerInput, CustomerItemCountUncheckedCreateWithoutCustomerInput> | CustomerItemCountCreateWithoutCustomerInput[] | CustomerItemCountUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CustomerItemCountCreateOrConnectWithoutCustomerInput | CustomerItemCountCreateOrConnectWithoutCustomerInput[]
    upsert?: CustomerItemCountUpsertWithWhereUniqueWithoutCustomerInput | CustomerItemCountUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: CustomerItemCountCreateManyCustomerInputEnvelope
    set?: CustomerItemCountWhereUniqueInput | CustomerItemCountWhereUniqueInput[]
    disconnect?: CustomerItemCountWhereUniqueInput | CustomerItemCountWhereUniqueInput[]
    delete?: CustomerItemCountWhereUniqueInput | CustomerItemCountWhereUniqueInput[]
    connect?: CustomerItemCountWhereUniqueInput | CustomerItemCountWhereUniqueInput[]
    update?: CustomerItemCountUpdateWithWhereUniqueWithoutCustomerInput | CustomerItemCountUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: CustomerItemCountUpdateManyWithWhereWithoutCustomerInput | CustomerItemCountUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: CustomerItemCountScalarWhereInput | CustomerItemCountScalarWhereInput[]
  }

  export type LinkedCardUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<LinkedCardCreateWithoutCustomerInput, LinkedCardUncheckedCreateWithoutCustomerInput> | LinkedCardCreateWithoutCustomerInput[] | LinkedCardUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: LinkedCardCreateOrConnectWithoutCustomerInput | LinkedCardCreateOrConnectWithoutCustomerInput[]
    upsert?: LinkedCardUpsertWithWhereUniqueWithoutCustomerInput | LinkedCardUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: LinkedCardCreateManyCustomerInputEnvelope
    set?: LinkedCardWhereUniqueInput | LinkedCardWhereUniqueInput[]
    disconnect?: LinkedCardWhereUniqueInput | LinkedCardWhereUniqueInput[]
    delete?: LinkedCardWhereUniqueInput | LinkedCardWhereUniqueInput[]
    connect?: LinkedCardWhereUniqueInput | LinkedCardWhereUniqueInput[]
    update?: LinkedCardUpdateWithWhereUniqueWithoutCustomerInput | LinkedCardUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: LinkedCardUpdateManyWithWhereWithoutCustomerInput | LinkedCardUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: LinkedCardScalarWhereInput | LinkedCardScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<TransactionCreateWithoutCustomerInput, TransactionUncheckedCreateWithoutCustomerInput> | TransactionCreateWithoutCustomerInput[] | TransactionUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutCustomerInput | TransactionCreateOrConnectWithoutCustomerInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutCustomerInput | TransactionUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: TransactionCreateManyCustomerInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutCustomerInput | TransactionUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutCustomerInput | TransactionUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type CustomerBalanceUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<CustomerBalanceCreateWithoutCustomerInput, CustomerBalanceUncheckedCreateWithoutCustomerInput> | CustomerBalanceCreateWithoutCustomerInput[] | CustomerBalanceUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CustomerBalanceCreateOrConnectWithoutCustomerInput | CustomerBalanceCreateOrConnectWithoutCustomerInput[]
    upsert?: CustomerBalanceUpsertWithWhereUniqueWithoutCustomerInput | CustomerBalanceUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: CustomerBalanceCreateManyCustomerInputEnvelope
    set?: CustomerBalanceWhereUniqueInput | CustomerBalanceWhereUniqueInput[]
    disconnect?: CustomerBalanceWhereUniqueInput | CustomerBalanceWhereUniqueInput[]
    delete?: CustomerBalanceWhereUniqueInput | CustomerBalanceWhereUniqueInput[]
    connect?: CustomerBalanceWhereUniqueInput | CustomerBalanceWhereUniqueInput[]
    update?: CustomerBalanceUpdateWithWhereUniqueWithoutCustomerInput | CustomerBalanceUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: CustomerBalanceUpdateManyWithWhereWithoutCustomerInput | CustomerBalanceUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: CustomerBalanceScalarWhereInput | CustomerBalanceScalarWhereInput[]
  }

  export type RedemptionUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<RedemptionCreateWithoutCustomerInput, RedemptionUncheckedCreateWithoutCustomerInput> | RedemptionCreateWithoutCustomerInput[] | RedemptionUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: RedemptionCreateOrConnectWithoutCustomerInput | RedemptionCreateOrConnectWithoutCustomerInput[]
    upsert?: RedemptionUpsertWithWhereUniqueWithoutCustomerInput | RedemptionUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: RedemptionCreateManyCustomerInputEnvelope
    set?: RedemptionWhereUniqueInput | RedemptionWhereUniqueInput[]
    disconnect?: RedemptionWhereUniqueInput | RedemptionWhereUniqueInput[]
    delete?: RedemptionWhereUniqueInput | RedemptionWhereUniqueInput[]
    connect?: RedemptionWhereUniqueInput | RedemptionWhereUniqueInput[]
    update?: RedemptionUpdateWithWhereUniqueWithoutCustomerInput | RedemptionUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: RedemptionUpdateManyWithWhereWithoutCustomerInput | RedemptionUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: RedemptionScalarWhereInput | RedemptionScalarWhereInput[]
  }

  export type LedgerEntryUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<LedgerEntryCreateWithoutCustomerInput, LedgerEntryUncheckedCreateWithoutCustomerInput> | LedgerEntryCreateWithoutCustomerInput[] | LedgerEntryUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: LedgerEntryCreateOrConnectWithoutCustomerInput | LedgerEntryCreateOrConnectWithoutCustomerInput[]
    upsert?: LedgerEntryUpsertWithWhereUniqueWithoutCustomerInput | LedgerEntryUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: LedgerEntryCreateManyCustomerInputEnvelope
    set?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    disconnect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    delete?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    connect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    update?: LedgerEntryUpdateWithWhereUniqueWithoutCustomerInput | LedgerEntryUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: LedgerEntryUpdateManyWithWhereWithoutCustomerInput | LedgerEntryUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: LedgerEntryScalarWhereInput | LedgerEntryScalarWhereInput[]
  }

  export type CustomerItemCountUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<CustomerItemCountCreateWithoutCustomerInput, CustomerItemCountUncheckedCreateWithoutCustomerInput> | CustomerItemCountCreateWithoutCustomerInput[] | CustomerItemCountUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CustomerItemCountCreateOrConnectWithoutCustomerInput | CustomerItemCountCreateOrConnectWithoutCustomerInput[]
    upsert?: CustomerItemCountUpsertWithWhereUniqueWithoutCustomerInput | CustomerItemCountUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: CustomerItemCountCreateManyCustomerInputEnvelope
    set?: CustomerItemCountWhereUniqueInput | CustomerItemCountWhereUniqueInput[]
    disconnect?: CustomerItemCountWhereUniqueInput | CustomerItemCountWhereUniqueInput[]
    delete?: CustomerItemCountWhereUniqueInput | CustomerItemCountWhereUniqueInput[]
    connect?: CustomerItemCountWhereUniqueInput | CustomerItemCountWhereUniqueInput[]
    update?: CustomerItemCountUpdateWithWhereUniqueWithoutCustomerInput | CustomerItemCountUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: CustomerItemCountUpdateManyWithWhereWithoutCustomerInput | CustomerItemCountUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: CustomerItemCountScalarWhereInput | CustomerItemCountScalarWhereInput[]
  }

  export type CustomerCreateNestedOneWithoutLinkedCardsInput = {
    create?: XOR<CustomerCreateWithoutLinkedCardsInput, CustomerUncheckedCreateWithoutLinkedCardsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutLinkedCardsInput
    connect?: CustomerWhereUniqueInput
  }

  export type CustomerUpdateOneRequiredWithoutLinkedCardsNestedInput = {
    create?: XOR<CustomerCreateWithoutLinkedCardsInput, CustomerUncheckedCreateWithoutLinkedCardsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutLinkedCardsInput
    upsert?: CustomerUpsertWithoutLinkedCardsInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutLinkedCardsInput, CustomerUpdateWithoutLinkedCardsInput>, CustomerUncheckedUpdateWithoutLinkedCardsInput>
  }

  export type MerchantCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<MerchantCreateWithoutTransactionsInput, MerchantUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: MerchantCreateOrConnectWithoutTransactionsInput
    connect?: MerchantWhereUniqueInput
  }

  export type CustomerCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<CustomerCreateWithoutTransactionsInput, CustomerUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutTransactionsInput
    connect?: CustomerWhereUniqueInput
  }

  export type LocationCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<LocationCreateWithoutTransactionsInput, LocationUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: LocationCreateOrConnectWithoutTransactionsInput
    connect?: LocationWhereUniqueInput
  }

  export type LedgerEntryCreateNestedManyWithoutTransactionInput = {
    create?: XOR<LedgerEntryCreateWithoutTransactionInput, LedgerEntryUncheckedCreateWithoutTransactionInput> | LedgerEntryCreateWithoutTransactionInput[] | LedgerEntryUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: LedgerEntryCreateOrConnectWithoutTransactionInput | LedgerEntryCreateOrConnectWithoutTransactionInput[]
    createMany?: LedgerEntryCreateManyTransactionInputEnvelope
    connect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
  }

  export type LedgerEntryUncheckedCreateNestedManyWithoutTransactionInput = {
    create?: XOR<LedgerEntryCreateWithoutTransactionInput, LedgerEntryUncheckedCreateWithoutTransactionInput> | LedgerEntryCreateWithoutTransactionInput[] | LedgerEntryUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: LedgerEntryCreateOrConnectWithoutTransactionInput | LedgerEntryCreateOrConnectWithoutTransactionInput[]
    createMany?: LedgerEntryCreateManyTransactionInputEnvelope
    connect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumTransactionStatusFieldUpdateOperationsInput = {
    set?: $Enums.TransactionStatus
  }

  export type MerchantUpdateOneRequiredWithoutTransactionsNestedInput = {
    create?: XOR<MerchantCreateWithoutTransactionsInput, MerchantUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: MerchantCreateOrConnectWithoutTransactionsInput
    upsert?: MerchantUpsertWithoutTransactionsInput
    connect?: MerchantWhereUniqueInput
    update?: XOR<XOR<MerchantUpdateToOneWithWhereWithoutTransactionsInput, MerchantUpdateWithoutTransactionsInput>, MerchantUncheckedUpdateWithoutTransactionsInput>
  }

  export type CustomerUpdateOneWithoutTransactionsNestedInput = {
    create?: XOR<CustomerCreateWithoutTransactionsInput, CustomerUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutTransactionsInput
    upsert?: CustomerUpsertWithoutTransactionsInput
    disconnect?: CustomerWhereInput | boolean
    delete?: CustomerWhereInput | boolean
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutTransactionsInput, CustomerUpdateWithoutTransactionsInput>, CustomerUncheckedUpdateWithoutTransactionsInput>
  }

  export type LocationUpdateOneWithoutTransactionsNestedInput = {
    create?: XOR<LocationCreateWithoutTransactionsInput, LocationUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: LocationCreateOrConnectWithoutTransactionsInput
    upsert?: LocationUpsertWithoutTransactionsInput
    disconnect?: LocationWhereInput | boolean
    delete?: LocationWhereInput | boolean
    connect?: LocationWhereUniqueInput
    update?: XOR<XOR<LocationUpdateToOneWithWhereWithoutTransactionsInput, LocationUpdateWithoutTransactionsInput>, LocationUncheckedUpdateWithoutTransactionsInput>
  }

  export type LedgerEntryUpdateManyWithoutTransactionNestedInput = {
    create?: XOR<LedgerEntryCreateWithoutTransactionInput, LedgerEntryUncheckedCreateWithoutTransactionInput> | LedgerEntryCreateWithoutTransactionInput[] | LedgerEntryUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: LedgerEntryCreateOrConnectWithoutTransactionInput | LedgerEntryCreateOrConnectWithoutTransactionInput[]
    upsert?: LedgerEntryUpsertWithWhereUniqueWithoutTransactionInput | LedgerEntryUpsertWithWhereUniqueWithoutTransactionInput[]
    createMany?: LedgerEntryCreateManyTransactionInputEnvelope
    set?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    disconnect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    delete?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    connect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    update?: LedgerEntryUpdateWithWhereUniqueWithoutTransactionInput | LedgerEntryUpdateWithWhereUniqueWithoutTransactionInput[]
    updateMany?: LedgerEntryUpdateManyWithWhereWithoutTransactionInput | LedgerEntryUpdateManyWithWhereWithoutTransactionInput[]
    deleteMany?: LedgerEntryScalarWhereInput | LedgerEntryScalarWhereInput[]
  }

  export type LedgerEntryUncheckedUpdateManyWithoutTransactionNestedInput = {
    create?: XOR<LedgerEntryCreateWithoutTransactionInput, LedgerEntryUncheckedCreateWithoutTransactionInput> | LedgerEntryCreateWithoutTransactionInput[] | LedgerEntryUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: LedgerEntryCreateOrConnectWithoutTransactionInput | LedgerEntryCreateOrConnectWithoutTransactionInput[]
    upsert?: LedgerEntryUpsertWithWhereUniqueWithoutTransactionInput | LedgerEntryUpsertWithWhereUniqueWithoutTransactionInput[]
    createMany?: LedgerEntryCreateManyTransactionInputEnvelope
    set?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    disconnect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    delete?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    connect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    update?: LedgerEntryUpdateWithWhereUniqueWithoutTransactionInput | LedgerEntryUpdateWithWhereUniqueWithoutTransactionInput[]
    updateMany?: LedgerEntryUpdateManyWithWhereWithoutTransactionInput | LedgerEntryUpdateManyWithWhereWithoutTransactionInput[]
    deleteMany?: LedgerEntryScalarWhereInput | LedgerEntryScalarWhereInput[]
  }

  export type CustomerCreateNestedOneWithoutCustomerBalancesInput = {
    create?: XOR<CustomerCreateWithoutCustomerBalancesInput, CustomerUncheckedCreateWithoutCustomerBalancesInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutCustomerBalancesInput
    connect?: CustomerWhereUniqueInput
  }

  export type MerchantCreateNestedOneWithoutCustomerBalancesInput = {
    create?: XOR<MerchantCreateWithoutCustomerBalancesInput, MerchantUncheckedCreateWithoutCustomerBalancesInput>
    connectOrCreate?: MerchantCreateOrConnectWithoutCustomerBalancesInput
    connect?: MerchantWhereUniqueInput
  }

  export type CustomerUpdateOneRequiredWithoutCustomerBalancesNestedInput = {
    create?: XOR<CustomerCreateWithoutCustomerBalancesInput, CustomerUncheckedCreateWithoutCustomerBalancesInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutCustomerBalancesInput
    upsert?: CustomerUpsertWithoutCustomerBalancesInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutCustomerBalancesInput, CustomerUpdateWithoutCustomerBalancesInput>, CustomerUncheckedUpdateWithoutCustomerBalancesInput>
  }

  export type MerchantUpdateOneRequiredWithoutCustomerBalancesNestedInput = {
    create?: XOR<MerchantCreateWithoutCustomerBalancesInput, MerchantUncheckedCreateWithoutCustomerBalancesInput>
    connectOrCreate?: MerchantCreateOrConnectWithoutCustomerBalancesInput
    upsert?: MerchantUpsertWithoutCustomerBalancesInput
    connect?: MerchantWhereUniqueInput
    update?: XOR<XOR<MerchantUpdateToOneWithWhereWithoutCustomerBalancesInput, MerchantUpdateWithoutCustomerBalancesInput>, MerchantUncheckedUpdateWithoutCustomerBalancesInput>
  }

  export type MerchantCreateNestedOneWithoutRewardsInput = {
    create?: XOR<MerchantCreateWithoutRewardsInput, MerchantUncheckedCreateWithoutRewardsInput>
    connectOrCreate?: MerchantCreateOrConnectWithoutRewardsInput
    connect?: MerchantWhereUniqueInput
  }

  export type POSRewardItemCreateNestedManyWithoutRewardInput = {
    create?: XOR<POSRewardItemCreateWithoutRewardInput, POSRewardItemUncheckedCreateWithoutRewardInput> | POSRewardItemCreateWithoutRewardInput[] | POSRewardItemUncheckedCreateWithoutRewardInput[]
    connectOrCreate?: POSRewardItemCreateOrConnectWithoutRewardInput | POSRewardItemCreateOrConnectWithoutRewardInput[]
    createMany?: POSRewardItemCreateManyRewardInputEnvelope
    connect?: POSRewardItemWhereUniqueInput | POSRewardItemWhereUniqueInput[]
  }

  export type RedemptionCreateNestedManyWithoutRewardInput = {
    create?: XOR<RedemptionCreateWithoutRewardInput, RedemptionUncheckedCreateWithoutRewardInput> | RedemptionCreateWithoutRewardInput[] | RedemptionUncheckedCreateWithoutRewardInput[]
    connectOrCreate?: RedemptionCreateOrConnectWithoutRewardInput | RedemptionCreateOrConnectWithoutRewardInput[]
    createMany?: RedemptionCreateManyRewardInputEnvelope
    connect?: RedemptionWhereUniqueInput | RedemptionWhereUniqueInput[]
  }

  export type CustomerItemCountCreateNestedManyWithoutRewardInput = {
    create?: XOR<CustomerItemCountCreateWithoutRewardInput, CustomerItemCountUncheckedCreateWithoutRewardInput> | CustomerItemCountCreateWithoutRewardInput[] | CustomerItemCountUncheckedCreateWithoutRewardInput[]
    connectOrCreate?: CustomerItemCountCreateOrConnectWithoutRewardInput | CustomerItemCountCreateOrConnectWithoutRewardInput[]
    createMany?: CustomerItemCountCreateManyRewardInputEnvelope
    connect?: CustomerItemCountWhereUniqueInput | CustomerItemCountWhereUniqueInput[]
  }

  export type POSRewardItemUncheckedCreateNestedManyWithoutRewardInput = {
    create?: XOR<POSRewardItemCreateWithoutRewardInput, POSRewardItemUncheckedCreateWithoutRewardInput> | POSRewardItemCreateWithoutRewardInput[] | POSRewardItemUncheckedCreateWithoutRewardInput[]
    connectOrCreate?: POSRewardItemCreateOrConnectWithoutRewardInput | POSRewardItemCreateOrConnectWithoutRewardInput[]
    createMany?: POSRewardItemCreateManyRewardInputEnvelope
    connect?: POSRewardItemWhereUniqueInput | POSRewardItemWhereUniqueInput[]
  }

  export type RedemptionUncheckedCreateNestedManyWithoutRewardInput = {
    create?: XOR<RedemptionCreateWithoutRewardInput, RedemptionUncheckedCreateWithoutRewardInput> | RedemptionCreateWithoutRewardInput[] | RedemptionUncheckedCreateWithoutRewardInput[]
    connectOrCreate?: RedemptionCreateOrConnectWithoutRewardInput | RedemptionCreateOrConnectWithoutRewardInput[]
    createMany?: RedemptionCreateManyRewardInputEnvelope
    connect?: RedemptionWhereUniqueInput | RedemptionWhereUniqueInput[]
  }

  export type CustomerItemCountUncheckedCreateNestedManyWithoutRewardInput = {
    create?: XOR<CustomerItemCountCreateWithoutRewardInput, CustomerItemCountUncheckedCreateWithoutRewardInput> | CustomerItemCountCreateWithoutRewardInput[] | CustomerItemCountUncheckedCreateWithoutRewardInput[]
    connectOrCreate?: CustomerItemCountCreateOrConnectWithoutRewardInput | CustomerItemCountCreateOrConnectWithoutRewardInput[]
    createMany?: CustomerItemCountCreateManyRewardInputEnvelope
    connect?: CustomerItemCountWhereUniqueInput | CustomerItemCountWhereUniqueInput[]
  }

  export type EnumRewardTypeFieldUpdateOperationsInput = {
    set?: $Enums.RewardType
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type MerchantUpdateOneRequiredWithoutRewardsNestedInput = {
    create?: XOR<MerchantCreateWithoutRewardsInput, MerchantUncheckedCreateWithoutRewardsInput>
    connectOrCreate?: MerchantCreateOrConnectWithoutRewardsInput
    upsert?: MerchantUpsertWithoutRewardsInput
    connect?: MerchantWhereUniqueInput
    update?: XOR<XOR<MerchantUpdateToOneWithWhereWithoutRewardsInput, MerchantUpdateWithoutRewardsInput>, MerchantUncheckedUpdateWithoutRewardsInput>
  }

  export type POSRewardItemUpdateManyWithoutRewardNestedInput = {
    create?: XOR<POSRewardItemCreateWithoutRewardInput, POSRewardItemUncheckedCreateWithoutRewardInput> | POSRewardItemCreateWithoutRewardInput[] | POSRewardItemUncheckedCreateWithoutRewardInput[]
    connectOrCreate?: POSRewardItemCreateOrConnectWithoutRewardInput | POSRewardItemCreateOrConnectWithoutRewardInput[]
    upsert?: POSRewardItemUpsertWithWhereUniqueWithoutRewardInput | POSRewardItemUpsertWithWhereUniqueWithoutRewardInput[]
    createMany?: POSRewardItemCreateManyRewardInputEnvelope
    set?: POSRewardItemWhereUniqueInput | POSRewardItemWhereUniqueInput[]
    disconnect?: POSRewardItemWhereUniqueInput | POSRewardItemWhereUniqueInput[]
    delete?: POSRewardItemWhereUniqueInput | POSRewardItemWhereUniqueInput[]
    connect?: POSRewardItemWhereUniqueInput | POSRewardItemWhereUniqueInput[]
    update?: POSRewardItemUpdateWithWhereUniqueWithoutRewardInput | POSRewardItemUpdateWithWhereUniqueWithoutRewardInput[]
    updateMany?: POSRewardItemUpdateManyWithWhereWithoutRewardInput | POSRewardItemUpdateManyWithWhereWithoutRewardInput[]
    deleteMany?: POSRewardItemScalarWhereInput | POSRewardItemScalarWhereInput[]
  }

  export type RedemptionUpdateManyWithoutRewardNestedInput = {
    create?: XOR<RedemptionCreateWithoutRewardInput, RedemptionUncheckedCreateWithoutRewardInput> | RedemptionCreateWithoutRewardInput[] | RedemptionUncheckedCreateWithoutRewardInput[]
    connectOrCreate?: RedemptionCreateOrConnectWithoutRewardInput | RedemptionCreateOrConnectWithoutRewardInput[]
    upsert?: RedemptionUpsertWithWhereUniqueWithoutRewardInput | RedemptionUpsertWithWhereUniqueWithoutRewardInput[]
    createMany?: RedemptionCreateManyRewardInputEnvelope
    set?: RedemptionWhereUniqueInput | RedemptionWhereUniqueInput[]
    disconnect?: RedemptionWhereUniqueInput | RedemptionWhereUniqueInput[]
    delete?: RedemptionWhereUniqueInput | RedemptionWhereUniqueInput[]
    connect?: RedemptionWhereUniqueInput | RedemptionWhereUniqueInput[]
    update?: RedemptionUpdateWithWhereUniqueWithoutRewardInput | RedemptionUpdateWithWhereUniqueWithoutRewardInput[]
    updateMany?: RedemptionUpdateManyWithWhereWithoutRewardInput | RedemptionUpdateManyWithWhereWithoutRewardInput[]
    deleteMany?: RedemptionScalarWhereInput | RedemptionScalarWhereInput[]
  }

  export type CustomerItemCountUpdateManyWithoutRewardNestedInput = {
    create?: XOR<CustomerItemCountCreateWithoutRewardInput, CustomerItemCountUncheckedCreateWithoutRewardInput> | CustomerItemCountCreateWithoutRewardInput[] | CustomerItemCountUncheckedCreateWithoutRewardInput[]
    connectOrCreate?: CustomerItemCountCreateOrConnectWithoutRewardInput | CustomerItemCountCreateOrConnectWithoutRewardInput[]
    upsert?: CustomerItemCountUpsertWithWhereUniqueWithoutRewardInput | CustomerItemCountUpsertWithWhereUniqueWithoutRewardInput[]
    createMany?: CustomerItemCountCreateManyRewardInputEnvelope
    set?: CustomerItemCountWhereUniqueInput | CustomerItemCountWhereUniqueInput[]
    disconnect?: CustomerItemCountWhereUniqueInput | CustomerItemCountWhereUniqueInput[]
    delete?: CustomerItemCountWhereUniqueInput | CustomerItemCountWhereUniqueInput[]
    connect?: CustomerItemCountWhereUniqueInput | CustomerItemCountWhereUniqueInput[]
    update?: CustomerItemCountUpdateWithWhereUniqueWithoutRewardInput | CustomerItemCountUpdateWithWhereUniqueWithoutRewardInput[]
    updateMany?: CustomerItemCountUpdateManyWithWhereWithoutRewardInput | CustomerItemCountUpdateManyWithWhereWithoutRewardInput[]
    deleteMany?: CustomerItemCountScalarWhereInput | CustomerItemCountScalarWhereInput[]
  }

  export type POSRewardItemUncheckedUpdateManyWithoutRewardNestedInput = {
    create?: XOR<POSRewardItemCreateWithoutRewardInput, POSRewardItemUncheckedCreateWithoutRewardInput> | POSRewardItemCreateWithoutRewardInput[] | POSRewardItemUncheckedCreateWithoutRewardInput[]
    connectOrCreate?: POSRewardItemCreateOrConnectWithoutRewardInput | POSRewardItemCreateOrConnectWithoutRewardInput[]
    upsert?: POSRewardItemUpsertWithWhereUniqueWithoutRewardInput | POSRewardItemUpsertWithWhereUniqueWithoutRewardInput[]
    createMany?: POSRewardItemCreateManyRewardInputEnvelope
    set?: POSRewardItemWhereUniqueInput | POSRewardItemWhereUniqueInput[]
    disconnect?: POSRewardItemWhereUniqueInput | POSRewardItemWhereUniqueInput[]
    delete?: POSRewardItemWhereUniqueInput | POSRewardItemWhereUniqueInput[]
    connect?: POSRewardItemWhereUniqueInput | POSRewardItemWhereUniqueInput[]
    update?: POSRewardItemUpdateWithWhereUniqueWithoutRewardInput | POSRewardItemUpdateWithWhereUniqueWithoutRewardInput[]
    updateMany?: POSRewardItemUpdateManyWithWhereWithoutRewardInput | POSRewardItemUpdateManyWithWhereWithoutRewardInput[]
    deleteMany?: POSRewardItemScalarWhereInput | POSRewardItemScalarWhereInput[]
  }

  export type RedemptionUncheckedUpdateManyWithoutRewardNestedInput = {
    create?: XOR<RedemptionCreateWithoutRewardInput, RedemptionUncheckedCreateWithoutRewardInput> | RedemptionCreateWithoutRewardInput[] | RedemptionUncheckedCreateWithoutRewardInput[]
    connectOrCreate?: RedemptionCreateOrConnectWithoutRewardInput | RedemptionCreateOrConnectWithoutRewardInput[]
    upsert?: RedemptionUpsertWithWhereUniqueWithoutRewardInput | RedemptionUpsertWithWhereUniqueWithoutRewardInput[]
    createMany?: RedemptionCreateManyRewardInputEnvelope
    set?: RedemptionWhereUniqueInput | RedemptionWhereUniqueInput[]
    disconnect?: RedemptionWhereUniqueInput | RedemptionWhereUniqueInput[]
    delete?: RedemptionWhereUniqueInput | RedemptionWhereUniqueInput[]
    connect?: RedemptionWhereUniqueInput | RedemptionWhereUniqueInput[]
    update?: RedemptionUpdateWithWhereUniqueWithoutRewardInput | RedemptionUpdateWithWhereUniqueWithoutRewardInput[]
    updateMany?: RedemptionUpdateManyWithWhereWithoutRewardInput | RedemptionUpdateManyWithWhereWithoutRewardInput[]
    deleteMany?: RedemptionScalarWhereInput | RedemptionScalarWhereInput[]
  }

  export type CustomerItemCountUncheckedUpdateManyWithoutRewardNestedInput = {
    create?: XOR<CustomerItemCountCreateWithoutRewardInput, CustomerItemCountUncheckedCreateWithoutRewardInput> | CustomerItemCountCreateWithoutRewardInput[] | CustomerItemCountUncheckedCreateWithoutRewardInput[]
    connectOrCreate?: CustomerItemCountCreateOrConnectWithoutRewardInput | CustomerItemCountCreateOrConnectWithoutRewardInput[]
    upsert?: CustomerItemCountUpsertWithWhereUniqueWithoutRewardInput | CustomerItemCountUpsertWithWhereUniqueWithoutRewardInput[]
    createMany?: CustomerItemCountCreateManyRewardInputEnvelope
    set?: CustomerItemCountWhereUniqueInput | CustomerItemCountWhereUniqueInput[]
    disconnect?: CustomerItemCountWhereUniqueInput | CustomerItemCountWhereUniqueInput[]
    delete?: CustomerItemCountWhereUniqueInput | CustomerItemCountWhereUniqueInput[]
    connect?: CustomerItemCountWhereUniqueInput | CustomerItemCountWhereUniqueInput[]
    update?: CustomerItemCountUpdateWithWhereUniqueWithoutRewardInput | CustomerItemCountUpdateWithWhereUniqueWithoutRewardInput[]
    updateMany?: CustomerItemCountUpdateManyWithWhereWithoutRewardInput | CustomerItemCountUpdateManyWithWhereWithoutRewardInput[]
    deleteMany?: CustomerItemCountScalarWhereInput | CustomerItemCountScalarWhereInput[]
  }

  export type RewardCreateNestedOneWithoutPosRewardItemsInput = {
    create?: XOR<RewardCreateWithoutPosRewardItemsInput, RewardUncheckedCreateWithoutPosRewardItemsInput>
    connectOrCreate?: RewardCreateOrConnectWithoutPosRewardItemsInput
    connect?: RewardWhereUniqueInput
  }

  export type RewardUpdateOneRequiredWithoutPosRewardItemsNestedInput = {
    create?: XOR<RewardCreateWithoutPosRewardItemsInput, RewardUncheckedCreateWithoutPosRewardItemsInput>
    connectOrCreate?: RewardCreateOrConnectWithoutPosRewardItemsInput
    upsert?: RewardUpsertWithoutPosRewardItemsInput
    connect?: RewardWhereUniqueInput
    update?: XOR<XOR<RewardUpdateToOneWithWhereWithoutPosRewardItemsInput, RewardUpdateWithoutPosRewardItemsInput>, RewardUncheckedUpdateWithoutPosRewardItemsInput>
  }

  export type CustomerCreateNestedOneWithoutRedemptionsInput = {
    create?: XOR<CustomerCreateWithoutRedemptionsInput, CustomerUncheckedCreateWithoutRedemptionsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutRedemptionsInput
    connect?: CustomerWhereUniqueInput
  }

  export type MerchantCreateNestedOneWithoutRedemptionsInput = {
    create?: XOR<MerchantCreateWithoutRedemptionsInput, MerchantUncheckedCreateWithoutRedemptionsInput>
    connectOrCreate?: MerchantCreateOrConnectWithoutRedemptionsInput
    connect?: MerchantWhereUniqueInput
  }

  export type RewardCreateNestedOneWithoutRedemptionsInput = {
    create?: XOR<RewardCreateWithoutRedemptionsInput, RewardUncheckedCreateWithoutRedemptionsInput>
    connectOrCreate?: RewardCreateOrConnectWithoutRedemptionsInput
    connect?: RewardWhereUniqueInput
  }

  export type LedgerEntryCreateNestedOneWithoutRedemptionInput = {
    create?: XOR<LedgerEntryCreateWithoutRedemptionInput, LedgerEntryUncheckedCreateWithoutRedemptionInput>
    connectOrCreate?: LedgerEntryCreateOrConnectWithoutRedemptionInput
    connect?: LedgerEntryWhereUniqueInput
  }

  export type LedgerEntryUncheckedCreateNestedOneWithoutRedemptionInput = {
    create?: XOR<LedgerEntryCreateWithoutRedemptionInput, LedgerEntryUncheckedCreateWithoutRedemptionInput>
    connectOrCreate?: LedgerEntryCreateOrConnectWithoutRedemptionInput
    connect?: LedgerEntryWhereUniqueInput
  }

  export type EnumRedemptionStatusFieldUpdateOperationsInput = {
    set?: $Enums.RedemptionStatus
  }

  export type CustomerUpdateOneRequiredWithoutRedemptionsNestedInput = {
    create?: XOR<CustomerCreateWithoutRedemptionsInput, CustomerUncheckedCreateWithoutRedemptionsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutRedemptionsInput
    upsert?: CustomerUpsertWithoutRedemptionsInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutRedemptionsInput, CustomerUpdateWithoutRedemptionsInput>, CustomerUncheckedUpdateWithoutRedemptionsInput>
  }

  export type MerchantUpdateOneRequiredWithoutRedemptionsNestedInput = {
    create?: XOR<MerchantCreateWithoutRedemptionsInput, MerchantUncheckedCreateWithoutRedemptionsInput>
    connectOrCreate?: MerchantCreateOrConnectWithoutRedemptionsInput
    upsert?: MerchantUpsertWithoutRedemptionsInput
    connect?: MerchantWhereUniqueInput
    update?: XOR<XOR<MerchantUpdateToOneWithWhereWithoutRedemptionsInput, MerchantUpdateWithoutRedemptionsInput>, MerchantUncheckedUpdateWithoutRedemptionsInput>
  }

  export type RewardUpdateOneRequiredWithoutRedemptionsNestedInput = {
    create?: XOR<RewardCreateWithoutRedemptionsInput, RewardUncheckedCreateWithoutRedemptionsInput>
    connectOrCreate?: RewardCreateOrConnectWithoutRedemptionsInput
    upsert?: RewardUpsertWithoutRedemptionsInput
    connect?: RewardWhereUniqueInput
    update?: XOR<XOR<RewardUpdateToOneWithWhereWithoutRedemptionsInput, RewardUpdateWithoutRedemptionsInput>, RewardUncheckedUpdateWithoutRedemptionsInput>
  }

  export type LedgerEntryUpdateOneWithoutRedemptionNestedInput = {
    create?: XOR<LedgerEntryCreateWithoutRedemptionInput, LedgerEntryUncheckedCreateWithoutRedemptionInput>
    connectOrCreate?: LedgerEntryCreateOrConnectWithoutRedemptionInput
    upsert?: LedgerEntryUpsertWithoutRedemptionInput
    disconnect?: LedgerEntryWhereInput | boolean
    delete?: LedgerEntryWhereInput | boolean
    connect?: LedgerEntryWhereUniqueInput
    update?: XOR<XOR<LedgerEntryUpdateToOneWithWhereWithoutRedemptionInput, LedgerEntryUpdateWithoutRedemptionInput>, LedgerEntryUncheckedUpdateWithoutRedemptionInput>
  }

  export type LedgerEntryUncheckedUpdateOneWithoutRedemptionNestedInput = {
    create?: XOR<LedgerEntryCreateWithoutRedemptionInput, LedgerEntryUncheckedCreateWithoutRedemptionInput>
    connectOrCreate?: LedgerEntryCreateOrConnectWithoutRedemptionInput
    upsert?: LedgerEntryUpsertWithoutRedemptionInput
    disconnect?: LedgerEntryWhereInput | boolean
    delete?: LedgerEntryWhereInput | boolean
    connect?: LedgerEntryWhereUniqueInput
    update?: XOR<XOR<LedgerEntryUpdateToOneWithWhereWithoutRedemptionInput, LedgerEntryUpdateWithoutRedemptionInput>, LedgerEntryUncheckedUpdateWithoutRedemptionInput>
  }

  export type CustomerCreateNestedOneWithoutItemCountsInput = {
    create?: XOR<CustomerCreateWithoutItemCountsInput, CustomerUncheckedCreateWithoutItemCountsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutItemCountsInput
    connect?: CustomerWhereUniqueInput
  }

  export type MerchantCreateNestedOneWithoutItemCountsInput = {
    create?: XOR<MerchantCreateWithoutItemCountsInput, MerchantUncheckedCreateWithoutItemCountsInput>
    connectOrCreate?: MerchantCreateOrConnectWithoutItemCountsInput
    connect?: MerchantWhereUniqueInput
  }

  export type RewardCreateNestedOneWithoutItemCountsInput = {
    create?: XOR<RewardCreateWithoutItemCountsInput, RewardUncheckedCreateWithoutItemCountsInput>
    connectOrCreate?: RewardCreateOrConnectWithoutItemCountsInput
    connect?: RewardWhereUniqueInput
  }

  export type CustomerUpdateOneRequiredWithoutItemCountsNestedInput = {
    create?: XOR<CustomerCreateWithoutItemCountsInput, CustomerUncheckedCreateWithoutItemCountsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutItemCountsInput
    upsert?: CustomerUpsertWithoutItemCountsInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutItemCountsInput, CustomerUpdateWithoutItemCountsInput>, CustomerUncheckedUpdateWithoutItemCountsInput>
  }

  export type MerchantUpdateOneRequiredWithoutItemCountsNestedInput = {
    create?: XOR<MerchantCreateWithoutItemCountsInput, MerchantUncheckedCreateWithoutItemCountsInput>
    connectOrCreate?: MerchantCreateOrConnectWithoutItemCountsInput
    upsert?: MerchantUpsertWithoutItemCountsInput
    connect?: MerchantWhereUniqueInput
    update?: XOR<XOR<MerchantUpdateToOneWithWhereWithoutItemCountsInput, MerchantUpdateWithoutItemCountsInput>, MerchantUncheckedUpdateWithoutItemCountsInput>
  }

  export type RewardUpdateOneRequiredWithoutItemCountsNestedInput = {
    create?: XOR<RewardCreateWithoutItemCountsInput, RewardUncheckedCreateWithoutItemCountsInput>
    connectOrCreate?: RewardCreateOrConnectWithoutItemCountsInput
    upsert?: RewardUpsertWithoutItemCountsInput
    connect?: RewardWhereUniqueInput
    update?: XOR<XOR<RewardUpdateToOneWithWhereWithoutItemCountsInput, RewardUpdateWithoutItemCountsInput>, RewardUncheckedUpdateWithoutItemCountsInput>
  }

  export type CustomerCreateNestedOneWithoutLedgerEntriesInput = {
    create?: XOR<CustomerCreateWithoutLedgerEntriesInput, CustomerUncheckedCreateWithoutLedgerEntriesInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutLedgerEntriesInput
    connect?: CustomerWhereUniqueInput
  }

  export type MerchantCreateNestedOneWithoutLedgerEntriesInput = {
    create?: XOR<MerchantCreateWithoutLedgerEntriesInput, MerchantUncheckedCreateWithoutLedgerEntriesInput>
    connectOrCreate?: MerchantCreateOrConnectWithoutLedgerEntriesInput
    connect?: MerchantWhereUniqueInput
  }

  export type TransactionCreateNestedOneWithoutLedgerEntriesInput = {
    create?: XOR<TransactionCreateWithoutLedgerEntriesInput, TransactionUncheckedCreateWithoutLedgerEntriesInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutLedgerEntriesInput
    connect?: TransactionWhereUniqueInput
  }

  export type RedemptionCreateNestedOneWithoutLedgerEntryInput = {
    create?: XOR<RedemptionCreateWithoutLedgerEntryInput, RedemptionUncheckedCreateWithoutLedgerEntryInput>
    connectOrCreate?: RedemptionCreateOrConnectWithoutLedgerEntryInput
    connect?: RedemptionWhereUniqueInput
  }

  export type EnumLedgerEntryTypeFieldUpdateOperationsInput = {
    set?: $Enums.LedgerEntryType
  }

  export type CustomerUpdateOneRequiredWithoutLedgerEntriesNestedInput = {
    create?: XOR<CustomerCreateWithoutLedgerEntriesInput, CustomerUncheckedCreateWithoutLedgerEntriesInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutLedgerEntriesInput
    upsert?: CustomerUpsertWithoutLedgerEntriesInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutLedgerEntriesInput, CustomerUpdateWithoutLedgerEntriesInput>, CustomerUncheckedUpdateWithoutLedgerEntriesInput>
  }

  export type MerchantUpdateOneRequiredWithoutLedgerEntriesNestedInput = {
    create?: XOR<MerchantCreateWithoutLedgerEntriesInput, MerchantUncheckedCreateWithoutLedgerEntriesInput>
    connectOrCreate?: MerchantCreateOrConnectWithoutLedgerEntriesInput
    upsert?: MerchantUpsertWithoutLedgerEntriesInput
    connect?: MerchantWhereUniqueInput
    update?: XOR<XOR<MerchantUpdateToOneWithWhereWithoutLedgerEntriesInput, MerchantUpdateWithoutLedgerEntriesInput>, MerchantUncheckedUpdateWithoutLedgerEntriesInput>
  }

  export type TransactionUpdateOneWithoutLedgerEntriesNestedInput = {
    create?: XOR<TransactionCreateWithoutLedgerEntriesInput, TransactionUncheckedCreateWithoutLedgerEntriesInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutLedgerEntriesInput
    upsert?: TransactionUpsertWithoutLedgerEntriesInput
    disconnect?: TransactionWhereInput | boolean
    delete?: TransactionWhereInput | boolean
    connect?: TransactionWhereUniqueInput
    update?: XOR<XOR<TransactionUpdateToOneWithWhereWithoutLedgerEntriesInput, TransactionUpdateWithoutLedgerEntriesInput>, TransactionUncheckedUpdateWithoutLedgerEntriesInput>
  }

  export type RedemptionUpdateOneWithoutLedgerEntryNestedInput = {
    create?: XOR<RedemptionCreateWithoutLedgerEntryInput, RedemptionUncheckedCreateWithoutLedgerEntryInput>
    connectOrCreate?: RedemptionCreateOrConnectWithoutLedgerEntryInput
    upsert?: RedemptionUpsertWithoutLedgerEntryInput
    disconnect?: RedemptionWhereInput | boolean
    delete?: RedemptionWhereInput | boolean
    connect?: RedemptionWhereUniqueInput
    update?: XOR<XOR<RedemptionUpdateToOneWithWhereWithoutLedgerEntryInput, RedemptionUpdateWithoutLedgerEntryInput>, RedemptionUncheckedUpdateWithoutLedgerEntryInput>
  }

  export type EnumWebhookStatusFieldUpdateOperationsInput = {
    set?: $Enums.WebhookStatus
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumPOSProviderFilter<$PrismaModel = never> = {
    equals?: $Enums.POSProvider | EnumPOSProviderFieldRefInput<$PrismaModel>
    in?: $Enums.POSProvider[] | ListEnumPOSProviderFieldRefInput<$PrismaModel>
    notIn?: $Enums.POSProvider[] | ListEnumPOSProviderFieldRefInput<$PrismaModel>
    not?: NestedEnumPOSProviderFilter<$PrismaModel> | $Enums.POSProvider
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumPOSProviderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.POSProvider | EnumPOSProviderFieldRefInput<$PrismaModel>
    in?: $Enums.POSProvider[] | ListEnumPOSProviderFieldRefInput<$PrismaModel>
    notIn?: $Enums.POSProvider[] | ListEnumPOSProviderFieldRefInput<$PrismaModel>
    not?: NestedEnumPOSProviderWithAggregatesFilter<$PrismaModel> | $Enums.POSProvider
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPOSProviderFilter<$PrismaModel>
    _max?: NestedEnumPOSProviderFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedEnumTransactionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionStatus | EnumTransactionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionStatusFilter<$PrismaModel> | $Enums.TransactionStatus
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumTransactionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionStatus | EnumTransactionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionStatusWithAggregatesFilter<$PrismaModel> | $Enums.TransactionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionStatusFilter<$PrismaModel>
    _max?: NestedEnumTransactionStatusFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumRewardTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.RewardType | EnumRewardTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RewardType[] | ListEnumRewardTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RewardType[] | ListEnumRewardTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRewardTypeFilter<$PrismaModel> | $Enums.RewardType
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumRewardTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RewardType | EnumRewardTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RewardType[] | ListEnumRewardTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RewardType[] | ListEnumRewardTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRewardTypeWithAggregatesFilter<$PrismaModel> | $Enums.RewardType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRewardTypeFilter<$PrismaModel>
    _max?: NestedEnumRewardTypeFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumRedemptionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RedemptionStatus | EnumRedemptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RedemptionStatus[] | ListEnumRedemptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RedemptionStatus[] | ListEnumRedemptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRedemptionStatusFilter<$PrismaModel> | $Enums.RedemptionStatus
  }

  export type NestedEnumRedemptionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RedemptionStatus | EnumRedemptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RedemptionStatus[] | ListEnumRedemptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RedemptionStatus[] | ListEnumRedemptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRedemptionStatusWithAggregatesFilter<$PrismaModel> | $Enums.RedemptionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRedemptionStatusFilter<$PrismaModel>
    _max?: NestedEnumRedemptionStatusFilter<$PrismaModel>
  }

  export type NestedEnumLedgerEntryTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.LedgerEntryType | EnumLedgerEntryTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LedgerEntryType[] | ListEnumLedgerEntryTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LedgerEntryType[] | ListEnumLedgerEntryTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLedgerEntryTypeFilter<$PrismaModel> | $Enums.LedgerEntryType
  }

  export type NestedEnumLedgerEntryTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LedgerEntryType | EnumLedgerEntryTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LedgerEntryType[] | ListEnumLedgerEntryTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LedgerEntryType[] | ListEnumLedgerEntryTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLedgerEntryTypeWithAggregatesFilter<$PrismaModel> | $Enums.LedgerEntryType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLedgerEntryTypeFilter<$PrismaModel>
    _max?: NestedEnumLedgerEntryTypeFilter<$PrismaModel>
  }

  export type NestedEnumWebhookStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.WebhookStatus | EnumWebhookStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WebhookStatus[] | ListEnumWebhookStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WebhookStatus[] | ListEnumWebhookStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWebhookStatusFilter<$PrismaModel> | $Enums.WebhookStatus
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumWebhookStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WebhookStatus | EnumWebhookStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WebhookStatus[] | ListEnumWebhookStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WebhookStatus[] | ListEnumWebhookStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWebhookStatusWithAggregatesFilter<$PrismaModel> | $Enums.WebhookStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWebhookStatusFilter<$PrismaModel>
    _max?: NestedEnumWebhookStatusFilter<$PrismaModel>
  }

  export type POSIntegrationCreateWithoutMerchantInput = {
    id?: string
    provider: $Enums.POSProvider
    accessToken: string
    refreshToken?: string | null
    providerMerchantId: string
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    locations?: LocationCreateNestedManyWithoutPosIntegrationInput
  }

  export type POSIntegrationUncheckedCreateWithoutMerchantInput = {
    id?: string
    provider: $Enums.POSProvider
    accessToken: string
    refreshToken?: string | null
    providerMerchantId: string
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    locations?: LocationUncheckedCreateNestedManyWithoutPosIntegrationInput
  }

  export type POSIntegrationCreateOrConnectWithoutMerchantInput = {
    where: POSIntegrationWhereUniqueInput
    create: XOR<POSIntegrationCreateWithoutMerchantInput, POSIntegrationUncheckedCreateWithoutMerchantInput>
  }

  export type POSIntegrationCreateManyMerchantInputEnvelope = {
    data: POSIntegrationCreateManyMerchantInput | POSIntegrationCreateManyMerchantInput[]
    skipDuplicates?: boolean
  }

  export type LocationCreateWithoutMerchantInput = {
    id?: string
    posLocationId: string
    name: string
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    country?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    posIntegration: POSIntegrationCreateNestedOneWithoutLocationsInput
    transactions?: TransactionCreateNestedManyWithoutLocationInput
  }

  export type LocationUncheckedCreateWithoutMerchantInput = {
    id?: string
    posIntegrationId: string
    posLocationId: string
    name: string
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    country?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: TransactionUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationCreateOrConnectWithoutMerchantInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutMerchantInput, LocationUncheckedCreateWithoutMerchantInput>
  }

  export type LocationCreateManyMerchantInputEnvelope = {
    data: LocationCreateManyMerchantInput | LocationCreateManyMerchantInput[]
    skipDuplicates?: boolean
  }

  export type RewardCreateWithoutMerchantInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.RewardType
    pointsCost?: number | null
    itemName?: string | null
    itemCount?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    posRewardItems?: POSRewardItemCreateNestedManyWithoutRewardInput
    redemptions?: RedemptionCreateNestedManyWithoutRewardInput
    itemCounts?: CustomerItemCountCreateNestedManyWithoutRewardInput
  }

  export type RewardUncheckedCreateWithoutMerchantInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.RewardType
    pointsCost?: number | null
    itemName?: string | null
    itemCount?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    posRewardItems?: POSRewardItemUncheckedCreateNestedManyWithoutRewardInput
    redemptions?: RedemptionUncheckedCreateNestedManyWithoutRewardInput
    itemCounts?: CustomerItemCountUncheckedCreateNestedManyWithoutRewardInput
  }

  export type RewardCreateOrConnectWithoutMerchantInput = {
    where: RewardWhereUniqueInput
    create: XOR<RewardCreateWithoutMerchantInput, RewardUncheckedCreateWithoutMerchantInput>
  }

  export type RewardCreateManyMerchantInputEnvelope = {
    data: RewardCreateManyMerchantInput | RewardCreateManyMerchantInput[]
    skipDuplicates?: boolean
  }

  export type TransactionCreateWithoutMerchantInput = {
    id?: string
    posProvider: $Enums.POSProvider
    posTransactionId: string
    posLocationId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    pointsEarned?: number
    status?: $Enums.TransactionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    customer?: CustomerCreateNestedOneWithoutTransactionsInput
    location?: LocationCreateNestedOneWithoutTransactionsInput
    ledgerEntries?: LedgerEntryCreateNestedManyWithoutTransactionInput
  }

  export type TransactionUncheckedCreateWithoutMerchantInput = {
    id?: string
    customerId?: string | null
    locationId?: string | null
    posProvider: $Enums.POSProvider
    posTransactionId: string
    posLocationId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    pointsEarned?: number
    status?: $Enums.TransactionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    ledgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutTransactionInput
  }

  export type TransactionCreateOrConnectWithoutMerchantInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutMerchantInput, TransactionUncheckedCreateWithoutMerchantInput>
  }

  export type TransactionCreateManyMerchantInputEnvelope = {
    data: TransactionCreateManyMerchantInput | TransactionCreateManyMerchantInput[]
    skipDuplicates?: boolean
  }

  export type RedemptionCreateWithoutMerchantInput = {
    id?: string
    qrToken: string
    pinCode: string
    status?: $Enums.RedemptionStatus
    pointsDeducted?: number | null
    redeemedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutRedemptionsInput
    reward: RewardCreateNestedOneWithoutRedemptionsInput
    ledgerEntry?: LedgerEntryCreateNestedOneWithoutRedemptionInput
  }

  export type RedemptionUncheckedCreateWithoutMerchantInput = {
    id?: string
    customerId: string
    rewardId: string
    qrToken: string
    pinCode: string
    status?: $Enums.RedemptionStatus
    pointsDeducted?: number | null
    redeemedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ledgerEntry?: LedgerEntryUncheckedCreateNestedOneWithoutRedemptionInput
  }

  export type RedemptionCreateOrConnectWithoutMerchantInput = {
    where: RedemptionWhereUniqueInput
    create: XOR<RedemptionCreateWithoutMerchantInput, RedemptionUncheckedCreateWithoutMerchantInput>
  }

  export type RedemptionCreateManyMerchantInputEnvelope = {
    data: RedemptionCreateManyMerchantInput | RedemptionCreateManyMerchantInput[]
    skipDuplicates?: boolean
  }

  export type CustomerBalanceCreateWithoutMerchantInput = {
    id?: string
    points?: number
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutCustomerBalancesInput
  }

  export type CustomerBalanceUncheckedCreateWithoutMerchantInput = {
    id?: string
    customerId: string
    points?: number
    updatedAt?: Date | string
  }

  export type CustomerBalanceCreateOrConnectWithoutMerchantInput = {
    where: CustomerBalanceWhereUniqueInput
    create: XOR<CustomerBalanceCreateWithoutMerchantInput, CustomerBalanceUncheckedCreateWithoutMerchantInput>
  }

  export type CustomerBalanceCreateManyMerchantInputEnvelope = {
    data: CustomerBalanceCreateManyMerchantInput | CustomerBalanceCreateManyMerchantInput[]
    skipDuplicates?: boolean
  }

  export type CustomerItemCountCreateWithoutMerchantInput = {
    id?: string
    itemName: string
    count?: number
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutItemCountsInput
    reward: RewardCreateNestedOneWithoutItemCountsInput
  }

  export type CustomerItemCountUncheckedCreateWithoutMerchantInput = {
    id?: string
    customerId: string
    rewardId: string
    itemName: string
    count?: number
    updatedAt?: Date | string
  }

  export type CustomerItemCountCreateOrConnectWithoutMerchantInput = {
    where: CustomerItemCountWhereUniqueInput
    create: XOR<CustomerItemCountCreateWithoutMerchantInput, CustomerItemCountUncheckedCreateWithoutMerchantInput>
  }

  export type CustomerItemCountCreateManyMerchantInputEnvelope = {
    data: CustomerItemCountCreateManyMerchantInput | CustomerItemCountCreateManyMerchantInput[]
    skipDuplicates?: boolean
  }

  export type LedgerEntryCreateWithoutMerchantInput = {
    id?: string
    type: $Enums.LedgerEntryType
    points: number
    createdAt?: Date | string
    customer: CustomerCreateNestedOneWithoutLedgerEntriesInput
    transaction?: TransactionCreateNestedOneWithoutLedgerEntriesInput
    redemption?: RedemptionCreateNestedOneWithoutLedgerEntryInput
  }

  export type LedgerEntryUncheckedCreateWithoutMerchantInput = {
    id?: string
    customerId: string
    type: $Enums.LedgerEntryType
    points: number
    transactionId?: string | null
    redemptionId?: string | null
    createdAt?: Date | string
  }

  export type LedgerEntryCreateOrConnectWithoutMerchantInput = {
    where: LedgerEntryWhereUniqueInput
    create: XOR<LedgerEntryCreateWithoutMerchantInput, LedgerEntryUncheckedCreateWithoutMerchantInput>
  }

  export type LedgerEntryCreateManyMerchantInputEnvelope = {
    data: LedgerEntryCreateManyMerchantInput | LedgerEntryCreateManyMerchantInput[]
    skipDuplicates?: boolean
  }

  export type POSIntegrationUpsertWithWhereUniqueWithoutMerchantInput = {
    where: POSIntegrationWhereUniqueInput
    update: XOR<POSIntegrationUpdateWithoutMerchantInput, POSIntegrationUncheckedUpdateWithoutMerchantInput>
    create: XOR<POSIntegrationCreateWithoutMerchantInput, POSIntegrationUncheckedCreateWithoutMerchantInput>
  }

  export type POSIntegrationUpdateWithWhereUniqueWithoutMerchantInput = {
    where: POSIntegrationWhereUniqueInput
    data: XOR<POSIntegrationUpdateWithoutMerchantInput, POSIntegrationUncheckedUpdateWithoutMerchantInput>
  }

  export type POSIntegrationUpdateManyWithWhereWithoutMerchantInput = {
    where: POSIntegrationScalarWhereInput
    data: XOR<POSIntegrationUpdateManyMutationInput, POSIntegrationUncheckedUpdateManyWithoutMerchantInput>
  }

  export type POSIntegrationScalarWhereInput = {
    AND?: POSIntegrationScalarWhereInput | POSIntegrationScalarWhereInput[]
    OR?: POSIntegrationScalarWhereInput[]
    NOT?: POSIntegrationScalarWhereInput | POSIntegrationScalarWhereInput[]
    id?: StringFilter<"POSIntegration"> | string
    merchantId?: StringFilter<"POSIntegration"> | string
    provider?: EnumPOSProviderFilter<"POSIntegration"> | $Enums.POSProvider
    accessToken?: StringFilter<"POSIntegration"> | string
    refreshToken?: StringNullableFilter<"POSIntegration"> | string | null
    providerMerchantId?: StringFilter<"POSIntegration"> | string
    expiresAt?: DateTimeNullableFilter<"POSIntegration"> | Date | string | null
    createdAt?: DateTimeFilter<"POSIntegration"> | Date | string
    updatedAt?: DateTimeFilter<"POSIntegration"> | Date | string
  }

  export type LocationUpsertWithWhereUniqueWithoutMerchantInput = {
    where: LocationWhereUniqueInput
    update: XOR<LocationUpdateWithoutMerchantInput, LocationUncheckedUpdateWithoutMerchantInput>
    create: XOR<LocationCreateWithoutMerchantInput, LocationUncheckedCreateWithoutMerchantInput>
  }

  export type LocationUpdateWithWhereUniqueWithoutMerchantInput = {
    where: LocationWhereUniqueInput
    data: XOR<LocationUpdateWithoutMerchantInput, LocationUncheckedUpdateWithoutMerchantInput>
  }

  export type LocationUpdateManyWithWhereWithoutMerchantInput = {
    where: LocationScalarWhereInput
    data: XOR<LocationUpdateManyMutationInput, LocationUncheckedUpdateManyWithoutMerchantInput>
  }

  export type LocationScalarWhereInput = {
    AND?: LocationScalarWhereInput | LocationScalarWhereInput[]
    OR?: LocationScalarWhereInput[]
    NOT?: LocationScalarWhereInput | LocationScalarWhereInput[]
    id?: StringFilter<"Location"> | string
    merchantId?: StringFilter<"Location"> | string
    posIntegrationId?: StringFilter<"Location"> | string
    posLocationId?: StringFilter<"Location"> | string
    name?: StringFilter<"Location"> | string
    address?: StringNullableFilter<"Location"> | string | null
    city?: StringNullableFilter<"Location"> | string | null
    state?: StringNullableFilter<"Location"> | string | null
    zipCode?: StringNullableFilter<"Location"> | string | null
    country?: StringNullableFilter<"Location"> | string | null
    createdAt?: DateTimeFilter<"Location"> | Date | string
    updatedAt?: DateTimeFilter<"Location"> | Date | string
  }

  export type RewardUpsertWithWhereUniqueWithoutMerchantInput = {
    where: RewardWhereUniqueInput
    update: XOR<RewardUpdateWithoutMerchantInput, RewardUncheckedUpdateWithoutMerchantInput>
    create: XOR<RewardCreateWithoutMerchantInput, RewardUncheckedCreateWithoutMerchantInput>
  }

  export type RewardUpdateWithWhereUniqueWithoutMerchantInput = {
    where: RewardWhereUniqueInput
    data: XOR<RewardUpdateWithoutMerchantInput, RewardUncheckedUpdateWithoutMerchantInput>
  }

  export type RewardUpdateManyWithWhereWithoutMerchantInput = {
    where: RewardScalarWhereInput
    data: XOR<RewardUpdateManyMutationInput, RewardUncheckedUpdateManyWithoutMerchantInput>
  }

  export type RewardScalarWhereInput = {
    AND?: RewardScalarWhereInput | RewardScalarWhereInput[]
    OR?: RewardScalarWhereInput[]
    NOT?: RewardScalarWhereInput | RewardScalarWhereInput[]
    id?: StringFilter<"Reward"> | string
    merchantId?: StringFilter<"Reward"> | string
    name?: StringFilter<"Reward"> | string
    description?: StringNullableFilter<"Reward"> | string | null
    type?: EnumRewardTypeFilter<"Reward"> | $Enums.RewardType
    pointsCost?: IntNullableFilter<"Reward"> | number | null
    itemName?: StringNullableFilter<"Reward"> | string | null
    itemCount?: IntNullableFilter<"Reward"> | number | null
    isActive?: BoolFilter<"Reward"> | boolean
    createdAt?: DateTimeFilter<"Reward"> | Date | string
    updatedAt?: DateTimeFilter<"Reward"> | Date | string
  }

  export type TransactionUpsertWithWhereUniqueWithoutMerchantInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutMerchantInput, TransactionUncheckedUpdateWithoutMerchantInput>
    create: XOR<TransactionCreateWithoutMerchantInput, TransactionUncheckedCreateWithoutMerchantInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutMerchantInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutMerchantInput, TransactionUncheckedUpdateWithoutMerchantInput>
  }

  export type TransactionUpdateManyWithWhereWithoutMerchantInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutMerchantInput>
  }

  export type TransactionScalarWhereInput = {
    AND?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
    OR?: TransactionScalarWhereInput[]
    NOT?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
    id?: StringFilter<"Transaction"> | string
    merchantId?: StringFilter<"Transaction"> | string
    customerId?: StringNullableFilter<"Transaction"> | string | null
    locationId?: StringNullableFilter<"Transaction"> | string | null
    posProvider?: EnumPOSProviderFilter<"Transaction"> | $Enums.POSProvider
    posTransactionId?: StringFilter<"Transaction"> | string
    posLocationId?: StringNullableFilter<"Transaction"> | string | null
    amount?: DecimalFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    pointsEarned?: IntFilter<"Transaction"> | number
    status?: EnumTransactionStatusFilter<"Transaction"> | $Enums.TransactionStatus
    metadata?: JsonNullableFilter<"Transaction">
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeFilter<"Transaction"> | Date | string
  }

  export type RedemptionUpsertWithWhereUniqueWithoutMerchantInput = {
    where: RedemptionWhereUniqueInput
    update: XOR<RedemptionUpdateWithoutMerchantInput, RedemptionUncheckedUpdateWithoutMerchantInput>
    create: XOR<RedemptionCreateWithoutMerchantInput, RedemptionUncheckedCreateWithoutMerchantInput>
  }

  export type RedemptionUpdateWithWhereUniqueWithoutMerchantInput = {
    where: RedemptionWhereUniqueInput
    data: XOR<RedemptionUpdateWithoutMerchantInput, RedemptionUncheckedUpdateWithoutMerchantInput>
  }

  export type RedemptionUpdateManyWithWhereWithoutMerchantInput = {
    where: RedemptionScalarWhereInput
    data: XOR<RedemptionUpdateManyMutationInput, RedemptionUncheckedUpdateManyWithoutMerchantInput>
  }

  export type RedemptionScalarWhereInput = {
    AND?: RedemptionScalarWhereInput | RedemptionScalarWhereInput[]
    OR?: RedemptionScalarWhereInput[]
    NOT?: RedemptionScalarWhereInput | RedemptionScalarWhereInput[]
    id?: StringFilter<"Redemption"> | string
    customerId?: StringFilter<"Redemption"> | string
    merchantId?: StringFilter<"Redemption"> | string
    rewardId?: StringFilter<"Redemption"> | string
    qrToken?: StringFilter<"Redemption"> | string
    pinCode?: StringFilter<"Redemption"> | string
    status?: EnumRedemptionStatusFilter<"Redemption"> | $Enums.RedemptionStatus
    pointsDeducted?: IntNullableFilter<"Redemption"> | number | null
    redeemedAt?: DateTimeNullableFilter<"Redemption"> | Date | string | null
    createdAt?: DateTimeFilter<"Redemption"> | Date | string
    updatedAt?: DateTimeFilter<"Redemption"> | Date | string
  }

  export type CustomerBalanceUpsertWithWhereUniqueWithoutMerchantInput = {
    where: CustomerBalanceWhereUniqueInput
    update: XOR<CustomerBalanceUpdateWithoutMerchantInput, CustomerBalanceUncheckedUpdateWithoutMerchantInput>
    create: XOR<CustomerBalanceCreateWithoutMerchantInput, CustomerBalanceUncheckedCreateWithoutMerchantInput>
  }

  export type CustomerBalanceUpdateWithWhereUniqueWithoutMerchantInput = {
    where: CustomerBalanceWhereUniqueInput
    data: XOR<CustomerBalanceUpdateWithoutMerchantInput, CustomerBalanceUncheckedUpdateWithoutMerchantInput>
  }

  export type CustomerBalanceUpdateManyWithWhereWithoutMerchantInput = {
    where: CustomerBalanceScalarWhereInput
    data: XOR<CustomerBalanceUpdateManyMutationInput, CustomerBalanceUncheckedUpdateManyWithoutMerchantInput>
  }

  export type CustomerBalanceScalarWhereInput = {
    AND?: CustomerBalanceScalarWhereInput | CustomerBalanceScalarWhereInput[]
    OR?: CustomerBalanceScalarWhereInput[]
    NOT?: CustomerBalanceScalarWhereInput | CustomerBalanceScalarWhereInput[]
    id?: StringFilter<"CustomerBalance"> | string
    customerId?: StringFilter<"CustomerBalance"> | string
    merchantId?: StringFilter<"CustomerBalance"> | string
    points?: IntFilter<"CustomerBalance"> | number
    updatedAt?: DateTimeFilter<"CustomerBalance"> | Date | string
  }

  export type CustomerItemCountUpsertWithWhereUniqueWithoutMerchantInput = {
    where: CustomerItemCountWhereUniqueInput
    update: XOR<CustomerItemCountUpdateWithoutMerchantInput, CustomerItemCountUncheckedUpdateWithoutMerchantInput>
    create: XOR<CustomerItemCountCreateWithoutMerchantInput, CustomerItemCountUncheckedCreateWithoutMerchantInput>
  }

  export type CustomerItemCountUpdateWithWhereUniqueWithoutMerchantInput = {
    where: CustomerItemCountWhereUniqueInput
    data: XOR<CustomerItemCountUpdateWithoutMerchantInput, CustomerItemCountUncheckedUpdateWithoutMerchantInput>
  }

  export type CustomerItemCountUpdateManyWithWhereWithoutMerchantInput = {
    where: CustomerItemCountScalarWhereInput
    data: XOR<CustomerItemCountUpdateManyMutationInput, CustomerItemCountUncheckedUpdateManyWithoutMerchantInput>
  }

  export type CustomerItemCountScalarWhereInput = {
    AND?: CustomerItemCountScalarWhereInput | CustomerItemCountScalarWhereInput[]
    OR?: CustomerItemCountScalarWhereInput[]
    NOT?: CustomerItemCountScalarWhereInput | CustomerItemCountScalarWhereInput[]
    id?: StringFilter<"CustomerItemCount"> | string
    customerId?: StringFilter<"CustomerItemCount"> | string
    merchantId?: StringFilter<"CustomerItemCount"> | string
    rewardId?: StringFilter<"CustomerItemCount"> | string
    itemName?: StringFilter<"CustomerItemCount"> | string
    count?: IntFilter<"CustomerItemCount"> | number
    updatedAt?: DateTimeFilter<"CustomerItemCount"> | Date | string
  }

  export type LedgerEntryUpsertWithWhereUniqueWithoutMerchantInput = {
    where: LedgerEntryWhereUniqueInput
    update: XOR<LedgerEntryUpdateWithoutMerchantInput, LedgerEntryUncheckedUpdateWithoutMerchantInput>
    create: XOR<LedgerEntryCreateWithoutMerchantInput, LedgerEntryUncheckedCreateWithoutMerchantInput>
  }

  export type LedgerEntryUpdateWithWhereUniqueWithoutMerchantInput = {
    where: LedgerEntryWhereUniqueInput
    data: XOR<LedgerEntryUpdateWithoutMerchantInput, LedgerEntryUncheckedUpdateWithoutMerchantInput>
  }

  export type LedgerEntryUpdateManyWithWhereWithoutMerchantInput = {
    where: LedgerEntryScalarWhereInput
    data: XOR<LedgerEntryUpdateManyMutationInput, LedgerEntryUncheckedUpdateManyWithoutMerchantInput>
  }

  export type LedgerEntryScalarWhereInput = {
    AND?: LedgerEntryScalarWhereInput | LedgerEntryScalarWhereInput[]
    OR?: LedgerEntryScalarWhereInput[]
    NOT?: LedgerEntryScalarWhereInput | LedgerEntryScalarWhereInput[]
    id?: StringFilter<"LedgerEntry"> | string
    customerId?: StringFilter<"LedgerEntry"> | string
    merchantId?: StringFilter<"LedgerEntry"> | string
    type?: EnumLedgerEntryTypeFilter<"LedgerEntry"> | $Enums.LedgerEntryType
    points?: IntFilter<"LedgerEntry"> | number
    transactionId?: StringNullableFilter<"LedgerEntry"> | string | null
    redemptionId?: StringNullableFilter<"LedgerEntry"> | string | null
    createdAt?: DateTimeFilter<"LedgerEntry"> | Date | string
  }

  export type MerchantCreateWithoutPosIntegrationsInput = {
    id?: string
    email: string
    password: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    locations?: LocationCreateNestedManyWithoutMerchantInput
    rewards?: RewardCreateNestedManyWithoutMerchantInput
    transactions?: TransactionCreateNestedManyWithoutMerchantInput
    redemptions?: RedemptionCreateNestedManyWithoutMerchantInput
    customerBalances?: CustomerBalanceCreateNestedManyWithoutMerchantInput
    itemCounts?: CustomerItemCountCreateNestedManyWithoutMerchantInput
    ledgerEntries?: LedgerEntryCreateNestedManyWithoutMerchantInput
  }

  export type MerchantUncheckedCreateWithoutPosIntegrationsInput = {
    id?: string
    email: string
    password: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    locations?: LocationUncheckedCreateNestedManyWithoutMerchantInput
    rewards?: RewardUncheckedCreateNestedManyWithoutMerchantInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutMerchantInput
    redemptions?: RedemptionUncheckedCreateNestedManyWithoutMerchantInput
    customerBalances?: CustomerBalanceUncheckedCreateNestedManyWithoutMerchantInput
    itemCounts?: CustomerItemCountUncheckedCreateNestedManyWithoutMerchantInput
    ledgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutMerchantInput
  }

  export type MerchantCreateOrConnectWithoutPosIntegrationsInput = {
    where: MerchantWhereUniqueInput
    create: XOR<MerchantCreateWithoutPosIntegrationsInput, MerchantUncheckedCreateWithoutPosIntegrationsInput>
  }

  export type LocationCreateWithoutPosIntegrationInput = {
    id?: string
    posLocationId: string
    name: string
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    country?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    merchant: MerchantCreateNestedOneWithoutLocationsInput
    transactions?: TransactionCreateNestedManyWithoutLocationInput
  }

  export type LocationUncheckedCreateWithoutPosIntegrationInput = {
    id?: string
    merchantId: string
    posLocationId: string
    name: string
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    country?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: TransactionUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationCreateOrConnectWithoutPosIntegrationInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutPosIntegrationInput, LocationUncheckedCreateWithoutPosIntegrationInput>
  }

  export type LocationCreateManyPosIntegrationInputEnvelope = {
    data: LocationCreateManyPosIntegrationInput | LocationCreateManyPosIntegrationInput[]
    skipDuplicates?: boolean
  }

  export type MerchantUpsertWithoutPosIntegrationsInput = {
    update: XOR<MerchantUpdateWithoutPosIntegrationsInput, MerchantUncheckedUpdateWithoutPosIntegrationsInput>
    create: XOR<MerchantCreateWithoutPosIntegrationsInput, MerchantUncheckedCreateWithoutPosIntegrationsInput>
    where?: MerchantWhereInput
  }

  export type MerchantUpdateToOneWithWhereWithoutPosIntegrationsInput = {
    where?: MerchantWhereInput
    data: XOR<MerchantUpdateWithoutPosIntegrationsInput, MerchantUncheckedUpdateWithoutPosIntegrationsInput>
  }

  export type MerchantUpdateWithoutPosIntegrationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locations?: LocationUpdateManyWithoutMerchantNestedInput
    rewards?: RewardUpdateManyWithoutMerchantNestedInput
    transactions?: TransactionUpdateManyWithoutMerchantNestedInput
    redemptions?: RedemptionUpdateManyWithoutMerchantNestedInput
    customerBalances?: CustomerBalanceUpdateManyWithoutMerchantNestedInput
    itemCounts?: CustomerItemCountUpdateManyWithoutMerchantNestedInput
    ledgerEntries?: LedgerEntryUpdateManyWithoutMerchantNestedInput
  }

  export type MerchantUncheckedUpdateWithoutPosIntegrationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locations?: LocationUncheckedUpdateManyWithoutMerchantNestedInput
    rewards?: RewardUncheckedUpdateManyWithoutMerchantNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutMerchantNestedInput
    redemptions?: RedemptionUncheckedUpdateManyWithoutMerchantNestedInput
    customerBalances?: CustomerBalanceUncheckedUpdateManyWithoutMerchantNestedInput
    itemCounts?: CustomerItemCountUncheckedUpdateManyWithoutMerchantNestedInput
    ledgerEntries?: LedgerEntryUncheckedUpdateManyWithoutMerchantNestedInput
  }

  export type LocationUpsertWithWhereUniqueWithoutPosIntegrationInput = {
    where: LocationWhereUniqueInput
    update: XOR<LocationUpdateWithoutPosIntegrationInput, LocationUncheckedUpdateWithoutPosIntegrationInput>
    create: XOR<LocationCreateWithoutPosIntegrationInput, LocationUncheckedCreateWithoutPosIntegrationInput>
  }

  export type LocationUpdateWithWhereUniqueWithoutPosIntegrationInput = {
    where: LocationWhereUniqueInput
    data: XOR<LocationUpdateWithoutPosIntegrationInput, LocationUncheckedUpdateWithoutPosIntegrationInput>
  }

  export type LocationUpdateManyWithWhereWithoutPosIntegrationInput = {
    where: LocationScalarWhereInput
    data: XOR<LocationUpdateManyMutationInput, LocationUncheckedUpdateManyWithoutPosIntegrationInput>
  }

  export type MerchantCreateWithoutLocationsInput = {
    id?: string
    email: string
    password: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    posIntegrations?: POSIntegrationCreateNestedManyWithoutMerchantInput
    rewards?: RewardCreateNestedManyWithoutMerchantInput
    transactions?: TransactionCreateNestedManyWithoutMerchantInput
    redemptions?: RedemptionCreateNestedManyWithoutMerchantInput
    customerBalances?: CustomerBalanceCreateNestedManyWithoutMerchantInput
    itemCounts?: CustomerItemCountCreateNestedManyWithoutMerchantInput
    ledgerEntries?: LedgerEntryCreateNestedManyWithoutMerchantInput
  }

  export type MerchantUncheckedCreateWithoutLocationsInput = {
    id?: string
    email: string
    password: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    posIntegrations?: POSIntegrationUncheckedCreateNestedManyWithoutMerchantInput
    rewards?: RewardUncheckedCreateNestedManyWithoutMerchantInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutMerchantInput
    redemptions?: RedemptionUncheckedCreateNestedManyWithoutMerchantInput
    customerBalances?: CustomerBalanceUncheckedCreateNestedManyWithoutMerchantInput
    itemCounts?: CustomerItemCountUncheckedCreateNestedManyWithoutMerchantInput
    ledgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutMerchantInput
  }

  export type MerchantCreateOrConnectWithoutLocationsInput = {
    where: MerchantWhereUniqueInput
    create: XOR<MerchantCreateWithoutLocationsInput, MerchantUncheckedCreateWithoutLocationsInput>
  }

  export type POSIntegrationCreateWithoutLocationsInput = {
    id?: string
    provider: $Enums.POSProvider
    accessToken: string
    refreshToken?: string | null
    providerMerchantId: string
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    merchant: MerchantCreateNestedOneWithoutPosIntegrationsInput
  }

  export type POSIntegrationUncheckedCreateWithoutLocationsInput = {
    id?: string
    merchantId: string
    provider: $Enums.POSProvider
    accessToken: string
    refreshToken?: string | null
    providerMerchantId: string
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type POSIntegrationCreateOrConnectWithoutLocationsInput = {
    where: POSIntegrationWhereUniqueInput
    create: XOR<POSIntegrationCreateWithoutLocationsInput, POSIntegrationUncheckedCreateWithoutLocationsInput>
  }

  export type TransactionCreateWithoutLocationInput = {
    id?: string
    posProvider: $Enums.POSProvider
    posTransactionId: string
    posLocationId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    pointsEarned?: number
    status?: $Enums.TransactionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    merchant: MerchantCreateNestedOneWithoutTransactionsInput
    customer?: CustomerCreateNestedOneWithoutTransactionsInput
    ledgerEntries?: LedgerEntryCreateNestedManyWithoutTransactionInput
  }

  export type TransactionUncheckedCreateWithoutLocationInput = {
    id?: string
    merchantId: string
    customerId?: string | null
    posProvider: $Enums.POSProvider
    posTransactionId: string
    posLocationId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    pointsEarned?: number
    status?: $Enums.TransactionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    ledgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutTransactionInput
  }

  export type TransactionCreateOrConnectWithoutLocationInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutLocationInput, TransactionUncheckedCreateWithoutLocationInput>
  }

  export type TransactionCreateManyLocationInputEnvelope = {
    data: TransactionCreateManyLocationInput | TransactionCreateManyLocationInput[]
    skipDuplicates?: boolean
  }

  export type MerchantUpsertWithoutLocationsInput = {
    update: XOR<MerchantUpdateWithoutLocationsInput, MerchantUncheckedUpdateWithoutLocationsInput>
    create: XOR<MerchantCreateWithoutLocationsInput, MerchantUncheckedCreateWithoutLocationsInput>
    where?: MerchantWhereInput
  }

  export type MerchantUpdateToOneWithWhereWithoutLocationsInput = {
    where?: MerchantWhereInput
    data: XOR<MerchantUpdateWithoutLocationsInput, MerchantUncheckedUpdateWithoutLocationsInput>
  }

  export type MerchantUpdateWithoutLocationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posIntegrations?: POSIntegrationUpdateManyWithoutMerchantNestedInput
    rewards?: RewardUpdateManyWithoutMerchantNestedInput
    transactions?: TransactionUpdateManyWithoutMerchantNestedInput
    redemptions?: RedemptionUpdateManyWithoutMerchantNestedInput
    customerBalances?: CustomerBalanceUpdateManyWithoutMerchantNestedInput
    itemCounts?: CustomerItemCountUpdateManyWithoutMerchantNestedInput
    ledgerEntries?: LedgerEntryUpdateManyWithoutMerchantNestedInput
  }

  export type MerchantUncheckedUpdateWithoutLocationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posIntegrations?: POSIntegrationUncheckedUpdateManyWithoutMerchantNestedInput
    rewards?: RewardUncheckedUpdateManyWithoutMerchantNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutMerchantNestedInput
    redemptions?: RedemptionUncheckedUpdateManyWithoutMerchantNestedInput
    customerBalances?: CustomerBalanceUncheckedUpdateManyWithoutMerchantNestedInput
    itemCounts?: CustomerItemCountUncheckedUpdateManyWithoutMerchantNestedInput
    ledgerEntries?: LedgerEntryUncheckedUpdateManyWithoutMerchantNestedInput
  }

  export type POSIntegrationUpsertWithoutLocationsInput = {
    update: XOR<POSIntegrationUpdateWithoutLocationsInput, POSIntegrationUncheckedUpdateWithoutLocationsInput>
    create: XOR<POSIntegrationCreateWithoutLocationsInput, POSIntegrationUncheckedCreateWithoutLocationsInput>
    where?: POSIntegrationWhereInput
  }

  export type POSIntegrationUpdateToOneWithWhereWithoutLocationsInput = {
    where?: POSIntegrationWhereInput
    data: XOR<POSIntegrationUpdateWithoutLocationsInput, POSIntegrationUncheckedUpdateWithoutLocationsInput>
  }

  export type POSIntegrationUpdateWithoutLocationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumPOSProviderFieldUpdateOperationsInput | $Enums.POSProvider
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    providerMerchantId?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    merchant?: MerchantUpdateOneRequiredWithoutPosIntegrationsNestedInput
  }

  export type POSIntegrationUncheckedUpdateWithoutLocationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    merchantId?: StringFieldUpdateOperationsInput | string
    provider?: EnumPOSProviderFieldUpdateOperationsInput | $Enums.POSProvider
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    providerMerchantId?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUpsertWithWhereUniqueWithoutLocationInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutLocationInput, TransactionUncheckedUpdateWithoutLocationInput>
    create: XOR<TransactionCreateWithoutLocationInput, TransactionUncheckedCreateWithoutLocationInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutLocationInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutLocationInput, TransactionUncheckedUpdateWithoutLocationInput>
  }

  export type TransactionUpdateManyWithWhereWithoutLocationInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutLocationInput>
  }

  export type LinkedCardCreateWithoutCustomerInput = {
    id?: string
    cardFingerprint: string
    last4: string
    brand?: string | null
    zipCode?: string | null
    posProvider: $Enums.POSProvider
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LinkedCardUncheckedCreateWithoutCustomerInput = {
    id?: string
    cardFingerprint: string
    last4: string
    brand?: string | null
    zipCode?: string | null
    posProvider: $Enums.POSProvider
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LinkedCardCreateOrConnectWithoutCustomerInput = {
    where: LinkedCardWhereUniqueInput
    create: XOR<LinkedCardCreateWithoutCustomerInput, LinkedCardUncheckedCreateWithoutCustomerInput>
  }

  export type LinkedCardCreateManyCustomerInputEnvelope = {
    data: LinkedCardCreateManyCustomerInput | LinkedCardCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type TransactionCreateWithoutCustomerInput = {
    id?: string
    posProvider: $Enums.POSProvider
    posTransactionId: string
    posLocationId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    pointsEarned?: number
    status?: $Enums.TransactionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    merchant: MerchantCreateNestedOneWithoutTransactionsInput
    location?: LocationCreateNestedOneWithoutTransactionsInput
    ledgerEntries?: LedgerEntryCreateNestedManyWithoutTransactionInput
  }

  export type TransactionUncheckedCreateWithoutCustomerInput = {
    id?: string
    merchantId: string
    locationId?: string | null
    posProvider: $Enums.POSProvider
    posTransactionId: string
    posLocationId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    pointsEarned?: number
    status?: $Enums.TransactionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    ledgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutTransactionInput
  }

  export type TransactionCreateOrConnectWithoutCustomerInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutCustomerInput, TransactionUncheckedCreateWithoutCustomerInput>
  }

  export type TransactionCreateManyCustomerInputEnvelope = {
    data: TransactionCreateManyCustomerInput | TransactionCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type CustomerBalanceCreateWithoutCustomerInput = {
    id?: string
    points?: number
    updatedAt?: Date | string
    merchant: MerchantCreateNestedOneWithoutCustomerBalancesInput
  }

  export type CustomerBalanceUncheckedCreateWithoutCustomerInput = {
    id?: string
    merchantId: string
    points?: number
    updatedAt?: Date | string
  }

  export type CustomerBalanceCreateOrConnectWithoutCustomerInput = {
    where: CustomerBalanceWhereUniqueInput
    create: XOR<CustomerBalanceCreateWithoutCustomerInput, CustomerBalanceUncheckedCreateWithoutCustomerInput>
  }

  export type CustomerBalanceCreateManyCustomerInputEnvelope = {
    data: CustomerBalanceCreateManyCustomerInput | CustomerBalanceCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type RedemptionCreateWithoutCustomerInput = {
    id?: string
    qrToken: string
    pinCode: string
    status?: $Enums.RedemptionStatus
    pointsDeducted?: number | null
    redeemedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    merchant: MerchantCreateNestedOneWithoutRedemptionsInput
    reward: RewardCreateNestedOneWithoutRedemptionsInput
    ledgerEntry?: LedgerEntryCreateNestedOneWithoutRedemptionInput
  }

  export type RedemptionUncheckedCreateWithoutCustomerInput = {
    id?: string
    merchantId: string
    rewardId: string
    qrToken: string
    pinCode: string
    status?: $Enums.RedemptionStatus
    pointsDeducted?: number | null
    redeemedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ledgerEntry?: LedgerEntryUncheckedCreateNestedOneWithoutRedemptionInput
  }

  export type RedemptionCreateOrConnectWithoutCustomerInput = {
    where: RedemptionWhereUniqueInput
    create: XOR<RedemptionCreateWithoutCustomerInput, RedemptionUncheckedCreateWithoutCustomerInput>
  }

  export type RedemptionCreateManyCustomerInputEnvelope = {
    data: RedemptionCreateManyCustomerInput | RedemptionCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type LedgerEntryCreateWithoutCustomerInput = {
    id?: string
    type: $Enums.LedgerEntryType
    points: number
    createdAt?: Date | string
    merchant: MerchantCreateNestedOneWithoutLedgerEntriesInput
    transaction?: TransactionCreateNestedOneWithoutLedgerEntriesInput
    redemption?: RedemptionCreateNestedOneWithoutLedgerEntryInput
  }

  export type LedgerEntryUncheckedCreateWithoutCustomerInput = {
    id?: string
    merchantId: string
    type: $Enums.LedgerEntryType
    points: number
    transactionId?: string | null
    redemptionId?: string | null
    createdAt?: Date | string
  }

  export type LedgerEntryCreateOrConnectWithoutCustomerInput = {
    where: LedgerEntryWhereUniqueInput
    create: XOR<LedgerEntryCreateWithoutCustomerInput, LedgerEntryUncheckedCreateWithoutCustomerInput>
  }

  export type LedgerEntryCreateManyCustomerInputEnvelope = {
    data: LedgerEntryCreateManyCustomerInput | LedgerEntryCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type CustomerItemCountCreateWithoutCustomerInput = {
    id?: string
    itemName: string
    count?: number
    updatedAt?: Date | string
    merchant: MerchantCreateNestedOneWithoutItemCountsInput
    reward: RewardCreateNestedOneWithoutItemCountsInput
  }

  export type CustomerItemCountUncheckedCreateWithoutCustomerInput = {
    id?: string
    merchantId: string
    rewardId: string
    itemName: string
    count?: number
    updatedAt?: Date | string
  }

  export type CustomerItemCountCreateOrConnectWithoutCustomerInput = {
    where: CustomerItemCountWhereUniqueInput
    create: XOR<CustomerItemCountCreateWithoutCustomerInput, CustomerItemCountUncheckedCreateWithoutCustomerInput>
  }

  export type CustomerItemCountCreateManyCustomerInputEnvelope = {
    data: CustomerItemCountCreateManyCustomerInput | CustomerItemCountCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type LinkedCardUpsertWithWhereUniqueWithoutCustomerInput = {
    where: LinkedCardWhereUniqueInput
    update: XOR<LinkedCardUpdateWithoutCustomerInput, LinkedCardUncheckedUpdateWithoutCustomerInput>
    create: XOR<LinkedCardCreateWithoutCustomerInput, LinkedCardUncheckedCreateWithoutCustomerInput>
  }

  export type LinkedCardUpdateWithWhereUniqueWithoutCustomerInput = {
    where: LinkedCardWhereUniqueInput
    data: XOR<LinkedCardUpdateWithoutCustomerInput, LinkedCardUncheckedUpdateWithoutCustomerInput>
  }

  export type LinkedCardUpdateManyWithWhereWithoutCustomerInput = {
    where: LinkedCardScalarWhereInput
    data: XOR<LinkedCardUpdateManyMutationInput, LinkedCardUncheckedUpdateManyWithoutCustomerInput>
  }

  export type LinkedCardScalarWhereInput = {
    AND?: LinkedCardScalarWhereInput | LinkedCardScalarWhereInput[]
    OR?: LinkedCardScalarWhereInput[]
    NOT?: LinkedCardScalarWhereInput | LinkedCardScalarWhereInput[]
    id?: StringFilter<"LinkedCard"> | string
    customerId?: StringFilter<"LinkedCard"> | string
    cardFingerprint?: StringFilter<"LinkedCard"> | string
    last4?: StringFilter<"LinkedCard"> | string
    brand?: StringNullableFilter<"LinkedCard"> | string | null
    zipCode?: StringNullableFilter<"LinkedCard"> | string | null
    posProvider?: EnumPOSProviderFilter<"LinkedCard"> | $Enums.POSProvider
    createdAt?: DateTimeFilter<"LinkedCard"> | Date | string
    updatedAt?: DateTimeFilter<"LinkedCard"> | Date | string
  }

  export type TransactionUpsertWithWhereUniqueWithoutCustomerInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutCustomerInput, TransactionUncheckedUpdateWithoutCustomerInput>
    create: XOR<TransactionCreateWithoutCustomerInput, TransactionUncheckedCreateWithoutCustomerInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutCustomerInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutCustomerInput, TransactionUncheckedUpdateWithoutCustomerInput>
  }

  export type TransactionUpdateManyWithWhereWithoutCustomerInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutCustomerInput>
  }

  export type CustomerBalanceUpsertWithWhereUniqueWithoutCustomerInput = {
    where: CustomerBalanceWhereUniqueInput
    update: XOR<CustomerBalanceUpdateWithoutCustomerInput, CustomerBalanceUncheckedUpdateWithoutCustomerInput>
    create: XOR<CustomerBalanceCreateWithoutCustomerInput, CustomerBalanceUncheckedCreateWithoutCustomerInput>
  }

  export type CustomerBalanceUpdateWithWhereUniqueWithoutCustomerInput = {
    where: CustomerBalanceWhereUniqueInput
    data: XOR<CustomerBalanceUpdateWithoutCustomerInput, CustomerBalanceUncheckedUpdateWithoutCustomerInput>
  }

  export type CustomerBalanceUpdateManyWithWhereWithoutCustomerInput = {
    where: CustomerBalanceScalarWhereInput
    data: XOR<CustomerBalanceUpdateManyMutationInput, CustomerBalanceUncheckedUpdateManyWithoutCustomerInput>
  }

  export type RedemptionUpsertWithWhereUniqueWithoutCustomerInput = {
    where: RedemptionWhereUniqueInput
    update: XOR<RedemptionUpdateWithoutCustomerInput, RedemptionUncheckedUpdateWithoutCustomerInput>
    create: XOR<RedemptionCreateWithoutCustomerInput, RedemptionUncheckedCreateWithoutCustomerInput>
  }

  export type RedemptionUpdateWithWhereUniqueWithoutCustomerInput = {
    where: RedemptionWhereUniqueInput
    data: XOR<RedemptionUpdateWithoutCustomerInput, RedemptionUncheckedUpdateWithoutCustomerInput>
  }

  export type RedemptionUpdateManyWithWhereWithoutCustomerInput = {
    where: RedemptionScalarWhereInput
    data: XOR<RedemptionUpdateManyMutationInput, RedemptionUncheckedUpdateManyWithoutCustomerInput>
  }

  export type LedgerEntryUpsertWithWhereUniqueWithoutCustomerInput = {
    where: LedgerEntryWhereUniqueInput
    update: XOR<LedgerEntryUpdateWithoutCustomerInput, LedgerEntryUncheckedUpdateWithoutCustomerInput>
    create: XOR<LedgerEntryCreateWithoutCustomerInput, LedgerEntryUncheckedCreateWithoutCustomerInput>
  }

  export type LedgerEntryUpdateWithWhereUniqueWithoutCustomerInput = {
    where: LedgerEntryWhereUniqueInput
    data: XOR<LedgerEntryUpdateWithoutCustomerInput, LedgerEntryUncheckedUpdateWithoutCustomerInput>
  }

  export type LedgerEntryUpdateManyWithWhereWithoutCustomerInput = {
    where: LedgerEntryScalarWhereInput
    data: XOR<LedgerEntryUpdateManyMutationInput, LedgerEntryUncheckedUpdateManyWithoutCustomerInput>
  }

  export type CustomerItemCountUpsertWithWhereUniqueWithoutCustomerInput = {
    where: CustomerItemCountWhereUniqueInput
    update: XOR<CustomerItemCountUpdateWithoutCustomerInput, CustomerItemCountUncheckedUpdateWithoutCustomerInput>
    create: XOR<CustomerItemCountCreateWithoutCustomerInput, CustomerItemCountUncheckedCreateWithoutCustomerInput>
  }

  export type CustomerItemCountUpdateWithWhereUniqueWithoutCustomerInput = {
    where: CustomerItemCountWhereUniqueInput
    data: XOR<CustomerItemCountUpdateWithoutCustomerInput, CustomerItemCountUncheckedUpdateWithoutCustomerInput>
  }

  export type CustomerItemCountUpdateManyWithWhereWithoutCustomerInput = {
    where: CustomerItemCountScalarWhereInput
    data: XOR<CustomerItemCountUpdateManyMutationInput, CustomerItemCountUncheckedUpdateManyWithoutCustomerInput>
  }

  export type CustomerCreateWithoutLinkedCardsInput = {
    id?: string
    phoneNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: TransactionCreateNestedManyWithoutCustomerInput
    customerBalances?: CustomerBalanceCreateNestedManyWithoutCustomerInput
    redemptions?: RedemptionCreateNestedManyWithoutCustomerInput
    ledgerEntries?: LedgerEntryCreateNestedManyWithoutCustomerInput
    itemCounts?: CustomerItemCountCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutLinkedCardsInput = {
    id?: string
    phoneNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: TransactionUncheckedCreateNestedManyWithoutCustomerInput
    customerBalances?: CustomerBalanceUncheckedCreateNestedManyWithoutCustomerInput
    redemptions?: RedemptionUncheckedCreateNestedManyWithoutCustomerInput
    ledgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutCustomerInput
    itemCounts?: CustomerItemCountUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutLinkedCardsInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutLinkedCardsInput, CustomerUncheckedCreateWithoutLinkedCardsInput>
  }

  export type CustomerUpsertWithoutLinkedCardsInput = {
    update: XOR<CustomerUpdateWithoutLinkedCardsInput, CustomerUncheckedUpdateWithoutLinkedCardsInput>
    create: XOR<CustomerCreateWithoutLinkedCardsInput, CustomerUncheckedCreateWithoutLinkedCardsInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutLinkedCardsInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutLinkedCardsInput, CustomerUncheckedUpdateWithoutLinkedCardsInput>
  }

  export type CustomerUpdateWithoutLinkedCardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUpdateManyWithoutCustomerNestedInput
    customerBalances?: CustomerBalanceUpdateManyWithoutCustomerNestedInput
    redemptions?: RedemptionUpdateManyWithoutCustomerNestedInput
    ledgerEntries?: LedgerEntryUpdateManyWithoutCustomerNestedInput
    itemCounts?: CustomerItemCountUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutLinkedCardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUncheckedUpdateManyWithoutCustomerNestedInput
    customerBalances?: CustomerBalanceUncheckedUpdateManyWithoutCustomerNestedInput
    redemptions?: RedemptionUncheckedUpdateManyWithoutCustomerNestedInput
    ledgerEntries?: LedgerEntryUncheckedUpdateManyWithoutCustomerNestedInput
    itemCounts?: CustomerItemCountUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type MerchantCreateWithoutTransactionsInput = {
    id?: string
    email: string
    password: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    posIntegrations?: POSIntegrationCreateNestedManyWithoutMerchantInput
    locations?: LocationCreateNestedManyWithoutMerchantInput
    rewards?: RewardCreateNestedManyWithoutMerchantInput
    redemptions?: RedemptionCreateNestedManyWithoutMerchantInput
    customerBalances?: CustomerBalanceCreateNestedManyWithoutMerchantInput
    itemCounts?: CustomerItemCountCreateNestedManyWithoutMerchantInput
    ledgerEntries?: LedgerEntryCreateNestedManyWithoutMerchantInput
  }

  export type MerchantUncheckedCreateWithoutTransactionsInput = {
    id?: string
    email: string
    password: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    posIntegrations?: POSIntegrationUncheckedCreateNestedManyWithoutMerchantInput
    locations?: LocationUncheckedCreateNestedManyWithoutMerchantInput
    rewards?: RewardUncheckedCreateNestedManyWithoutMerchantInput
    redemptions?: RedemptionUncheckedCreateNestedManyWithoutMerchantInput
    customerBalances?: CustomerBalanceUncheckedCreateNestedManyWithoutMerchantInput
    itemCounts?: CustomerItemCountUncheckedCreateNestedManyWithoutMerchantInput
    ledgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutMerchantInput
  }

  export type MerchantCreateOrConnectWithoutTransactionsInput = {
    where: MerchantWhereUniqueInput
    create: XOR<MerchantCreateWithoutTransactionsInput, MerchantUncheckedCreateWithoutTransactionsInput>
  }

  export type CustomerCreateWithoutTransactionsInput = {
    id?: string
    phoneNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    linkedCards?: LinkedCardCreateNestedManyWithoutCustomerInput
    customerBalances?: CustomerBalanceCreateNestedManyWithoutCustomerInput
    redemptions?: RedemptionCreateNestedManyWithoutCustomerInput
    ledgerEntries?: LedgerEntryCreateNestedManyWithoutCustomerInput
    itemCounts?: CustomerItemCountCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutTransactionsInput = {
    id?: string
    phoneNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    linkedCards?: LinkedCardUncheckedCreateNestedManyWithoutCustomerInput
    customerBalances?: CustomerBalanceUncheckedCreateNestedManyWithoutCustomerInput
    redemptions?: RedemptionUncheckedCreateNestedManyWithoutCustomerInput
    ledgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutCustomerInput
    itemCounts?: CustomerItemCountUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutTransactionsInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutTransactionsInput, CustomerUncheckedCreateWithoutTransactionsInput>
  }

  export type LocationCreateWithoutTransactionsInput = {
    id?: string
    posLocationId: string
    name: string
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    country?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    merchant: MerchantCreateNestedOneWithoutLocationsInput
    posIntegration: POSIntegrationCreateNestedOneWithoutLocationsInput
  }

  export type LocationUncheckedCreateWithoutTransactionsInput = {
    id?: string
    merchantId: string
    posIntegrationId: string
    posLocationId: string
    name: string
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    country?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LocationCreateOrConnectWithoutTransactionsInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutTransactionsInput, LocationUncheckedCreateWithoutTransactionsInput>
  }

  export type LedgerEntryCreateWithoutTransactionInput = {
    id?: string
    type: $Enums.LedgerEntryType
    points: number
    createdAt?: Date | string
    customer: CustomerCreateNestedOneWithoutLedgerEntriesInput
    merchant: MerchantCreateNestedOneWithoutLedgerEntriesInput
    redemption?: RedemptionCreateNestedOneWithoutLedgerEntryInput
  }

  export type LedgerEntryUncheckedCreateWithoutTransactionInput = {
    id?: string
    customerId: string
    merchantId: string
    type: $Enums.LedgerEntryType
    points: number
    redemptionId?: string | null
    createdAt?: Date | string
  }

  export type LedgerEntryCreateOrConnectWithoutTransactionInput = {
    where: LedgerEntryWhereUniqueInput
    create: XOR<LedgerEntryCreateWithoutTransactionInput, LedgerEntryUncheckedCreateWithoutTransactionInput>
  }

  export type LedgerEntryCreateManyTransactionInputEnvelope = {
    data: LedgerEntryCreateManyTransactionInput | LedgerEntryCreateManyTransactionInput[]
    skipDuplicates?: boolean
  }

  export type MerchantUpsertWithoutTransactionsInput = {
    update: XOR<MerchantUpdateWithoutTransactionsInput, MerchantUncheckedUpdateWithoutTransactionsInput>
    create: XOR<MerchantCreateWithoutTransactionsInput, MerchantUncheckedCreateWithoutTransactionsInput>
    where?: MerchantWhereInput
  }

  export type MerchantUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: MerchantWhereInput
    data: XOR<MerchantUpdateWithoutTransactionsInput, MerchantUncheckedUpdateWithoutTransactionsInput>
  }

  export type MerchantUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posIntegrations?: POSIntegrationUpdateManyWithoutMerchantNestedInput
    locations?: LocationUpdateManyWithoutMerchantNestedInput
    rewards?: RewardUpdateManyWithoutMerchantNestedInput
    redemptions?: RedemptionUpdateManyWithoutMerchantNestedInput
    customerBalances?: CustomerBalanceUpdateManyWithoutMerchantNestedInput
    itemCounts?: CustomerItemCountUpdateManyWithoutMerchantNestedInput
    ledgerEntries?: LedgerEntryUpdateManyWithoutMerchantNestedInput
  }

  export type MerchantUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posIntegrations?: POSIntegrationUncheckedUpdateManyWithoutMerchantNestedInput
    locations?: LocationUncheckedUpdateManyWithoutMerchantNestedInput
    rewards?: RewardUncheckedUpdateManyWithoutMerchantNestedInput
    redemptions?: RedemptionUncheckedUpdateManyWithoutMerchantNestedInput
    customerBalances?: CustomerBalanceUncheckedUpdateManyWithoutMerchantNestedInput
    itemCounts?: CustomerItemCountUncheckedUpdateManyWithoutMerchantNestedInput
    ledgerEntries?: LedgerEntryUncheckedUpdateManyWithoutMerchantNestedInput
  }

  export type CustomerUpsertWithoutTransactionsInput = {
    update: XOR<CustomerUpdateWithoutTransactionsInput, CustomerUncheckedUpdateWithoutTransactionsInput>
    create: XOR<CustomerCreateWithoutTransactionsInput, CustomerUncheckedCreateWithoutTransactionsInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutTransactionsInput, CustomerUncheckedUpdateWithoutTransactionsInput>
  }

  export type CustomerUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    linkedCards?: LinkedCardUpdateManyWithoutCustomerNestedInput
    customerBalances?: CustomerBalanceUpdateManyWithoutCustomerNestedInput
    redemptions?: RedemptionUpdateManyWithoutCustomerNestedInput
    ledgerEntries?: LedgerEntryUpdateManyWithoutCustomerNestedInput
    itemCounts?: CustomerItemCountUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    linkedCards?: LinkedCardUncheckedUpdateManyWithoutCustomerNestedInput
    customerBalances?: CustomerBalanceUncheckedUpdateManyWithoutCustomerNestedInput
    redemptions?: RedemptionUncheckedUpdateManyWithoutCustomerNestedInput
    ledgerEntries?: LedgerEntryUncheckedUpdateManyWithoutCustomerNestedInput
    itemCounts?: CustomerItemCountUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type LocationUpsertWithoutTransactionsInput = {
    update: XOR<LocationUpdateWithoutTransactionsInput, LocationUncheckedUpdateWithoutTransactionsInput>
    create: XOR<LocationCreateWithoutTransactionsInput, LocationUncheckedCreateWithoutTransactionsInput>
    where?: LocationWhereInput
  }

  export type LocationUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: LocationWhereInput
    data: XOR<LocationUpdateWithoutTransactionsInput, LocationUncheckedUpdateWithoutTransactionsInput>
  }

  export type LocationUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    posLocationId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    merchant?: MerchantUpdateOneRequiredWithoutLocationsNestedInput
    posIntegration?: POSIntegrationUpdateOneRequiredWithoutLocationsNestedInput
  }

  export type LocationUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    merchantId?: StringFieldUpdateOperationsInput | string
    posIntegrationId?: StringFieldUpdateOperationsInput | string
    posLocationId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LedgerEntryUpsertWithWhereUniqueWithoutTransactionInput = {
    where: LedgerEntryWhereUniqueInput
    update: XOR<LedgerEntryUpdateWithoutTransactionInput, LedgerEntryUncheckedUpdateWithoutTransactionInput>
    create: XOR<LedgerEntryCreateWithoutTransactionInput, LedgerEntryUncheckedCreateWithoutTransactionInput>
  }

  export type LedgerEntryUpdateWithWhereUniqueWithoutTransactionInput = {
    where: LedgerEntryWhereUniqueInput
    data: XOR<LedgerEntryUpdateWithoutTransactionInput, LedgerEntryUncheckedUpdateWithoutTransactionInput>
  }

  export type LedgerEntryUpdateManyWithWhereWithoutTransactionInput = {
    where: LedgerEntryScalarWhereInput
    data: XOR<LedgerEntryUpdateManyMutationInput, LedgerEntryUncheckedUpdateManyWithoutTransactionInput>
  }

  export type CustomerCreateWithoutCustomerBalancesInput = {
    id?: string
    phoneNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    linkedCards?: LinkedCardCreateNestedManyWithoutCustomerInput
    transactions?: TransactionCreateNestedManyWithoutCustomerInput
    redemptions?: RedemptionCreateNestedManyWithoutCustomerInput
    ledgerEntries?: LedgerEntryCreateNestedManyWithoutCustomerInput
    itemCounts?: CustomerItemCountCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutCustomerBalancesInput = {
    id?: string
    phoneNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    linkedCards?: LinkedCardUncheckedCreateNestedManyWithoutCustomerInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCustomerInput
    redemptions?: RedemptionUncheckedCreateNestedManyWithoutCustomerInput
    ledgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutCustomerInput
    itemCounts?: CustomerItemCountUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutCustomerBalancesInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutCustomerBalancesInput, CustomerUncheckedCreateWithoutCustomerBalancesInput>
  }

  export type MerchantCreateWithoutCustomerBalancesInput = {
    id?: string
    email: string
    password: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    posIntegrations?: POSIntegrationCreateNestedManyWithoutMerchantInput
    locations?: LocationCreateNestedManyWithoutMerchantInput
    rewards?: RewardCreateNestedManyWithoutMerchantInput
    transactions?: TransactionCreateNestedManyWithoutMerchantInput
    redemptions?: RedemptionCreateNestedManyWithoutMerchantInput
    itemCounts?: CustomerItemCountCreateNestedManyWithoutMerchantInput
    ledgerEntries?: LedgerEntryCreateNestedManyWithoutMerchantInput
  }

  export type MerchantUncheckedCreateWithoutCustomerBalancesInput = {
    id?: string
    email: string
    password: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    posIntegrations?: POSIntegrationUncheckedCreateNestedManyWithoutMerchantInput
    locations?: LocationUncheckedCreateNestedManyWithoutMerchantInput
    rewards?: RewardUncheckedCreateNestedManyWithoutMerchantInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutMerchantInput
    redemptions?: RedemptionUncheckedCreateNestedManyWithoutMerchantInput
    itemCounts?: CustomerItemCountUncheckedCreateNestedManyWithoutMerchantInput
    ledgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutMerchantInput
  }

  export type MerchantCreateOrConnectWithoutCustomerBalancesInput = {
    where: MerchantWhereUniqueInput
    create: XOR<MerchantCreateWithoutCustomerBalancesInput, MerchantUncheckedCreateWithoutCustomerBalancesInput>
  }

  export type CustomerUpsertWithoutCustomerBalancesInput = {
    update: XOR<CustomerUpdateWithoutCustomerBalancesInput, CustomerUncheckedUpdateWithoutCustomerBalancesInput>
    create: XOR<CustomerCreateWithoutCustomerBalancesInput, CustomerUncheckedCreateWithoutCustomerBalancesInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutCustomerBalancesInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutCustomerBalancesInput, CustomerUncheckedUpdateWithoutCustomerBalancesInput>
  }

  export type CustomerUpdateWithoutCustomerBalancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    linkedCards?: LinkedCardUpdateManyWithoutCustomerNestedInput
    transactions?: TransactionUpdateManyWithoutCustomerNestedInput
    redemptions?: RedemptionUpdateManyWithoutCustomerNestedInput
    ledgerEntries?: LedgerEntryUpdateManyWithoutCustomerNestedInput
    itemCounts?: CustomerItemCountUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutCustomerBalancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    linkedCards?: LinkedCardUncheckedUpdateManyWithoutCustomerNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCustomerNestedInput
    redemptions?: RedemptionUncheckedUpdateManyWithoutCustomerNestedInput
    ledgerEntries?: LedgerEntryUncheckedUpdateManyWithoutCustomerNestedInput
    itemCounts?: CustomerItemCountUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type MerchantUpsertWithoutCustomerBalancesInput = {
    update: XOR<MerchantUpdateWithoutCustomerBalancesInput, MerchantUncheckedUpdateWithoutCustomerBalancesInput>
    create: XOR<MerchantCreateWithoutCustomerBalancesInput, MerchantUncheckedCreateWithoutCustomerBalancesInput>
    where?: MerchantWhereInput
  }

  export type MerchantUpdateToOneWithWhereWithoutCustomerBalancesInput = {
    where?: MerchantWhereInput
    data: XOR<MerchantUpdateWithoutCustomerBalancesInput, MerchantUncheckedUpdateWithoutCustomerBalancesInput>
  }

  export type MerchantUpdateWithoutCustomerBalancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posIntegrations?: POSIntegrationUpdateManyWithoutMerchantNestedInput
    locations?: LocationUpdateManyWithoutMerchantNestedInput
    rewards?: RewardUpdateManyWithoutMerchantNestedInput
    transactions?: TransactionUpdateManyWithoutMerchantNestedInput
    redemptions?: RedemptionUpdateManyWithoutMerchantNestedInput
    itemCounts?: CustomerItemCountUpdateManyWithoutMerchantNestedInput
    ledgerEntries?: LedgerEntryUpdateManyWithoutMerchantNestedInput
  }

  export type MerchantUncheckedUpdateWithoutCustomerBalancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posIntegrations?: POSIntegrationUncheckedUpdateManyWithoutMerchantNestedInput
    locations?: LocationUncheckedUpdateManyWithoutMerchantNestedInput
    rewards?: RewardUncheckedUpdateManyWithoutMerchantNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutMerchantNestedInput
    redemptions?: RedemptionUncheckedUpdateManyWithoutMerchantNestedInput
    itemCounts?: CustomerItemCountUncheckedUpdateManyWithoutMerchantNestedInput
    ledgerEntries?: LedgerEntryUncheckedUpdateManyWithoutMerchantNestedInput
  }

  export type MerchantCreateWithoutRewardsInput = {
    id?: string
    email: string
    password: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    posIntegrations?: POSIntegrationCreateNestedManyWithoutMerchantInput
    locations?: LocationCreateNestedManyWithoutMerchantInput
    transactions?: TransactionCreateNestedManyWithoutMerchantInput
    redemptions?: RedemptionCreateNestedManyWithoutMerchantInput
    customerBalances?: CustomerBalanceCreateNestedManyWithoutMerchantInput
    itemCounts?: CustomerItemCountCreateNestedManyWithoutMerchantInput
    ledgerEntries?: LedgerEntryCreateNestedManyWithoutMerchantInput
  }

  export type MerchantUncheckedCreateWithoutRewardsInput = {
    id?: string
    email: string
    password: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    posIntegrations?: POSIntegrationUncheckedCreateNestedManyWithoutMerchantInput
    locations?: LocationUncheckedCreateNestedManyWithoutMerchantInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutMerchantInput
    redemptions?: RedemptionUncheckedCreateNestedManyWithoutMerchantInput
    customerBalances?: CustomerBalanceUncheckedCreateNestedManyWithoutMerchantInput
    itemCounts?: CustomerItemCountUncheckedCreateNestedManyWithoutMerchantInput
    ledgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutMerchantInput
  }

  export type MerchantCreateOrConnectWithoutRewardsInput = {
    where: MerchantWhereUniqueInput
    create: XOR<MerchantCreateWithoutRewardsInput, MerchantUncheckedCreateWithoutRewardsInput>
  }

  export type POSRewardItemCreateWithoutRewardInput = {
    id?: string
    posProvider: $Enums.POSProvider
    posItemId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type POSRewardItemUncheckedCreateWithoutRewardInput = {
    id?: string
    posProvider: $Enums.POSProvider
    posItemId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type POSRewardItemCreateOrConnectWithoutRewardInput = {
    where: POSRewardItemWhereUniqueInput
    create: XOR<POSRewardItemCreateWithoutRewardInput, POSRewardItemUncheckedCreateWithoutRewardInput>
  }

  export type POSRewardItemCreateManyRewardInputEnvelope = {
    data: POSRewardItemCreateManyRewardInput | POSRewardItemCreateManyRewardInput[]
    skipDuplicates?: boolean
  }

  export type RedemptionCreateWithoutRewardInput = {
    id?: string
    qrToken: string
    pinCode: string
    status?: $Enums.RedemptionStatus
    pointsDeducted?: number | null
    redeemedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutRedemptionsInput
    merchant: MerchantCreateNestedOneWithoutRedemptionsInput
    ledgerEntry?: LedgerEntryCreateNestedOneWithoutRedemptionInput
  }

  export type RedemptionUncheckedCreateWithoutRewardInput = {
    id?: string
    customerId: string
    merchantId: string
    qrToken: string
    pinCode: string
    status?: $Enums.RedemptionStatus
    pointsDeducted?: number | null
    redeemedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ledgerEntry?: LedgerEntryUncheckedCreateNestedOneWithoutRedemptionInput
  }

  export type RedemptionCreateOrConnectWithoutRewardInput = {
    where: RedemptionWhereUniqueInput
    create: XOR<RedemptionCreateWithoutRewardInput, RedemptionUncheckedCreateWithoutRewardInput>
  }

  export type RedemptionCreateManyRewardInputEnvelope = {
    data: RedemptionCreateManyRewardInput | RedemptionCreateManyRewardInput[]
    skipDuplicates?: boolean
  }

  export type CustomerItemCountCreateWithoutRewardInput = {
    id?: string
    itemName: string
    count?: number
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutItemCountsInput
    merchant: MerchantCreateNestedOneWithoutItemCountsInput
  }

  export type CustomerItemCountUncheckedCreateWithoutRewardInput = {
    id?: string
    customerId: string
    merchantId: string
    itemName: string
    count?: number
    updatedAt?: Date | string
  }

  export type CustomerItemCountCreateOrConnectWithoutRewardInput = {
    where: CustomerItemCountWhereUniqueInput
    create: XOR<CustomerItemCountCreateWithoutRewardInput, CustomerItemCountUncheckedCreateWithoutRewardInput>
  }

  export type CustomerItemCountCreateManyRewardInputEnvelope = {
    data: CustomerItemCountCreateManyRewardInput | CustomerItemCountCreateManyRewardInput[]
    skipDuplicates?: boolean
  }

  export type MerchantUpsertWithoutRewardsInput = {
    update: XOR<MerchantUpdateWithoutRewardsInput, MerchantUncheckedUpdateWithoutRewardsInput>
    create: XOR<MerchantCreateWithoutRewardsInput, MerchantUncheckedCreateWithoutRewardsInput>
    where?: MerchantWhereInput
  }

  export type MerchantUpdateToOneWithWhereWithoutRewardsInput = {
    where?: MerchantWhereInput
    data: XOR<MerchantUpdateWithoutRewardsInput, MerchantUncheckedUpdateWithoutRewardsInput>
  }

  export type MerchantUpdateWithoutRewardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posIntegrations?: POSIntegrationUpdateManyWithoutMerchantNestedInput
    locations?: LocationUpdateManyWithoutMerchantNestedInput
    transactions?: TransactionUpdateManyWithoutMerchantNestedInput
    redemptions?: RedemptionUpdateManyWithoutMerchantNestedInput
    customerBalances?: CustomerBalanceUpdateManyWithoutMerchantNestedInput
    itemCounts?: CustomerItemCountUpdateManyWithoutMerchantNestedInput
    ledgerEntries?: LedgerEntryUpdateManyWithoutMerchantNestedInput
  }

  export type MerchantUncheckedUpdateWithoutRewardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posIntegrations?: POSIntegrationUncheckedUpdateManyWithoutMerchantNestedInput
    locations?: LocationUncheckedUpdateManyWithoutMerchantNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutMerchantNestedInput
    redemptions?: RedemptionUncheckedUpdateManyWithoutMerchantNestedInput
    customerBalances?: CustomerBalanceUncheckedUpdateManyWithoutMerchantNestedInput
    itemCounts?: CustomerItemCountUncheckedUpdateManyWithoutMerchantNestedInput
    ledgerEntries?: LedgerEntryUncheckedUpdateManyWithoutMerchantNestedInput
  }

  export type POSRewardItemUpsertWithWhereUniqueWithoutRewardInput = {
    where: POSRewardItemWhereUniqueInput
    update: XOR<POSRewardItemUpdateWithoutRewardInput, POSRewardItemUncheckedUpdateWithoutRewardInput>
    create: XOR<POSRewardItemCreateWithoutRewardInput, POSRewardItemUncheckedCreateWithoutRewardInput>
  }

  export type POSRewardItemUpdateWithWhereUniqueWithoutRewardInput = {
    where: POSRewardItemWhereUniqueInput
    data: XOR<POSRewardItemUpdateWithoutRewardInput, POSRewardItemUncheckedUpdateWithoutRewardInput>
  }

  export type POSRewardItemUpdateManyWithWhereWithoutRewardInput = {
    where: POSRewardItemScalarWhereInput
    data: XOR<POSRewardItemUpdateManyMutationInput, POSRewardItemUncheckedUpdateManyWithoutRewardInput>
  }

  export type POSRewardItemScalarWhereInput = {
    AND?: POSRewardItemScalarWhereInput | POSRewardItemScalarWhereInput[]
    OR?: POSRewardItemScalarWhereInput[]
    NOT?: POSRewardItemScalarWhereInput | POSRewardItemScalarWhereInput[]
    id?: StringFilter<"POSRewardItem"> | string
    rewardId?: StringFilter<"POSRewardItem"> | string
    posProvider?: EnumPOSProviderFilter<"POSRewardItem"> | $Enums.POSProvider
    posItemId?: StringFilter<"POSRewardItem"> | string
    createdAt?: DateTimeFilter<"POSRewardItem"> | Date | string
    updatedAt?: DateTimeFilter<"POSRewardItem"> | Date | string
  }

  export type RedemptionUpsertWithWhereUniqueWithoutRewardInput = {
    where: RedemptionWhereUniqueInput
    update: XOR<RedemptionUpdateWithoutRewardInput, RedemptionUncheckedUpdateWithoutRewardInput>
    create: XOR<RedemptionCreateWithoutRewardInput, RedemptionUncheckedCreateWithoutRewardInput>
  }

  export type RedemptionUpdateWithWhereUniqueWithoutRewardInput = {
    where: RedemptionWhereUniqueInput
    data: XOR<RedemptionUpdateWithoutRewardInput, RedemptionUncheckedUpdateWithoutRewardInput>
  }

  export type RedemptionUpdateManyWithWhereWithoutRewardInput = {
    where: RedemptionScalarWhereInput
    data: XOR<RedemptionUpdateManyMutationInput, RedemptionUncheckedUpdateManyWithoutRewardInput>
  }

  export type CustomerItemCountUpsertWithWhereUniqueWithoutRewardInput = {
    where: CustomerItemCountWhereUniqueInput
    update: XOR<CustomerItemCountUpdateWithoutRewardInput, CustomerItemCountUncheckedUpdateWithoutRewardInput>
    create: XOR<CustomerItemCountCreateWithoutRewardInput, CustomerItemCountUncheckedCreateWithoutRewardInput>
  }

  export type CustomerItemCountUpdateWithWhereUniqueWithoutRewardInput = {
    where: CustomerItemCountWhereUniqueInput
    data: XOR<CustomerItemCountUpdateWithoutRewardInput, CustomerItemCountUncheckedUpdateWithoutRewardInput>
  }

  export type CustomerItemCountUpdateManyWithWhereWithoutRewardInput = {
    where: CustomerItemCountScalarWhereInput
    data: XOR<CustomerItemCountUpdateManyMutationInput, CustomerItemCountUncheckedUpdateManyWithoutRewardInput>
  }

  export type RewardCreateWithoutPosRewardItemsInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.RewardType
    pointsCost?: number | null
    itemName?: string | null
    itemCount?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    merchant: MerchantCreateNestedOneWithoutRewardsInput
    redemptions?: RedemptionCreateNestedManyWithoutRewardInput
    itemCounts?: CustomerItemCountCreateNestedManyWithoutRewardInput
  }

  export type RewardUncheckedCreateWithoutPosRewardItemsInput = {
    id?: string
    merchantId: string
    name: string
    description?: string | null
    type: $Enums.RewardType
    pointsCost?: number | null
    itemName?: string | null
    itemCount?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    redemptions?: RedemptionUncheckedCreateNestedManyWithoutRewardInput
    itemCounts?: CustomerItemCountUncheckedCreateNestedManyWithoutRewardInput
  }

  export type RewardCreateOrConnectWithoutPosRewardItemsInput = {
    where: RewardWhereUniqueInput
    create: XOR<RewardCreateWithoutPosRewardItemsInput, RewardUncheckedCreateWithoutPosRewardItemsInput>
  }

  export type RewardUpsertWithoutPosRewardItemsInput = {
    update: XOR<RewardUpdateWithoutPosRewardItemsInput, RewardUncheckedUpdateWithoutPosRewardItemsInput>
    create: XOR<RewardCreateWithoutPosRewardItemsInput, RewardUncheckedCreateWithoutPosRewardItemsInput>
    where?: RewardWhereInput
  }

  export type RewardUpdateToOneWithWhereWithoutPosRewardItemsInput = {
    where?: RewardWhereInput
    data: XOR<RewardUpdateWithoutPosRewardItemsInput, RewardUncheckedUpdateWithoutPosRewardItemsInput>
  }

  export type RewardUpdateWithoutPosRewardItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumRewardTypeFieldUpdateOperationsInput | $Enums.RewardType
    pointsCost?: NullableIntFieldUpdateOperationsInput | number | null
    itemName?: NullableStringFieldUpdateOperationsInput | string | null
    itemCount?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    merchant?: MerchantUpdateOneRequiredWithoutRewardsNestedInput
    redemptions?: RedemptionUpdateManyWithoutRewardNestedInput
    itemCounts?: CustomerItemCountUpdateManyWithoutRewardNestedInput
  }

  export type RewardUncheckedUpdateWithoutPosRewardItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    merchantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumRewardTypeFieldUpdateOperationsInput | $Enums.RewardType
    pointsCost?: NullableIntFieldUpdateOperationsInput | number | null
    itemName?: NullableStringFieldUpdateOperationsInput | string | null
    itemCount?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    redemptions?: RedemptionUncheckedUpdateManyWithoutRewardNestedInput
    itemCounts?: CustomerItemCountUncheckedUpdateManyWithoutRewardNestedInput
  }

  export type CustomerCreateWithoutRedemptionsInput = {
    id?: string
    phoneNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    linkedCards?: LinkedCardCreateNestedManyWithoutCustomerInput
    transactions?: TransactionCreateNestedManyWithoutCustomerInput
    customerBalances?: CustomerBalanceCreateNestedManyWithoutCustomerInput
    ledgerEntries?: LedgerEntryCreateNestedManyWithoutCustomerInput
    itemCounts?: CustomerItemCountCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutRedemptionsInput = {
    id?: string
    phoneNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    linkedCards?: LinkedCardUncheckedCreateNestedManyWithoutCustomerInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCustomerInput
    customerBalances?: CustomerBalanceUncheckedCreateNestedManyWithoutCustomerInput
    ledgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutCustomerInput
    itemCounts?: CustomerItemCountUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutRedemptionsInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutRedemptionsInput, CustomerUncheckedCreateWithoutRedemptionsInput>
  }

  export type MerchantCreateWithoutRedemptionsInput = {
    id?: string
    email: string
    password: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    posIntegrations?: POSIntegrationCreateNestedManyWithoutMerchantInput
    locations?: LocationCreateNestedManyWithoutMerchantInput
    rewards?: RewardCreateNestedManyWithoutMerchantInput
    transactions?: TransactionCreateNestedManyWithoutMerchantInput
    customerBalances?: CustomerBalanceCreateNestedManyWithoutMerchantInput
    itemCounts?: CustomerItemCountCreateNestedManyWithoutMerchantInput
    ledgerEntries?: LedgerEntryCreateNestedManyWithoutMerchantInput
  }

  export type MerchantUncheckedCreateWithoutRedemptionsInput = {
    id?: string
    email: string
    password: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    posIntegrations?: POSIntegrationUncheckedCreateNestedManyWithoutMerchantInput
    locations?: LocationUncheckedCreateNestedManyWithoutMerchantInput
    rewards?: RewardUncheckedCreateNestedManyWithoutMerchantInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutMerchantInput
    customerBalances?: CustomerBalanceUncheckedCreateNestedManyWithoutMerchantInput
    itemCounts?: CustomerItemCountUncheckedCreateNestedManyWithoutMerchantInput
    ledgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutMerchantInput
  }

  export type MerchantCreateOrConnectWithoutRedemptionsInput = {
    where: MerchantWhereUniqueInput
    create: XOR<MerchantCreateWithoutRedemptionsInput, MerchantUncheckedCreateWithoutRedemptionsInput>
  }

  export type RewardCreateWithoutRedemptionsInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.RewardType
    pointsCost?: number | null
    itemName?: string | null
    itemCount?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    merchant: MerchantCreateNestedOneWithoutRewardsInput
    posRewardItems?: POSRewardItemCreateNestedManyWithoutRewardInput
    itemCounts?: CustomerItemCountCreateNestedManyWithoutRewardInput
  }

  export type RewardUncheckedCreateWithoutRedemptionsInput = {
    id?: string
    merchantId: string
    name: string
    description?: string | null
    type: $Enums.RewardType
    pointsCost?: number | null
    itemName?: string | null
    itemCount?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    posRewardItems?: POSRewardItemUncheckedCreateNestedManyWithoutRewardInput
    itemCounts?: CustomerItemCountUncheckedCreateNestedManyWithoutRewardInput
  }

  export type RewardCreateOrConnectWithoutRedemptionsInput = {
    where: RewardWhereUniqueInput
    create: XOR<RewardCreateWithoutRedemptionsInput, RewardUncheckedCreateWithoutRedemptionsInput>
  }

  export type LedgerEntryCreateWithoutRedemptionInput = {
    id?: string
    type: $Enums.LedgerEntryType
    points: number
    createdAt?: Date | string
    customer: CustomerCreateNestedOneWithoutLedgerEntriesInput
    merchant: MerchantCreateNestedOneWithoutLedgerEntriesInput
    transaction?: TransactionCreateNestedOneWithoutLedgerEntriesInput
  }

  export type LedgerEntryUncheckedCreateWithoutRedemptionInput = {
    id?: string
    customerId: string
    merchantId: string
    type: $Enums.LedgerEntryType
    points: number
    transactionId?: string | null
    createdAt?: Date | string
  }

  export type LedgerEntryCreateOrConnectWithoutRedemptionInput = {
    where: LedgerEntryWhereUniqueInput
    create: XOR<LedgerEntryCreateWithoutRedemptionInput, LedgerEntryUncheckedCreateWithoutRedemptionInput>
  }

  export type CustomerUpsertWithoutRedemptionsInput = {
    update: XOR<CustomerUpdateWithoutRedemptionsInput, CustomerUncheckedUpdateWithoutRedemptionsInput>
    create: XOR<CustomerCreateWithoutRedemptionsInput, CustomerUncheckedCreateWithoutRedemptionsInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutRedemptionsInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutRedemptionsInput, CustomerUncheckedUpdateWithoutRedemptionsInput>
  }

  export type CustomerUpdateWithoutRedemptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    linkedCards?: LinkedCardUpdateManyWithoutCustomerNestedInput
    transactions?: TransactionUpdateManyWithoutCustomerNestedInput
    customerBalances?: CustomerBalanceUpdateManyWithoutCustomerNestedInput
    ledgerEntries?: LedgerEntryUpdateManyWithoutCustomerNestedInput
    itemCounts?: CustomerItemCountUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutRedemptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    linkedCards?: LinkedCardUncheckedUpdateManyWithoutCustomerNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCustomerNestedInput
    customerBalances?: CustomerBalanceUncheckedUpdateManyWithoutCustomerNestedInput
    ledgerEntries?: LedgerEntryUncheckedUpdateManyWithoutCustomerNestedInput
    itemCounts?: CustomerItemCountUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type MerchantUpsertWithoutRedemptionsInput = {
    update: XOR<MerchantUpdateWithoutRedemptionsInput, MerchantUncheckedUpdateWithoutRedemptionsInput>
    create: XOR<MerchantCreateWithoutRedemptionsInput, MerchantUncheckedCreateWithoutRedemptionsInput>
    where?: MerchantWhereInput
  }

  export type MerchantUpdateToOneWithWhereWithoutRedemptionsInput = {
    where?: MerchantWhereInput
    data: XOR<MerchantUpdateWithoutRedemptionsInput, MerchantUncheckedUpdateWithoutRedemptionsInput>
  }

  export type MerchantUpdateWithoutRedemptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posIntegrations?: POSIntegrationUpdateManyWithoutMerchantNestedInput
    locations?: LocationUpdateManyWithoutMerchantNestedInput
    rewards?: RewardUpdateManyWithoutMerchantNestedInput
    transactions?: TransactionUpdateManyWithoutMerchantNestedInput
    customerBalances?: CustomerBalanceUpdateManyWithoutMerchantNestedInput
    itemCounts?: CustomerItemCountUpdateManyWithoutMerchantNestedInput
    ledgerEntries?: LedgerEntryUpdateManyWithoutMerchantNestedInput
  }

  export type MerchantUncheckedUpdateWithoutRedemptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posIntegrations?: POSIntegrationUncheckedUpdateManyWithoutMerchantNestedInput
    locations?: LocationUncheckedUpdateManyWithoutMerchantNestedInput
    rewards?: RewardUncheckedUpdateManyWithoutMerchantNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutMerchantNestedInput
    customerBalances?: CustomerBalanceUncheckedUpdateManyWithoutMerchantNestedInput
    itemCounts?: CustomerItemCountUncheckedUpdateManyWithoutMerchantNestedInput
    ledgerEntries?: LedgerEntryUncheckedUpdateManyWithoutMerchantNestedInput
  }

  export type RewardUpsertWithoutRedemptionsInput = {
    update: XOR<RewardUpdateWithoutRedemptionsInput, RewardUncheckedUpdateWithoutRedemptionsInput>
    create: XOR<RewardCreateWithoutRedemptionsInput, RewardUncheckedCreateWithoutRedemptionsInput>
    where?: RewardWhereInput
  }

  export type RewardUpdateToOneWithWhereWithoutRedemptionsInput = {
    where?: RewardWhereInput
    data: XOR<RewardUpdateWithoutRedemptionsInput, RewardUncheckedUpdateWithoutRedemptionsInput>
  }

  export type RewardUpdateWithoutRedemptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumRewardTypeFieldUpdateOperationsInput | $Enums.RewardType
    pointsCost?: NullableIntFieldUpdateOperationsInput | number | null
    itemName?: NullableStringFieldUpdateOperationsInput | string | null
    itemCount?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    merchant?: MerchantUpdateOneRequiredWithoutRewardsNestedInput
    posRewardItems?: POSRewardItemUpdateManyWithoutRewardNestedInput
    itemCounts?: CustomerItemCountUpdateManyWithoutRewardNestedInput
  }

  export type RewardUncheckedUpdateWithoutRedemptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    merchantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumRewardTypeFieldUpdateOperationsInput | $Enums.RewardType
    pointsCost?: NullableIntFieldUpdateOperationsInput | number | null
    itemName?: NullableStringFieldUpdateOperationsInput | string | null
    itemCount?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posRewardItems?: POSRewardItemUncheckedUpdateManyWithoutRewardNestedInput
    itemCounts?: CustomerItemCountUncheckedUpdateManyWithoutRewardNestedInput
  }

  export type LedgerEntryUpsertWithoutRedemptionInput = {
    update: XOR<LedgerEntryUpdateWithoutRedemptionInput, LedgerEntryUncheckedUpdateWithoutRedemptionInput>
    create: XOR<LedgerEntryCreateWithoutRedemptionInput, LedgerEntryUncheckedCreateWithoutRedemptionInput>
    where?: LedgerEntryWhereInput
  }

  export type LedgerEntryUpdateToOneWithWhereWithoutRedemptionInput = {
    where?: LedgerEntryWhereInput
    data: XOR<LedgerEntryUpdateWithoutRedemptionInput, LedgerEntryUncheckedUpdateWithoutRedemptionInput>
  }

  export type LedgerEntryUpdateWithoutRedemptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumLedgerEntryTypeFieldUpdateOperationsInput | $Enums.LedgerEntryType
    points?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutLedgerEntriesNestedInput
    merchant?: MerchantUpdateOneRequiredWithoutLedgerEntriesNestedInput
    transaction?: TransactionUpdateOneWithoutLedgerEntriesNestedInput
  }

  export type LedgerEntryUncheckedUpdateWithoutRedemptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    merchantId?: StringFieldUpdateOperationsInput | string
    type?: EnumLedgerEntryTypeFieldUpdateOperationsInput | $Enums.LedgerEntryType
    points?: IntFieldUpdateOperationsInput | number
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerCreateWithoutItemCountsInput = {
    id?: string
    phoneNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    linkedCards?: LinkedCardCreateNestedManyWithoutCustomerInput
    transactions?: TransactionCreateNestedManyWithoutCustomerInput
    customerBalances?: CustomerBalanceCreateNestedManyWithoutCustomerInput
    redemptions?: RedemptionCreateNestedManyWithoutCustomerInput
    ledgerEntries?: LedgerEntryCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutItemCountsInput = {
    id?: string
    phoneNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    linkedCards?: LinkedCardUncheckedCreateNestedManyWithoutCustomerInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCustomerInput
    customerBalances?: CustomerBalanceUncheckedCreateNestedManyWithoutCustomerInput
    redemptions?: RedemptionUncheckedCreateNestedManyWithoutCustomerInput
    ledgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutItemCountsInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutItemCountsInput, CustomerUncheckedCreateWithoutItemCountsInput>
  }

  export type MerchantCreateWithoutItemCountsInput = {
    id?: string
    email: string
    password: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    posIntegrations?: POSIntegrationCreateNestedManyWithoutMerchantInput
    locations?: LocationCreateNestedManyWithoutMerchantInput
    rewards?: RewardCreateNestedManyWithoutMerchantInput
    transactions?: TransactionCreateNestedManyWithoutMerchantInput
    redemptions?: RedemptionCreateNestedManyWithoutMerchantInput
    customerBalances?: CustomerBalanceCreateNestedManyWithoutMerchantInput
    ledgerEntries?: LedgerEntryCreateNestedManyWithoutMerchantInput
  }

  export type MerchantUncheckedCreateWithoutItemCountsInput = {
    id?: string
    email: string
    password: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    posIntegrations?: POSIntegrationUncheckedCreateNestedManyWithoutMerchantInput
    locations?: LocationUncheckedCreateNestedManyWithoutMerchantInput
    rewards?: RewardUncheckedCreateNestedManyWithoutMerchantInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutMerchantInput
    redemptions?: RedemptionUncheckedCreateNestedManyWithoutMerchantInput
    customerBalances?: CustomerBalanceUncheckedCreateNestedManyWithoutMerchantInput
    ledgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutMerchantInput
  }

  export type MerchantCreateOrConnectWithoutItemCountsInput = {
    where: MerchantWhereUniqueInput
    create: XOR<MerchantCreateWithoutItemCountsInput, MerchantUncheckedCreateWithoutItemCountsInput>
  }

  export type RewardCreateWithoutItemCountsInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.RewardType
    pointsCost?: number | null
    itemName?: string | null
    itemCount?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    merchant: MerchantCreateNestedOneWithoutRewardsInput
    posRewardItems?: POSRewardItemCreateNestedManyWithoutRewardInput
    redemptions?: RedemptionCreateNestedManyWithoutRewardInput
  }

  export type RewardUncheckedCreateWithoutItemCountsInput = {
    id?: string
    merchantId: string
    name: string
    description?: string | null
    type: $Enums.RewardType
    pointsCost?: number | null
    itemName?: string | null
    itemCount?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    posRewardItems?: POSRewardItemUncheckedCreateNestedManyWithoutRewardInput
    redemptions?: RedemptionUncheckedCreateNestedManyWithoutRewardInput
  }

  export type RewardCreateOrConnectWithoutItemCountsInput = {
    where: RewardWhereUniqueInput
    create: XOR<RewardCreateWithoutItemCountsInput, RewardUncheckedCreateWithoutItemCountsInput>
  }

  export type CustomerUpsertWithoutItemCountsInput = {
    update: XOR<CustomerUpdateWithoutItemCountsInput, CustomerUncheckedUpdateWithoutItemCountsInput>
    create: XOR<CustomerCreateWithoutItemCountsInput, CustomerUncheckedCreateWithoutItemCountsInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutItemCountsInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutItemCountsInput, CustomerUncheckedUpdateWithoutItemCountsInput>
  }

  export type CustomerUpdateWithoutItemCountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    linkedCards?: LinkedCardUpdateManyWithoutCustomerNestedInput
    transactions?: TransactionUpdateManyWithoutCustomerNestedInput
    customerBalances?: CustomerBalanceUpdateManyWithoutCustomerNestedInput
    redemptions?: RedemptionUpdateManyWithoutCustomerNestedInput
    ledgerEntries?: LedgerEntryUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutItemCountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    linkedCards?: LinkedCardUncheckedUpdateManyWithoutCustomerNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCustomerNestedInput
    customerBalances?: CustomerBalanceUncheckedUpdateManyWithoutCustomerNestedInput
    redemptions?: RedemptionUncheckedUpdateManyWithoutCustomerNestedInput
    ledgerEntries?: LedgerEntryUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type MerchantUpsertWithoutItemCountsInput = {
    update: XOR<MerchantUpdateWithoutItemCountsInput, MerchantUncheckedUpdateWithoutItemCountsInput>
    create: XOR<MerchantCreateWithoutItemCountsInput, MerchantUncheckedCreateWithoutItemCountsInput>
    where?: MerchantWhereInput
  }

  export type MerchantUpdateToOneWithWhereWithoutItemCountsInput = {
    where?: MerchantWhereInput
    data: XOR<MerchantUpdateWithoutItemCountsInput, MerchantUncheckedUpdateWithoutItemCountsInput>
  }

  export type MerchantUpdateWithoutItemCountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posIntegrations?: POSIntegrationUpdateManyWithoutMerchantNestedInput
    locations?: LocationUpdateManyWithoutMerchantNestedInput
    rewards?: RewardUpdateManyWithoutMerchantNestedInput
    transactions?: TransactionUpdateManyWithoutMerchantNestedInput
    redemptions?: RedemptionUpdateManyWithoutMerchantNestedInput
    customerBalances?: CustomerBalanceUpdateManyWithoutMerchantNestedInput
    ledgerEntries?: LedgerEntryUpdateManyWithoutMerchantNestedInput
  }

  export type MerchantUncheckedUpdateWithoutItemCountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posIntegrations?: POSIntegrationUncheckedUpdateManyWithoutMerchantNestedInput
    locations?: LocationUncheckedUpdateManyWithoutMerchantNestedInput
    rewards?: RewardUncheckedUpdateManyWithoutMerchantNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutMerchantNestedInput
    redemptions?: RedemptionUncheckedUpdateManyWithoutMerchantNestedInput
    customerBalances?: CustomerBalanceUncheckedUpdateManyWithoutMerchantNestedInput
    ledgerEntries?: LedgerEntryUncheckedUpdateManyWithoutMerchantNestedInput
  }

  export type RewardUpsertWithoutItemCountsInput = {
    update: XOR<RewardUpdateWithoutItemCountsInput, RewardUncheckedUpdateWithoutItemCountsInput>
    create: XOR<RewardCreateWithoutItemCountsInput, RewardUncheckedCreateWithoutItemCountsInput>
    where?: RewardWhereInput
  }

  export type RewardUpdateToOneWithWhereWithoutItemCountsInput = {
    where?: RewardWhereInput
    data: XOR<RewardUpdateWithoutItemCountsInput, RewardUncheckedUpdateWithoutItemCountsInput>
  }

  export type RewardUpdateWithoutItemCountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumRewardTypeFieldUpdateOperationsInput | $Enums.RewardType
    pointsCost?: NullableIntFieldUpdateOperationsInput | number | null
    itemName?: NullableStringFieldUpdateOperationsInput | string | null
    itemCount?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    merchant?: MerchantUpdateOneRequiredWithoutRewardsNestedInput
    posRewardItems?: POSRewardItemUpdateManyWithoutRewardNestedInput
    redemptions?: RedemptionUpdateManyWithoutRewardNestedInput
  }

  export type RewardUncheckedUpdateWithoutItemCountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    merchantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumRewardTypeFieldUpdateOperationsInput | $Enums.RewardType
    pointsCost?: NullableIntFieldUpdateOperationsInput | number | null
    itemName?: NullableStringFieldUpdateOperationsInput | string | null
    itemCount?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posRewardItems?: POSRewardItemUncheckedUpdateManyWithoutRewardNestedInput
    redemptions?: RedemptionUncheckedUpdateManyWithoutRewardNestedInput
  }

  export type CustomerCreateWithoutLedgerEntriesInput = {
    id?: string
    phoneNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    linkedCards?: LinkedCardCreateNestedManyWithoutCustomerInput
    transactions?: TransactionCreateNestedManyWithoutCustomerInput
    customerBalances?: CustomerBalanceCreateNestedManyWithoutCustomerInput
    redemptions?: RedemptionCreateNestedManyWithoutCustomerInput
    itemCounts?: CustomerItemCountCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutLedgerEntriesInput = {
    id?: string
    phoneNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    linkedCards?: LinkedCardUncheckedCreateNestedManyWithoutCustomerInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCustomerInput
    customerBalances?: CustomerBalanceUncheckedCreateNestedManyWithoutCustomerInput
    redemptions?: RedemptionUncheckedCreateNestedManyWithoutCustomerInput
    itemCounts?: CustomerItemCountUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutLedgerEntriesInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutLedgerEntriesInput, CustomerUncheckedCreateWithoutLedgerEntriesInput>
  }

  export type MerchantCreateWithoutLedgerEntriesInput = {
    id?: string
    email: string
    password: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    posIntegrations?: POSIntegrationCreateNestedManyWithoutMerchantInput
    locations?: LocationCreateNestedManyWithoutMerchantInput
    rewards?: RewardCreateNestedManyWithoutMerchantInput
    transactions?: TransactionCreateNestedManyWithoutMerchantInput
    redemptions?: RedemptionCreateNestedManyWithoutMerchantInput
    customerBalances?: CustomerBalanceCreateNestedManyWithoutMerchantInput
    itemCounts?: CustomerItemCountCreateNestedManyWithoutMerchantInput
  }

  export type MerchantUncheckedCreateWithoutLedgerEntriesInput = {
    id?: string
    email: string
    password: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    posIntegrations?: POSIntegrationUncheckedCreateNestedManyWithoutMerchantInput
    locations?: LocationUncheckedCreateNestedManyWithoutMerchantInput
    rewards?: RewardUncheckedCreateNestedManyWithoutMerchantInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutMerchantInput
    redemptions?: RedemptionUncheckedCreateNestedManyWithoutMerchantInput
    customerBalances?: CustomerBalanceUncheckedCreateNestedManyWithoutMerchantInput
    itemCounts?: CustomerItemCountUncheckedCreateNestedManyWithoutMerchantInput
  }

  export type MerchantCreateOrConnectWithoutLedgerEntriesInput = {
    where: MerchantWhereUniqueInput
    create: XOR<MerchantCreateWithoutLedgerEntriesInput, MerchantUncheckedCreateWithoutLedgerEntriesInput>
  }

  export type TransactionCreateWithoutLedgerEntriesInput = {
    id?: string
    posProvider: $Enums.POSProvider
    posTransactionId: string
    posLocationId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    pointsEarned?: number
    status?: $Enums.TransactionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    merchant: MerchantCreateNestedOneWithoutTransactionsInput
    customer?: CustomerCreateNestedOneWithoutTransactionsInput
    location?: LocationCreateNestedOneWithoutTransactionsInput
  }

  export type TransactionUncheckedCreateWithoutLedgerEntriesInput = {
    id?: string
    merchantId: string
    customerId?: string | null
    locationId?: string | null
    posProvider: $Enums.POSProvider
    posTransactionId: string
    posLocationId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    pointsEarned?: number
    status?: $Enums.TransactionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionCreateOrConnectWithoutLedgerEntriesInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutLedgerEntriesInput, TransactionUncheckedCreateWithoutLedgerEntriesInput>
  }

  export type RedemptionCreateWithoutLedgerEntryInput = {
    id?: string
    qrToken: string
    pinCode: string
    status?: $Enums.RedemptionStatus
    pointsDeducted?: number | null
    redeemedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutRedemptionsInput
    merchant: MerchantCreateNestedOneWithoutRedemptionsInput
    reward: RewardCreateNestedOneWithoutRedemptionsInput
  }

  export type RedemptionUncheckedCreateWithoutLedgerEntryInput = {
    id?: string
    customerId: string
    merchantId: string
    rewardId: string
    qrToken: string
    pinCode: string
    status?: $Enums.RedemptionStatus
    pointsDeducted?: number | null
    redeemedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RedemptionCreateOrConnectWithoutLedgerEntryInput = {
    where: RedemptionWhereUniqueInput
    create: XOR<RedemptionCreateWithoutLedgerEntryInput, RedemptionUncheckedCreateWithoutLedgerEntryInput>
  }

  export type CustomerUpsertWithoutLedgerEntriesInput = {
    update: XOR<CustomerUpdateWithoutLedgerEntriesInput, CustomerUncheckedUpdateWithoutLedgerEntriesInput>
    create: XOR<CustomerCreateWithoutLedgerEntriesInput, CustomerUncheckedCreateWithoutLedgerEntriesInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutLedgerEntriesInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutLedgerEntriesInput, CustomerUncheckedUpdateWithoutLedgerEntriesInput>
  }

  export type CustomerUpdateWithoutLedgerEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    linkedCards?: LinkedCardUpdateManyWithoutCustomerNestedInput
    transactions?: TransactionUpdateManyWithoutCustomerNestedInput
    customerBalances?: CustomerBalanceUpdateManyWithoutCustomerNestedInput
    redemptions?: RedemptionUpdateManyWithoutCustomerNestedInput
    itemCounts?: CustomerItemCountUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutLedgerEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    linkedCards?: LinkedCardUncheckedUpdateManyWithoutCustomerNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCustomerNestedInput
    customerBalances?: CustomerBalanceUncheckedUpdateManyWithoutCustomerNestedInput
    redemptions?: RedemptionUncheckedUpdateManyWithoutCustomerNestedInput
    itemCounts?: CustomerItemCountUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type MerchantUpsertWithoutLedgerEntriesInput = {
    update: XOR<MerchantUpdateWithoutLedgerEntriesInput, MerchantUncheckedUpdateWithoutLedgerEntriesInput>
    create: XOR<MerchantCreateWithoutLedgerEntriesInput, MerchantUncheckedCreateWithoutLedgerEntriesInput>
    where?: MerchantWhereInput
  }

  export type MerchantUpdateToOneWithWhereWithoutLedgerEntriesInput = {
    where?: MerchantWhereInput
    data: XOR<MerchantUpdateWithoutLedgerEntriesInput, MerchantUncheckedUpdateWithoutLedgerEntriesInput>
  }

  export type MerchantUpdateWithoutLedgerEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posIntegrations?: POSIntegrationUpdateManyWithoutMerchantNestedInput
    locations?: LocationUpdateManyWithoutMerchantNestedInput
    rewards?: RewardUpdateManyWithoutMerchantNestedInput
    transactions?: TransactionUpdateManyWithoutMerchantNestedInput
    redemptions?: RedemptionUpdateManyWithoutMerchantNestedInput
    customerBalances?: CustomerBalanceUpdateManyWithoutMerchantNestedInput
    itemCounts?: CustomerItemCountUpdateManyWithoutMerchantNestedInput
  }

  export type MerchantUncheckedUpdateWithoutLedgerEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posIntegrations?: POSIntegrationUncheckedUpdateManyWithoutMerchantNestedInput
    locations?: LocationUncheckedUpdateManyWithoutMerchantNestedInput
    rewards?: RewardUncheckedUpdateManyWithoutMerchantNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutMerchantNestedInput
    redemptions?: RedemptionUncheckedUpdateManyWithoutMerchantNestedInput
    customerBalances?: CustomerBalanceUncheckedUpdateManyWithoutMerchantNestedInput
    itemCounts?: CustomerItemCountUncheckedUpdateManyWithoutMerchantNestedInput
  }

  export type TransactionUpsertWithoutLedgerEntriesInput = {
    update: XOR<TransactionUpdateWithoutLedgerEntriesInput, TransactionUncheckedUpdateWithoutLedgerEntriesInput>
    create: XOR<TransactionCreateWithoutLedgerEntriesInput, TransactionUncheckedCreateWithoutLedgerEntriesInput>
    where?: TransactionWhereInput
  }

  export type TransactionUpdateToOneWithWhereWithoutLedgerEntriesInput = {
    where?: TransactionWhereInput
    data: XOR<TransactionUpdateWithoutLedgerEntriesInput, TransactionUncheckedUpdateWithoutLedgerEntriesInput>
  }

  export type TransactionUpdateWithoutLedgerEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    posProvider?: EnumPOSProviderFieldUpdateOperationsInput | $Enums.POSProvider
    posTransactionId?: StringFieldUpdateOperationsInput | string
    posLocationId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pointsEarned?: IntFieldUpdateOperationsInput | number
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    merchant?: MerchantUpdateOneRequiredWithoutTransactionsNestedInput
    customer?: CustomerUpdateOneWithoutTransactionsNestedInput
    location?: LocationUpdateOneWithoutTransactionsNestedInput
  }

  export type TransactionUncheckedUpdateWithoutLedgerEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    merchantId?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    posProvider?: EnumPOSProviderFieldUpdateOperationsInput | $Enums.POSProvider
    posTransactionId?: StringFieldUpdateOperationsInput | string
    posLocationId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pointsEarned?: IntFieldUpdateOperationsInput | number
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RedemptionUpsertWithoutLedgerEntryInput = {
    update: XOR<RedemptionUpdateWithoutLedgerEntryInput, RedemptionUncheckedUpdateWithoutLedgerEntryInput>
    create: XOR<RedemptionCreateWithoutLedgerEntryInput, RedemptionUncheckedCreateWithoutLedgerEntryInput>
    where?: RedemptionWhereInput
  }

  export type RedemptionUpdateToOneWithWhereWithoutLedgerEntryInput = {
    where?: RedemptionWhereInput
    data: XOR<RedemptionUpdateWithoutLedgerEntryInput, RedemptionUncheckedUpdateWithoutLedgerEntryInput>
  }

  export type RedemptionUpdateWithoutLedgerEntryInput = {
    id?: StringFieldUpdateOperationsInput | string
    qrToken?: StringFieldUpdateOperationsInput | string
    pinCode?: StringFieldUpdateOperationsInput | string
    status?: EnumRedemptionStatusFieldUpdateOperationsInput | $Enums.RedemptionStatus
    pointsDeducted?: NullableIntFieldUpdateOperationsInput | number | null
    redeemedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutRedemptionsNestedInput
    merchant?: MerchantUpdateOneRequiredWithoutRedemptionsNestedInput
    reward?: RewardUpdateOneRequiredWithoutRedemptionsNestedInput
  }

  export type RedemptionUncheckedUpdateWithoutLedgerEntryInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    merchantId?: StringFieldUpdateOperationsInput | string
    rewardId?: StringFieldUpdateOperationsInput | string
    qrToken?: StringFieldUpdateOperationsInput | string
    pinCode?: StringFieldUpdateOperationsInput | string
    status?: EnumRedemptionStatusFieldUpdateOperationsInput | $Enums.RedemptionStatus
    pointsDeducted?: NullableIntFieldUpdateOperationsInput | number | null
    redeemedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type POSIntegrationCreateManyMerchantInput = {
    id?: string
    provider: $Enums.POSProvider
    accessToken: string
    refreshToken?: string | null
    providerMerchantId: string
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LocationCreateManyMerchantInput = {
    id?: string
    posIntegrationId: string
    posLocationId: string
    name: string
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    country?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RewardCreateManyMerchantInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.RewardType
    pointsCost?: number | null
    itemName?: string | null
    itemCount?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionCreateManyMerchantInput = {
    id?: string
    customerId?: string | null
    locationId?: string | null
    posProvider: $Enums.POSProvider
    posTransactionId: string
    posLocationId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    pointsEarned?: number
    status?: $Enums.TransactionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RedemptionCreateManyMerchantInput = {
    id?: string
    customerId: string
    rewardId: string
    qrToken: string
    pinCode: string
    status?: $Enums.RedemptionStatus
    pointsDeducted?: number | null
    redeemedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerBalanceCreateManyMerchantInput = {
    id?: string
    customerId: string
    points?: number
    updatedAt?: Date | string
  }

  export type CustomerItemCountCreateManyMerchantInput = {
    id?: string
    customerId: string
    rewardId: string
    itemName: string
    count?: number
    updatedAt?: Date | string
  }

  export type LedgerEntryCreateManyMerchantInput = {
    id?: string
    customerId: string
    type: $Enums.LedgerEntryType
    points: number
    transactionId?: string | null
    redemptionId?: string | null
    createdAt?: Date | string
  }

  export type POSIntegrationUpdateWithoutMerchantInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumPOSProviderFieldUpdateOperationsInput | $Enums.POSProvider
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    providerMerchantId?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locations?: LocationUpdateManyWithoutPosIntegrationNestedInput
  }

  export type POSIntegrationUncheckedUpdateWithoutMerchantInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumPOSProviderFieldUpdateOperationsInput | $Enums.POSProvider
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    providerMerchantId?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locations?: LocationUncheckedUpdateManyWithoutPosIntegrationNestedInput
  }

  export type POSIntegrationUncheckedUpdateManyWithoutMerchantInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumPOSProviderFieldUpdateOperationsInput | $Enums.POSProvider
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    providerMerchantId?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocationUpdateWithoutMerchantInput = {
    id?: StringFieldUpdateOperationsInput | string
    posLocationId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posIntegration?: POSIntegrationUpdateOneRequiredWithoutLocationsNestedInput
    transactions?: TransactionUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateWithoutMerchantInput = {
    id?: StringFieldUpdateOperationsInput | string
    posIntegrationId?: StringFieldUpdateOperationsInput | string
    posLocationId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateManyWithoutMerchantInput = {
    id?: StringFieldUpdateOperationsInput | string
    posIntegrationId?: StringFieldUpdateOperationsInput | string
    posLocationId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RewardUpdateWithoutMerchantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumRewardTypeFieldUpdateOperationsInput | $Enums.RewardType
    pointsCost?: NullableIntFieldUpdateOperationsInput | number | null
    itemName?: NullableStringFieldUpdateOperationsInput | string | null
    itemCount?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posRewardItems?: POSRewardItemUpdateManyWithoutRewardNestedInput
    redemptions?: RedemptionUpdateManyWithoutRewardNestedInput
    itemCounts?: CustomerItemCountUpdateManyWithoutRewardNestedInput
  }

  export type RewardUncheckedUpdateWithoutMerchantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumRewardTypeFieldUpdateOperationsInput | $Enums.RewardType
    pointsCost?: NullableIntFieldUpdateOperationsInput | number | null
    itemName?: NullableStringFieldUpdateOperationsInput | string | null
    itemCount?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posRewardItems?: POSRewardItemUncheckedUpdateManyWithoutRewardNestedInput
    redemptions?: RedemptionUncheckedUpdateManyWithoutRewardNestedInput
    itemCounts?: CustomerItemCountUncheckedUpdateManyWithoutRewardNestedInput
  }

  export type RewardUncheckedUpdateManyWithoutMerchantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumRewardTypeFieldUpdateOperationsInput | $Enums.RewardType
    pointsCost?: NullableIntFieldUpdateOperationsInput | number | null
    itemName?: NullableStringFieldUpdateOperationsInput | string | null
    itemCount?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUpdateWithoutMerchantInput = {
    id?: StringFieldUpdateOperationsInput | string
    posProvider?: EnumPOSProviderFieldUpdateOperationsInput | $Enums.POSProvider
    posTransactionId?: StringFieldUpdateOperationsInput | string
    posLocationId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pointsEarned?: IntFieldUpdateOperationsInput | number
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneWithoutTransactionsNestedInput
    location?: LocationUpdateOneWithoutTransactionsNestedInput
    ledgerEntries?: LedgerEntryUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateWithoutMerchantInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    posProvider?: EnumPOSProviderFieldUpdateOperationsInput | $Enums.POSProvider
    posTransactionId?: StringFieldUpdateOperationsInput | string
    posLocationId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pointsEarned?: IntFieldUpdateOperationsInput | number
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ledgerEntries?: LedgerEntryUncheckedUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateManyWithoutMerchantInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    posProvider?: EnumPOSProviderFieldUpdateOperationsInput | $Enums.POSProvider
    posTransactionId?: StringFieldUpdateOperationsInput | string
    posLocationId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pointsEarned?: IntFieldUpdateOperationsInput | number
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RedemptionUpdateWithoutMerchantInput = {
    id?: StringFieldUpdateOperationsInput | string
    qrToken?: StringFieldUpdateOperationsInput | string
    pinCode?: StringFieldUpdateOperationsInput | string
    status?: EnumRedemptionStatusFieldUpdateOperationsInput | $Enums.RedemptionStatus
    pointsDeducted?: NullableIntFieldUpdateOperationsInput | number | null
    redeemedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutRedemptionsNestedInput
    reward?: RewardUpdateOneRequiredWithoutRedemptionsNestedInput
    ledgerEntry?: LedgerEntryUpdateOneWithoutRedemptionNestedInput
  }

  export type RedemptionUncheckedUpdateWithoutMerchantInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    rewardId?: StringFieldUpdateOperationsInput | string
    qrToken?: StringFieldUpdateOperationsInput | string
    pinCode?: StringFieldUpdateOperationsInput | string
    status?: EnumRedemptionStatusFieldUpdateOperationsInput | $Enums.RedemptionStatus
    pointsDeducted?: NullableIntFieldUpdateOperationsInput | number | null
    redeemedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ledgerEntry?: LedgerEntryUncheckedUpdateOneWithoutRedemptionNestedInput
  }

  export type RedemptionUncheckedUpdateManyWithoutMerchantInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    rewardId?: StringFieldUpdateOperationsInput | string
    qrToken?: StringFieldUpdateOperationsInput | string
    pinCode?: StringFieldUpdateOperationsInput | string
    status?: EnumRedemptionStatusFieldUpdateOperationsInput | $Enums.RedemptionStatus
    pointsDeducted?: NullableIntFieldUpdateOperationsInput | number | null
    redeemedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerBalanceUpdateWithoutMerchantInput = {
    id?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutCustomerBalancesNestedInput
  }

  export type CustomerBalanceUncheckedUpdateWithoutMerchantInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerBalanceUncheckedUpdateManyWithoutMerchantInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerItemCountUpdateWithoutMerchantInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemName?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutItemCountsNestedInput
    reward?: RewardUpdateOneRequiredWithoutItemCountsNestedInput
  }

  export type CustomerItemCountUncheckedUpdateWithoutMerchantInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    rewardId?: StringFieldUpdateOperationsInput | string
    itemName?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerItemCountUncheckedUpdateManyWithoutMerchantInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    rewardId?: StringFieldUpdateOperationsInput | string
    itemName?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LedgerEntryUpdateWithoutMerchantInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumLedgerEntryTypeFieldUpdateOperationsInput | $Enums.LedgerEntryType
    points?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutLedgerEntriesNestedInput
    transaction?: TransactionUpdateOneWithoutLedgerEntriesNestedInput
    redemption?: RedemptionUpdateOneWithoutLedgerEntryNestedInput
  }

  export type LedgerEntryUncheckedUpdateWithoutMerchantInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    type?: EnumLedgerEntryTypeFieldUpdateOperationsInput | $Enums.LedgerEntryType
    points?: IntFieldUpdateOperationsInput | number
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    redemptionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LedgerEntryUncheckedUpdateManyWithoutMerchantInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    type?: EnumLedgerEntryTypeFieldUpdateOperationsInput | $Enums.LedgerEntryType
    points?: IntFieldUpdateOperationsInput | number
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    redemptionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocationCreateManyPosIntegrationInput = {
    id?: string
    merchantId: string
    posLocationId: string
    name: string
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    country?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LocationUpdateWithoutPosIntegrationInput = {
    id?: StringFieldUpdateOperationsInput | string
    posLocationId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    merchant?: MerchantUpdateOneRequiredWithoutLocationsNestedInput
    transactions?: TransactionUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateWithoutPosIntegrationInput = {
    id?: StringFieldUpdateOperationsInput | string
    merchantId?: StringFieldUpdateOperationsInput | string
    posLocationId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateManyWithoutPosIntegrationInput = {
    id?: StringFieldUpdateOperationsInput | string
    merchantId?: StringFieldUpdateOperationsInput | string
    posLocationId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionCreateManyLocationInput = {
    id?: string
    merchantId: string
    customerId?: string | null
    posProvider: $Enums.POSProvider
    posTransactionId: string
    posLocationId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    pointsEarned?: number
    status?: $Enums.TransactionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    posProvider?: EnumPOSProviderFieldUpdateOperationsInput | $Enums.POSProvider
    posTransactionId?: StringFieldUpdateOperationsInput | string
    posLocationId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pointsEarned?: IntFieldUpdateOperationsInput | number
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    merchant?: MerchantUpdateOneRequiredWithoutTransactionsNestedInput
    customer?: CustomerUpdateOneWithoutTransactionsNestedInput
    ledgerEntries?: LedgerEntryUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    merchantId?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    posProvider?: EnumPOSProviderFieldUpdateOperationsInput | $Enums.POSProvider
    posTransactionId?: StringFieldUpdateOperationsInput | string
    posLocationId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pointsEarned?: IntFieldUpdateOperationsInput | number
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ledgerEntries?: LedgerEntryUncheckedUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateManyWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    merchantId?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    posProvider?: EnumPOSProviderFieldUpdateOperationsInput | $Enums.POSProvider
    posTransactionId?: StringFieldUpdateOperationsInput | string
    posLocationId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pointsEarned?: IntFieldUpdateOperationsInput | number
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LinkedCardCreateManyCustomerInput = {
    id?: string
    cardFingerprint: string
    last4: string
    brand?: string | null
    zipCode?: string | null
    posProvider: $Enums.POSProvider
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionCreateManyCustomerInput = {
    id?: string
    merchantId: string
    locationId?: string | null
    posProvider: $Enums.POSProvider
    posTransactionId: string
    posLocationId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    pointsEarned?: number
    status?: $Enums.TransactionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerBalanceCreateManyCustomerInput = {
    id?: string
    merchantId: string
    points?: number
    updatedAt?: Date | string
  }

  export type RedemptionCreateManyCustomerInput = {
    id?: string
    merchantId: string
    rewardId: string
    qrToken: string
    pinCode: string
    status?: $Enums.RedemptionStatus
    pointsDeducted?: number | null
    redeemedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LedgerEntryCreateManyCustomerInput = {
    id?: string
    merchantId: string
    type: $Enums.LedgerEntryType
    points: number
    transactionId?: string | null
    redemptionId?: string | null
    createdAt?: Date | string
  }

  export type CustomerItemCountCreateManyCustomerInput = {
    id?: string
    merchantId: string
    rewardId: string
    itemName: string
    count?: number
    updatedAt?: Date | string
  }

  export type LinkedCardUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    cardFingerprint?: StringFieldUpdateOperationsInput | string
    last4?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    posProvider?: EnumPOSProviderFieldUpdateOperationsInput | $Enums.POSProvider
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LinkedCardUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    cardFingerprint?: StringFieldUpdateOperationsInput | string
    last4?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    posProvider?: EnumPOSProviderFieldUpdateOperationsInput | $Enums.POSProvider
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LinkedCardUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    cardFingerprint?: StringFieldUpdateOperationsInput | string
    last4?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    posProvider?: EnumPOSProviderFieldUpdateOperationsInput | $Enums.POSProvider
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    posProvider?: EnumPOSProviderFieldUpdateOperationsInput | $Enums.POSProvider
    posTransactionId?: StringFieldUpdateOperationsInput | string
    posLocationId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pointsEarned?: IntFieldUpdateOperationsInput | number
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    merchant?: MerchantUpdateOneRequiredWithoutTransactionsNestedInput
    location?: LocationUpdateOneWithoutTransactionsNestedInput
    ledgerEntries?: LedgerEntryUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    merchantId?: StringFieldUpdateOperationsInput | string
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    posProvider?: EnumPOSProviderFieldUpdateOperationsInput | $Enums.POSProvider
    posTransactionId?: StringFieldUpdateOperationsInput | string
    posLocationId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pointsEarned?: IntFieldUpdateOperationsInput | number
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ledgerEntries?: LedgerEntryUncheckedUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    merchantId?: StringFieldUpdateOperationsInput | string
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    posProvider?: EnumPOSProviderFieldUpdateOperationsInput | $Enums.POSProvider
    posTransactionId?: StringFieldUpdateOperationsInput | string
    posLocationId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pointsEarned?: IntFieldUpdateOperationsInput | number
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerBalanceUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    merchant?: MerchantUpdateOneRequiredWithoutCustomerBalancesNestedInput
  }

  export type CustomerBalanceUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    merchantId?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerBalanceUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    merchantId?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RedemptionUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    qrToken?: StringFieldUpdateOperationsInput | string
    pinCode?: StringFieldUpdateOperationsInput | string
    status?: EnumRedemptionStatusFieldUpdateOperationsInput | $Enums.RedemptionStatus
    pointsDeducted?: NullableIntFieldUpdateOperationsInput | number | null
    redeemedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    merchant?: MerchantUpdateOneRequiredWithoutRedemptionsNestedInput
    reward?: RewardUpdateOneRequiredWithoutRedemptionsNestedInput
    ledgerEntry?: LedgerEntryUpdateOneWithoutRedemptionNestedInput
  }

  export type RedemptionUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    merchantId?: StringFieldUpdateOperationsInput | string
    rewardId?: StringFieldUpdateOperationsInput | string
    qrToken?: StringFieldUpdateOperationsInput | string
    pinCode?: StringFieldUpdateOperationsInput | string
    status?: EnumRedemptionStatusFieldUpdateOperationsInput | $Enums.RedemptionStatus
    pointsDeducted?: NullableIntFieldUpdateOperationsInput | number | null
    redeemedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ledgerEntry?: LedgerEntryUncheckedUpdateOneWithoutRedemptionNestedInput
  }

  export type RedemptionUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    merchantId?: StringFieldUpdateOperationsInput | string
    rewardId?: StringFieldUpdateOperationsInput | string
    qrToken?: StringFieldUpdateOperationsInput | string
    pinCode?: StringFieldUpdateOperationsInput | string
    status?: EnumRedemptionStatusFieldUpdateOperationsInput | $Enums.RedemptionStatus
    pointsDeducted?: NullableIntFieldUpdateOperationsInput | number | null
    redeemedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LedgerEntryUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumLedgerEntryTypeFieldUpdateOperationsInput | $Enums.LedgerEntryType
    points?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    merchant?: MerchantUpdateOneRequiredWithoutLedgerEntriesNestedInput
    transaction?: TransactionUpdateOneWithoutLedgerEntriesNestedInput
    redemption?: RedemptionUpdateOneWithoutLedgerEntryNestedInput
  }

  export type LedgerEntryUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    merchantId?: StringFieldUpdateOperationsInput | string
    type?: EnumLedgerEntryTypeFieldUpdateOperationsInput | $Enums.LedgerEntryType
    points?: IntFieldUpdateOperationsInput | number
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    redemptionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LedgerEntryUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    merchantId?: StringFieldUpdateOperationsInput | string
    type?: EnumLedgerEntryTypeFieldUpdateOperationsInput | $Enums.LedgerEntryType
    points?: IntFieldUpdateOperationsInput | number
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    redemptionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerItemCountUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemName?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    merchant?: MerchantUpdateOneRequiredWithoutItemCountsNestedInput
    reward?: RewardUpdateOneRequiredWithoutItemCountsNestedInput
  }

  export type CustomerItemCountUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    merchantId?: StringFieldUpdateOperationsInput | string
    rewardId?: StringFieldUpdateOperationsInput | string
    itemName?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerItemCountUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    merchantId?: StringFieldUpdateOperationsInput | string
    rewardId?: StringFieldUpdateOperationsInput | string
    itemName?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LedgerEntryCreateManyTransactionInput = {
    id?: string
    customerId: string
    merchantId: string
    type: $Enums.LedgerEntryType
    points: number
    redemptionId?: string | null
    createdAt?: Date | string
  }

  export type LedgerEntryUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumLedgerEntryTypeFieldUpdateOperationsInput | $Enums.LedgerEntryType
    points?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutLedgerEntriesNestedInput
    merchant?: MerchantUpdateOneRequiredWithoutLedgerEntriesNestedInput
    redemption?: RedemptionUpdateOneWithoutLedgerEntryNestedInput
  }

  export type LedgerEntryUncheckedUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    merchantId?: StringFieldUpdateOperationsInput | string
    type?: EnumLedgerEntryTypeFieldUpdateOperationsInput | $Enums.LedgerEntryType
    points?: IntFieldUpdateOperationsInput | number
    redemptionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LedgerEntryUncheckedUpdateManyWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    merchantId?: StringFieldUpdateOperationsInput | string
    type?: EnumLedgerEntryTypeFieldUpdateOperationsInput | $Enums.LedgerEntryType
    points?: IntFieldUpdateOperationsInput | number
    redemptionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type POSRewardItemCreateManyRewardInput = {
    id?: string
    posProvider: $Enums.POSProvider
    posItemId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RedemptionCreateManyRewardInput = {
    id?: string
    customerId: string
    merchantId: string
    qrToken: string
    pinCode: string
    status?: $Enums.RedemptionStatus
    pointsDeducted?: number | null
    redeemedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerItemCountCreateManyRewardInput = {
    id?: string
    customerId: string
    merchantId: string
    itemName: string
    count?: number
    updatedAt?: Date | string
  }

  export type POSRewardItemUpdateWithoutRewardInput = {
    id?: StringFieldUpdateOperationsInput | string
    posProvider?: EnumPOSProviderFieldUpdateOperationsInput | $Enums.POSProvider
    posItemId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type POSRewardItemUncheckedUpdateWithoutRewardInput = {
    id?: StringFieldUpdateOperationsInput | string
    posProvider?: EnumPOSProviderFieldUpdateOperationsInput | $Enums.POSProvider
    posItemId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type POSRewardItemUncheckedUpdateManyWithoutRewardInput = {
    id?: StringFieldUpdateOperationsInput | string
    posProvider?: EnumPOSProviderFieldUpdateOperationsInput | $Enums.POSProvider
    posItemId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RedemptionUpdateWithoutRewardInput = {
    id?: StringFieldUpdateOperationsInput | string
    qrToken?: StringFieldUpdateOperationsInput | string
    pinCode?: StringFieldUpdateOperationsInput | string
    status?: EnumRedemptionStatusFieldUpdateOperationsInput | $Enums.RedemptionStatus
    pointsDeducted?: NullableIntFieldUpdateOperationsInput | number | null
    redeemedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutRedemptionsNestedInput
    merchant?: MerchantUpdateOneRequiredWithoutRedemptionsNestedInput
    ledgerEntry?: LedgerEntryUpdateOneWithoutRedemptionNestedInput
  }

  export type RedemptionUncheckedUpdateWithoutRewardInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    merchantId?: StringFieldUpdateOperationsInput | string
    qrToken?: StringFieldUpdateOperationsInput | string
    pinCode?: StringFieldUpdateOperationsInput | string
    status?: EnumRedemptionStatusFieldUpdateOperationsInput | $Enums.RedemptionStatus
    pointsDeducted?: NullableIntFieldUpdateOperationsInput | number | null
    redeemedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ledgerEntry?: LedgerEntryUncheckedUpdateOneWithoutRedemptionNestedInput
  }

  export type RedemptionUncheckedUpdateManyWithoutRewardInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    merchantId?: StringFieldUpdateOperationsInput | string
    qrToken?: StringFieldUpdateOperationsInput | string
    pinCode?: StringFieldUpdateOperationsInput | string
    status?: EnumRedemptionStatusFieldUpdateOperationsInput | $Enums.RedemptionStatus
    pointsDeducted?: NullableIntFieldUpdateOperationsInput | number | null
    redeemedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerItemCountUpdateWithoutRewardInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemName?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutItemCountsNestedInput
    merchant?: MerchantUpdateOneRequiredWithoutItemCountsNestedInput
  }

  export type CustomerItemCountUncheckedUpdateWithoutRewardInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    merchantId?: StringFieldUpdateOperationsInput | string
    itemName?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerItemCountUncheckedUpdateManyWithoutRewardInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    merchantId?: StringFieldUpdateOperationsInput | string
    itemName?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use MerchantCountOutputTypeDefaultArgs instead
     */
    export type MerchantCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MerchantCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use POSIntegrationCountOutputTypeDefaultArgs instead
     */
    export type POSIntegrationCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = POSIntegrationCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LocationCountOutputTypeDefaultArgs instead
     */
    export type LocationCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LocationCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CustomerCountOutputTypeDefaultArgs instead
     */
    export type CustomerCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CustomerCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TransactionCountOutputTypeDefaultArgs instead
     */
    export type TransactionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TransactionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RewardCountOutputTypeDefaultArgs instead
     */
    export type RewardCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RewardCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MerchantDefaultArgs instead
     */
    export type MerchantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MerchantDefaultArgs<ExtArgs>
    /**
     * @deprecated Use POSIntegrationDefaultArgs instead
     */
    export type POSIntegrationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = POSIntegrationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LocationDefaultArgs instead
     */
    export type LocationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LocationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CustomerDefaultArgs instead
     */
    export type CustomerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CustomerDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LinkedCardDefaultArgs instead
     */
    export type LinkedCardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LinkedCardDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TransactionDefaultArgs instead
     */
    export type TransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TransactionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CustomerBalanceDefaultArgs instead
     */
    export type CustomerBalanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CustomerBalanceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RewardDefaultArgs instead
     */
    export type RewardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RewardDefaultArgs<ExtArgs>
    /**
     * @deprecated Use POSRewardItemDefaultArgs instead
     */
    export type POSRewardItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = POSRewardItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RedemptionDefaultArgs instead
     */
    export type RedemptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RedemptionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CustomerItemCountDefaultArgs instead
     */
    export type CustomerItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CustomerItemCountDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LedgerEntryDefaultArgs instead
     */
    export type LedgerEntryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LedgerEntryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WebhookLogDefaultArgs instead
     */
    export type WebhookLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WebhookLogDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}